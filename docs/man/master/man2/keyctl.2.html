
<!DOCTYPE HTML>
<head>
	<title>/usr/share/man/man2/keyctl.2</title>
	<link rel='stylesheet' href='/mandoc.css' />
	<link rel='stylesheet' href='/style.css' />
</head>
<body>
	<div class=contents>
	<h1>The Fidelix Linux Distribution</h1>
	<h2>Simple, Stable, and Secure</h2>
<div class=menubar>
	<ul>
		<li><a href=/>News</a></li>
		<li><a href=/about.html>About</a></li>
		<li><a href=/download.html>Download</a></li>
		<div class=dropdown>
			<li><a href=/documentation.html>Documentation</a></li>
			<ul class=dropdown-content>
				<li><a href=/handbook/>Handbook</a></li>
				<li><a href=/man/>Manual Pages</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=/development.html>Development</a></li>
			<ul class=dropdown-content>
				<li><a href=https://github.com/Z5T1/fidelix>GitHub</a></li>
			</ul>
		</div>
	</ul>
</div>

<table class="head">
  <tr>
    <td class="head-ltitle">KEYCTL(2)</td>
    <td class="head-vol">Linux Key Management Calls</td>
    <td class="head-rtitle">KEYCTL(2)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
keyctl - manipulate the kernel's key management facility
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
<b>#include &lt;sys/types.h&gt;</b>
<b>#include &lt;keyutils.h&gt;</b>
</pre>
<pre>
<b>long keyctl(int </b><i>operation</i><b>, ...)</b>
<b>/* For direct call via syscall(2): */</b>
<b>#include &lt;asm/unistd.h&gt;</b>
<b>#include &lt;linux/keyctl.h&gt;</b>
<b>#include &lt;unistd.h&gt;</b>
</pre>
<pre>
<b>long syscall(__NR_keyctl, int </b><i>operation</i><b>, __kernel_ulong_t </b><i>arg2</i><b>,</b>
<b>             __kernel_ulong_t </b><i>arg3</i><b>, __kernel_ulong_t </b><i>arg4</i><b>,</b>
<b>             __kernel_ulong_t </b><i>arg5</i><b>);</b>
</pre>
<p class="Pp">No glibc wrapper is provided for this system call; see NOTES.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>keyctl</b>() allows user-space programs to perform key manipulation.
<p class="Pp">The operation performed by <b>keyctl</b>() is determined by the
    value of the <i>operation</i> argument. Each of these operations is wrapped
    by the <i>libkeyutils</i> library (provided by the <i>keyutils</i> package)
    into individual functions (noted below) to permit the compiler to check
    types.</p>
<p class="Pp">The permitted values for <i>operation</i> are:</p>
<dl class="Bl-tag">
  <dt><b>KEYCTL_GET_KEYRING_ID</b> (since Linux 2.6.10)</dt>
  <dd>Map a special key ID to a real key ID for this process.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This operation looks up the special key whose ID is provided in
      <i>arg2</i> (cast to <i>key_serial_t</i>). If the special key is found,
      the ID of the corresponding real key is returned as the function result.
      The following values may be specified in <i>arg2</i>:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>KEY_SPEC_THREAD_KEYRING</b></dt>
  <dd>This specifies the calling thread's thread-specific keyring. See
      <b>thread-keyring</b>(7).</dd>
  <dt><b>KEY_SPEC_PROCESS_KEYRING</b></dt>
  <dd>This specifies the caller's process-specific keyring. See
      <b>process-keyring</b>(7).</dd>
  <dt><b>KEY_SPEC_SESSION_KEYRING</b></dt>
  <dd>This specifies the caller's session-specific keyring. See
      <b>session-keyring</b>(7).</dd>
  <dt><b>KEY_SPEC_USER_KEYRING</b></dt>
  <dd>This specifies the caller's UID-specific keyring. See
      <b>user-keyring</b>(7).</dd>
  <dt><b>KEY_SPEC_USER_SESSION_KEYRING</b></dt>
  <dd>This specifies the caller's UID-session keyring. See
      <b>user-session-keyring</b>(7).</dd>
  <dt><b>KEY_SPEC_REQKEY_AUTH_KEY</b> (since Linux 2.6.16)</dt>
  <dd>This specifies the authorization key created by <b>request_key</b>(2) and
      passed to the process it spawns to generate a key. This key is available
      only in a <b>request-key</b>(8)-style program that was passed an
      authorization key by the kernel and ceases to be available once the
      requested key has been instantiated; see <b>request_key</b>(2).</dd>
  <dt><b>KEY_SPEC_REQUESTOR_KEYRING</b> (since Linux 2.6.29)</dt>
  <dd>This specifies the key ID for the <b>request_key</b>(2) destination
      keyring. This keyring is available only in a <b>request-key</b>(8)-style
      program that was passed an authorization key by the kernel and ceases to
      be available once the requested key has been instantiated; see
      <b>request_key</b>(2).</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The behavior if the key specified in <i>arg2</i> does not exist depends on
      the value of <i>arg3</i> (cast to <i>int</i>). If <i>arg3</i> contains a
      nonzero value, then&#x2014;if it is appropriate to do so (e.g., when
      looking up the user, user-session, or session key)&#x2014;a new key is
      created and its real key ID returned as the function result. Otherwise,
      the operation fails with the error <b>ENOKEY</b>.</dd>
  <dt></dt>
  <dd>If a valid key ID is specified in <i>arg2</i>, and the key exists, then
      this operation simply returns the key ID. If the key does not exist, the
      call fails with error <b>ENOKEY</b>.</dd>
  <dt></dt>
  <dd>The caller must have <i>search</i> permission on a keyring in order for it
      to be found.</dd>
  <dt></dt>
  <dd>The arguments <i>arg4</i> and <i>arg5</i> are ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_get_keyring_ID</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_JOIN_SESSION_KEYRING</b> (since Linux 2.6.10)</dt>
  <dd>Replace the session keyring this process subscribes to with a new session
      keyring.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If <i>arg2</i> is NULL, an anonymous keyring with the description
      &quot;_ses&quot; is created and the process is subscribed to that keyring
      as its session keyring, displacing the previous session keyring.</dd>
  <dt></dt>
  <dd>Otherwise, <i>arg2</i> (cast to <i>char&#x00A0;*</i>) is treated as the
      description (name) of a keyring, and the behavior is as follows:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>If a keyring with a matching description exists, the process will attempt
      to subscribe to that keyring as its session keyring if possible; if that
      is not possible, an error is returned. In order to subscribe to the
      keyring, the caller must have <i>search</i> permission on the
    keyring.</li>
  <li>If a keyring with a matching description does not exist, then a new
      keyring with the specified description is created, and the process is
      subscribed to that keyring as its session keyring.</li>
</ul>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_join_session_keyring</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_UPDATE</b> (since Linux 2.6.10)</dt>
  <dd>Update a key's data payload.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <i>arg2</i> argument (cast to <i>key_serial_t</i>) specifies the ID of
      the key to be updated. The <i>arg3</i> argument (cast to
      <i>void&#x00A0;*</i>) points to the new payload and <i>arg4</i> (cast to
      <i>size_t</i>) contains the new payload size in bytes.</dd>
  <dt></dt>
  <dd>The caller must have <i>write</i> permission on the key specified and the
      key type must support updating.</dd>
  <dt></dt>
  <dd>A negatively instantiated key (see the description of
      <b>KEYCTL_REJECT</b>) can be positively instantiated with this
    operation.</dd>
  <dt></dt>
  <dd>The <i>arg5</i> argument is ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_update</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_REVOKE</b> (since Linux 2.6.10)</dt>
  <dd>Revoke the key with the ID provided in <i>arg2</i> (cast to
      <i>key_serial_t</i>). The key is scheduled for garbage collection; it will
      no longer be findable, and will be unavailable for further operations.
      Further attempts to use the key will fail with the error
      <b>EKEYREVOKED</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The caller must have <i>write</i> or <i>setattr</i> permission on the
    key.</dd>
  <dt></dt>
  <dd>The arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_revoke</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_CHOWN</b> (since Linux 2.6.10)</dt>
  <dd>Change the ownership (user and group ID) of a key.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <i>arg2</i> argument (cast to <i>key_serial_t</i>) contains the key
      ID. The <i>arg3</i> argument (cast to <i>uid_t</i>) contains the new user
      ID (or -1 in case the user ID shouldn't be changed). The <i>arg4</i>
      argument (cast to <i>gid_t</i>) contains the new group ID (or -1 in case
      the group ID shouldn't be changed).</dd>
  <dt></dt>
  <dd>The key must grant the caller <i>setattr</i> permission.</dd>
  <dt></dt>
  <dd>For the UID to be changed, or for the GID to be changed to a group the
      caller is not a member of, the caller must have the <b>CAP_SYS_ADMIN</b>
      capability (see <b>capabilities</b>(7)).</dd>
  <dt></dt>
  <dd>If the UID is to be changed, the new user must have sufficient quota to
      accept the key. The quota deduction will be removed from the old user to
      the new user should the UID be changed.</dd>
  <dt></dt>
  <dd>The <i>arg5</i> argument is ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_chown</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_SETPERM</b> (since Linux 2.6.10)</dt>
  <dd>Change the permissions of the key with the ID provided in the <i>arg2</i>
      argument (cast to <i>key_serial_t</i>) to the permissions provided in the
      <i>arg3</i> argument (cast to <i>key_perm_t</i>).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If the caller doesn't have the <b>CAP_SYS_ADMIN</b> capability, it can
      change permissions only for the keys it owns. (More precisely: the
      caller's filesystem UID must match the UID of the key.)</dd>
  <dt></dt>
  <dd>The key must grant <i>setattr</i> permission to the caller
      <i>regardless</i> of the caller's capabilities.</dd>
  <dt></dt>
  <dd>The permissions in <i>arg3</i> specify masks of available operations for
      each of the following user categories:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><i>possessor</i> (since Linux 2.6.14)</dt>
  <dd>This is the permission granted to a process that possesses the key (has it
      attached searchably to one of the process's keyrings); see
      <b>keyrings</b>(7).</dd>
  <dt><i>user</i></dt>
  <dd>This is the permission granted to a process whose filesystem UID matches
      the UID of the key.</dd>
  <dt><i>group</i></dt>
  <dd>This is the permission granted to a process whose filesystem GID or any of
      its supplementary GIDs matches the GID of the key.</dd>
  <dt><i>other</i></dt>
  <dd>This is the permission granted to other processes that do not match the
      <i>user</i> and <i>group</i> categories.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <i>user</i>, <i>group</i>, and <i>other</i> categories are exclusive:
      if a process matches the <i>user</i> category, it will not receive
      permissions granted in the <i>group</i> category; if a process matches the
      <i>user</i> or <i>group</i> category, then it will not receive permissions
      granted in the <i>other</i> category.</dd>
  <dt></dt>
  <dd>The <i>possessor</i> category grants permissions that are cumulative with
      the grants from the <i>user</i>, <i>group</i>, or <i>other</i>
    category.</dd>
  <dt></dt>
  <dd>Each permission mask is eight bits in size, with only six bits currently
      used. The available permissions are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><i>view</i></dt>
  <dd>This permission allows reading attributes of a key.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This permission is required for the <b>KEYCTL_DESCRIBE</b> operation.</dd>
  <dt></dt>
  <dd>The permission bits for each category are <b>KEY_POS_VIEW</b>,
      <b>KEY_USR_VIEW</b>, <b>KEY_GRP_VIEW</b>, and <b>KEY_OTH_VIEW</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt><i>read</i></dt>
  <dd>This permission allows reading a key's payload.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This permission is required for the <b>KEYCTL_READ</b> operation.</dd>
  <dt></dt>
  <dd>The permission bits for each category are <b>KEY_POS_READ</b>,
      <b>KEY_USR_READ</b>, <b>KEY_GRP_READ</b>, and <b>KEY_OTH_READ</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt><i>write</i></dt>
  <dd>This permission allows update or instantiation of a key's payload. For a
      keyring, it allows keys to be linked and unlinked from the keyring,</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This permission is required for the <b>KEYCTL_UPDATE</b>,
      <b>KEYCTL_REVOKE</b>, <b>KEYCTL_CLEAR</b>, <b>KEYCTL_LINK</b>, and
      <b>KEYCTL_UNLINK</b> operations.</dd>
  <dt></dt>
  <dd>The permission bits for each category are <b>KEY_POS_WRITE</b>,
      <b>KEY_USR_WRITE</b>, <b>KEY_GRP_WRITE</b>, and <b>KEY_OTH_WRITE</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt><i>search</i></dt>
  <dd>This permission allows keyrings to be searched and keys to be found.
      Searches can recurse only into nested keyrings that have <i>search</i>
      permission set.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This permission is required for the <b>KEYCTL_GET_KEYRING_ID</b>,
      <b>KEYCTL_JOIN_SESSION_KEYRING</b>, <b>KEYCTL_SEARCH</b>, and
      <b>KEYCTL_INVALIDATE</b> operations.</dd>
  <dt></dt>
  <dd>The permission bits for each category are <b>KEY_POS_SEARCH</b>,
      <b>KEY_USR_SEARCH</b>, <b>KEY_GRP_SEARCH</b>, and
    <b>KEY_OTH_SEARCH</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt><i>link</i></dt>
  <dd>This permission allows a key or keyring to be linked to.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This permission is required for the <b>KEYCTL_LINK</b> and
      <b>KEYCTL_SESSION_TO_PARENT</b> operations.</dd>
  <dt></dt>
  <dd>The permission bits for each category are <b>KEY_POS_LINK</b>,
      <b>KEY_USR_LINK</b>, <b>KEY_GRP_LINK</b>, and <b>KEY_OTH_LINK</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt><i>setattr</i> (since Linux 2.6.15).</dt>
  <dd>This permission allows a key's UID, GID, and permissions mask to be
      changed.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This permission is required for the <b>KEYCTL_REVOKE</b>,
      <b>KEYCTL_CHOWN</b>, and <b>KEYCTL_SETPERM</b> operations.</dd>
  <dt></dt>
  <dd>The permission bits for each category are <b>KEY_POS_SETATTR</b>,
      <b>KEY_USR_SETATTR</b>, <b>KEY_GRP_SETATTR</b>, and
      <b>KEY_OTH_SETATTR</b>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>As a convenience, the following macros are defined as masks for all of the
      permission bits in each of the user categories: <b>KEY_POS_ALL</b>,
      <b>KEY_USR_ALL</b>, <b>KEY_GRP_ALL</b>, and <b>KEY_OTH_ALL</b>.</dd>
  <dt></dt>
  <dd>The <i>arg4</i> and <i>arg5</i> arguments are ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_setperm</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_DESCRIBE</b> (since Linux 2.6.10)</dt>
  <dd>Obtain a string describing the attributes of a specified key.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The ID of the key to be described is specified in <i>arg2</i> (cast to
      <i>key_serial_t</i>). The descriptive string is returned in the buffer
      pointed to by <i>arg3</i> (cast to <i>char&#x00A0;*</i>); <i>arg4</i>
      (cast to <i>size_t</i>) specifies the size of that buffer in bytes.</dd>
  <dt></dt>
  <dd>The key must grant the caller <i>view</i> permission.</dd>
  <dt></dt>
  <dd>The returned string is null-terminated and contains the following
      information about the key:</dd>
  <dt></dt>
  <dd>
    <br/>
    <i>type</i>;<i>uid</i>;<i>gid</i>;<i>perm</i>;<i>description</i>
    <br/>
  </dd>
  <dt></dt>
  <dd>In the above, <i>type</i> and <i>description</i> are strings, <i>uid</i>
      and <i>gid</i> are decimal strings, and <i>perm</i> is a hexadecimal
      permissions mask. The descriptive string is written with the following
      format:</dd>
  <dt></dt>
  <dd>
     %s;%d;%d;%08x;%s</dd>
  <dt></dt>
  <dd><b>Note: the intention is that the descriptive string should</b> <b>be
      extensible in future kernel versions</b>. In particular, the
      <i>description</i> field will not contain semicolons; it should be parsed
      by working backwards from the end of the string to find the last
      semicolon. This allows future semicolon-delimited fields to be inserted in
      the descriptive string in the future.</dd>
  <dt></dt>
  <dd>Writing to the buffer is attempted only when <i>arg3</i> is non-NULL and
      the specified buffer size is large enough to accept the descriptive string
      (including the terminating null byte). In order to determine whether the
      buffer size was too small, check to see if the return value of the
      operation is greater than <i>arg4</i>.</dd>
  <dt></dt>
  <dd>The <i>arg5</i> argument is ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_describe</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_CLEAR</b></dt>
  <dd>Clear the contents of (i.e., unlink all keys from) a keyring.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The ID of the key (which must be of keyring type) is provided in
      <i>arg2</i> (cast to <i>key_serial_t</i>).</dd>
  <dt></dt>
  <dd>The caller must have <i>write</i> permission on the keyring.</dd>
  <dt></dt>
  <dd>The arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_clear</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_LINK</b> (since Linux 2.6.10)</dt>
  <dd>Create a link from a keyring to a key.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The key to be linked is specified in <i>arg2</i> (cast to
      <i>key_serial_t</i>); the keyring is specified in <i>arg3</i> (cast to
      <i>key_serial_t</i>).</dd>
  <dt></dt>
  <dd>If a key with the same type and description is already linked in the
      keyring, then that key is displaced from the keyring.</dd>
  <dt></dt>
  <dd>Before creating the link, the kernel checks the nesting of the keyrings
      and returns appropriate errors if the link would produce a cycle or if the
      nesting of keyrings would be too deep (The limit on the nesting of
      keyrings is determined by the kernel constant
      <b>KEYRING_SEARCH_MAX_DEPTH</b>, defined with the value 6, and is
      necessary to prevent overflows on the kernel stack when recursively
      searching keyrings).</dd>
  <dt></dt>
  <dd>The caller must have <i>link</i> permission on the key being added and
      <i>write</i> permission on the keyring.</dd>
  <dt></dt>
  <dd>The arguments <i>arg4</i> and <i>arg5</i> are ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_link</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_UNLINK</b> (since Linux 2.6.10)</dt>
  <dd>Unlink a key from a keyring.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The ID of the key to be unlinked is specified in <i>arg2</i> (cast to
      <i>key_serial_t</i>); the ID of the keyring from which it is to be
      unlinked is specified in <i>arg3</i> (cast to <i>key_serial_t</i>).</dd>
  <dt></dt>
  <dd>If the key is not currently linked into the keyring, an error
    results.</dd>
  <dt></dt>
  <dd>The caller must have <i>write</i> permission on the keyring from which the
      key is being removed.</dd>
  <dt></dt>
  <dd>If the last link to a key is removed, then that key will be scheduled for
      destruction.</dd>
  <dt></dt>
  <dd>The arguments <i>arg4</i> and <i>arg5</i> are ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_unlink</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_SEARCH</b> (since Linux 2.6.10)</dt>
  <dd>Search for a key in a keyring tree, returning its ID and optionally
      linking it to a specified keyring.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The tree to be searched is specified by passing the ID of the head keyring
      in <i>arg2</i> (cast to <i>key_serial_t</i>). The search is performed
      breadth-first and recursively.</dd>
  <dt></dt>
  <dd>The <i>arg3</i> and <i>arg4</i> arguments specify the key to be searched
      for: <i>arg3</i> (cast as <i>char&#x00A0;*</i>) contains the key type (a
      null-terminated character string up to 32 bytes in size, including the
      terminating null byte), and <i>arg4</i> (cast as <i>char&#x00A0;*</i>)
      contains the description of the key (a null-terminated character string up
      to 4096 bytes in size, including the terminating null byte).</dd>
  <dt></dt>
  <dd>The source keyring must grant <i>search</i> permission to the caller. When
      performing the recursive search, only keyrings that grant the caller
      <i>search</i> permission will be searched. Only keys with for which the
      caller has <i>search</i> permission can be found.</dd>
  <dt></dt>
  <dd>If the key is found, its ID is returned as the function result.</dd>
  <dt></dt>
  <dd>If the key is found and <i>arg5</i> (cast to <i>key_serial_t</i>) is
      nonzero, then, subject to the same constraints and rules as
      <b>KEYCTL_LINK</b>, the key is linked into the keyring whose ID is
      specified in <i>arg5</i>. If the destination keyring specified in
      <i>arg5</i> already contains a link to a key that has the same type and
      description, then that link will be displaced by a link to the key found
      by this operation.</dd>
  <dt></dt>
  <dd>Instead of valid existing keyring IDs, the source (<i>arg2</i>) and
      destination (<i>arg5</i>) keyrings can be one of the special keyring IDs
      listed under <b>KEYCTL_GET_KEYRING_ID</b>.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_search</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_READ</b> (since Linux 2.6.10)</dt>
  <dd>Read the payload data of a key.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The ID of the key whose payload is to be read is specified in <i>arg2</i>
      (cast to <i>key_serial_t</i>). This can be the ID of an existing key, or
      any of the special key IDs listed for <b>KEYCTL_GET_KEYRING_ID</b>.</dd>
  <dt></dt>
  <dd>The payload is placed in the buffer pointed by <i>arg3</i> (cast to
      <i>char&#x00A0;*</i>); the size of that buffer must be specified in
      <i>arg4</i> (cast to <i>size_t</i>).</dd>
  <dt></dt>
  <dd>The returned data will be processed for presentation according to the key
      type. For example, a keyring will return an array of <i>key_serial_t</i>
      entries representing the IDs of all the keys that are linked to it. The
      <i>user</i> key type will return its data as is. If a key type does not
      implement this function, the operation fails with the error
      <b>EOPNOTSUPP</b>.</dd>
  <dt></dt>
  <dd>If <i>arg3</i> is not NULL, as much of the payload data as will fit is
      copied into the buffer. On a successful return, the return value is always
      the total size of the payload data. To determine whether the buffer was of
      sufficient size, check to see that the return value is less than or equal
      to the value supplied in <i>arg4</i>.</dd>
  <dt></dt>
  <dd>The key must either grant the caller <i>read</i> permission, or grant the
      caller <i>search</i> permission when searched for from the process
      keyrings (i.e., the key is possessed).</dd>
  <dt></dt>
  <dd>The <i>arg5</i> argument is ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_read</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_INSTANTIATE</b> (since Linux 2.6.10)</dt>
  <dd>(Positively) instantiate an uninstantiated key with a specified
    payload.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The ID of the key to be instantiated is provided in <i>arg2</i> (cast to
      <i>key_serial_t</i>).</dd>
  <dt></dt>
  <dd>The key payload is specified in the buffer pointed to by <i>arg3</i> (cast
      to <i>void&#x00A0;*</i>); the size of that buffer is specified in
      <i>arg4</i> (cast to <i>size_t</i>).</dd>
  <dt></dt>
  <dd>The payload may be a NULL pointer and the buffer size may be 0 if this is
      supported by the key type (e.g., it is a keyring).</dd>
  <dt></dt>
  <dd>The operation may be fail if the payload data is in the wrong format or is
      otherwise invalid.</dd>
  <dt></dt>
  <dd>If <i>arg5</i> (cast to <i>key_serial_t</i>) is nonzero, then, subject to
      the same constraints and rules as <b>KEYCTL_LINK</b>, the instantiated key
      is linked into the keyring whose ID specified in <i>arg5</i>.</dd>
  <dt></dt>
  <dd>The caller must have the appropriate authorization key, and once the
      uninstantiated key has been instantiated, the authorization key is
      revoked. In other words, this operation is available only from a
      <b>request-key</b>(8)-style program. See <b>request_key</b>(2) for an
      explanation of uninstantiated keys and key instantiation.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_instantiate</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_NEGATE</b> (since Linux 2.6.10)</dt>
  <dd>Negatively instantiate an uninstantiated key.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This operation is equivalent to the call:</dd>
  <dt></dt>
  <dd>
     keyctl(KEYCTL_REJECT, arg2, arg3, ENOKEY, arg4);</dd>
  <dt></dt>
  <dd>The <i>arg5</i> argument is ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_negate</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_SET_REQKEY_KEYRING</b> (since Linux 2.6.13)</dt>
  <dd>Set the default keyring to which implicitly requested keys will be linked
      for this thread, and return the previous setting. Implicit key requests
      are those made by internal kernel components, such as can occur when, for
      example, opening files on an AFS or NFS filesystem. Setting the default
      keyring also has an effect when requesting a key from user space; see
      <b>request_key</b>(2) for details.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <i>arg2</i> argument (cast to <i>int</i>) should contain one of the
      following values, to specify the new default keyring:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>KEY_REQKEY_DEFL_NO_CHANGE</b></dt>
  <dd>Don't change the default keyring. This can be used to discover the current
      default keyring (without changing it).</dd>
  <dt><b>KEY_REQKEY_DEFL_DEFAULT</b></dt>
  <dd>This selects the default behaviour, which is to use the thread-specific
      keyring if there is one, otherwise the process-specific keyring if there
      is one, otherwise the session keyring if there is one, otherwise the
      UID-specific session keyring, otherwise the user-specific keyring.</dd>
  <dt><b>KEY_REQKEY_DEFL_THREAD_KEYRING</b></dt>
  <dd>Use the thread-specific keyring (<b>thread-keyring</b>(7)) as the new
      default keyring.</dd>
  <dt><b>KEY_REQKEY_DEFL_PROCESS_KEYRING</b></dt>
  <dd>Use the process-specific keyring (<b>process-keyring</b>(7)) as the new
      default keyring.</dd>
  <dt><b>KEY_REQKEY_DEFL_SESSION_KEYRING</b></dt>
  <dd>Use the session-specific keyring (<b>session-keyring</b>(7)) as the new
      default keyring.</dd>
  <dt><b>KEY_REQKEY_DEFL_USER_KEYRING</b></dt>
  <dd>Use the UID-specific keyring (<b>user-keyring</b>(7)) as the new default
      keyring.</dd>
  <dt><b>KEY_REQKEY_DEFL_USER_SESSION_KEYRING</b></dt>
  <dd>Use the UID-specific session keyring (<b>user-session-keyring</b>(7)) as
      the new default keyring.</dd>
  <dt><b>KEY_REQKEY_DEFL_REQUESTOR_KEYRING</b> (since Linux 2.6.29)</dt>
  <dd>Use the requestor keyring.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>All other values are invalid.</dd>
  <dt></dt>
  <dd>The arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.</dd>
  <dt></dt>
  <dd>The setting controlled by this operation is inherited by the child of
      <b>fork</b>(2) and preserved across <b>execve</b>(2).</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_set_reqkey_keyring</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_SET_TIMEOUT</b> (since Linux 2.6.16)</dt>
  <dd>Set a timeout on a key.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The ID of the key is specified in <i>arg2</i> (cast to
      <i>key_serial_t</i>). The timeout value, in seconds from the current time,
      is specified in <i>arg3</i> (cast to <i>unsigned int</i>). The timeout is
      measured against the realtime clock.</dd>
  <dt></dt>
  <dd>Specifying the timeout value as 0 clears any existing timeout on the
    key.</dd>
  <dt></dt>
  <dd>The <i>/proc/keys</i> file displays the remaining time until each key will
      expire. (This is the only method of discovering the timeout on a
    key.)</dd>
  <dt></dt>
  <dd>The caller must either have the <i>setattr</i> permission on the key or
      hold an instantiation authorization token for the key (see
      <b>request_key</b>(2)).</dd>
  <dt></dt>
  <dd>The key and any links to the key will be automatically garbage collected
      after the timeout expires. Subsequent attempts to access the key will then
      fail with the error <b>EKEYEXPIRED</b>.</dd>
  <dt></dt>
  <dd>This operation cannot be used to set timeouts on revoked, expired, or
      negatively instantiated keys.</dd>
  <dt></dt>
  <dd>The arguments <i>arg4</i> and <i>arg5</i> are ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_set_timeout</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_ASSUME_AUTHORITY</b> (since Linux 2.6.16)</dt>
  <dd>Assume (or divest) the authority for the calling thread to instantiate a
      key.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <i>arg2</i> argument (cast to <i>key_serial_t</i>) specifies either a
      nonzero key ID to assume authority, or the value 0 to divest
    authority.</dd>
  <dt></dt>
  <dd>If <i>arg2</i> is nonzero, then it specifies the ID of an uninstantiated
      key for which authority is to be assumed. That key can then be
      instantiated using one of <b>KEYCTL_INSTANTIATE</b>,
      <b>KEYCTL_INSTANTIATE_IOV</b>, <b>KEYCTL_REJECT</b>, or
      <b>KEYCTL_NEGATE</b>. Once the key has been instantiated, the thread is
      automatically divested of authority to instantiate the key.</dd>
  <dt></dt>
  <dd>Authority over a key can be assumed only if the calling thread has present
      in its keyrings the authorization key that is associated with the
      specified key. (In other words, the <b>KEYCTL_ASSUME_AUTHORITY</b>
      operation is available only from a <b>request-key</b>(8)-style program;
      see <b>request_key</b>(2) for an explanation of how this operation is
      used.) The caller must have <i>search</i> permission on the authorization
      key.</dd>
  <dt></dt>
  <dd>If the specified key has a matching authorization key, then the ID of that
      key is returned. The authorization key can be read (<b>KEYCTL_READ</b>) to
      obtain the callout information passed to <b>request_key</b>(2).</dd>
  <dt></dt>
  <dd>If the ID given in <i>arg2</i> is 0, then the currently assumed authority
      is cleared (divested), and the value 0 is returned.</dd>
  <dt></dt>
  <dd>The <b>KEYCTL_ASSUME_AUTHORITY</b> mechanism allows a program such as
      <b>request-key</b>(8) to assume the necessary authority to instantiate a
      new uninstantiated key that was created as a consequence of a call to
      <b>request_key</b>(2). For further information, see <b>request_key</b>(2)
      and the kernel source file
      <i>Documentation/security/keys-request-key.txt</i>.</dd>
  <dt></dt>
  <dd>The arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_assume_authority</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_GET_SECURITY</b> (since Linux 2.6.26)</dt>
  <dd>Get the LSM (Linux Security Module) security label of the specified
    key.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The ID of the key whose security label is to be fetched is specified in
      <i>arg2</i> (cast to <i>key_serial_t</i>). The security label (terminated
      by a null byte) will be placed in the buffer pointed to by <i>arg3</i>
      argument (cast to <i>char&#x00A0;*</i>); the size of the buffer must be
      provided in <i>arg4</i> (cast to <i>size_t</i>).</dd>
  <dt></dt>
  <dd>If <i>arg3</i> is specified as NULL or the buffer size specified in
      <i>arg4</i> is too small, the full size of the security label string
      (including the terminating null byte) is returned as the function result,
      and nothing is copied to the buffer.</dd>
  <dt></dt>
  <dd>The caller must have <i>view</i> permission on the specified key.</dd>
  <dt></dt>
  <dd>The returned security label string will be rendered in a form appropriate
      to the LSM in force. For example, with SELinux, it may look like:</dd>
  <dt></dt>
  <dd>
     unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</dd>
  <dt></dt>
  <dd>If no LSM is currently in force, then an empty string is placed in the
      buffer.</dd>
  <dt></dt>
  <dd>The <i>arg5</i> argument is ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the functions
      <b>keyctl_get_security</b>(3) and
    <b>keyctl_get_security_alloc</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_SESSION_TO_PARENT</b> (since Linux 2.6.32)</dt>
  <dd>Replace the session keyring to which the <i>parent</i> of the calling
      process subscribes with the session keyring of the calling process.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The keyring will be replaced in the parent process at the point where the
      parent next transitions from kernel space to user space.</dd>
  <dt></dt>
  <dd>The keyring must exist and must grant the caller <i>link</i> permission.
      The parent process must be single-threaded and have the same effective
      ownership as this process and must not be set-user-ID or set-group-ID. The
      UID of the parent process's existing session keyring (f it has one), as
      well as the UID of the caller's session keyring much match the caller's
      effective UID.</dd>
  <dt></dt>
  <dd>The fact that it is the parent process that is affected by this operation
      allows a program such as the shell to start a child process that uses this
      operation to change the shell's session keyring. (This is what the
      <b>keyctl</b>(1) <b>new_session</b> command does.)</dd>
  <dt></dt>
  <dd>The arguments <i>arg2</i>, <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are
      ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_session_to_parent</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_REJECT</b> (since Linux 2.6.39)</dt>
  <dd>Mark a key as negatively instantiated and set an expiration timer on the
      key. This operation provides a superset of the functionality of the
      earlier <b>KEYCTL_NEGATE</b> operation.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The ID of the key that is to be negatively instantiated is specified in
      <i>arg2</i> (cast to <i>key_serial_t</i>). The <i>arg3</i> (cast to
      <i>unsigned int</i>) argument specifies the lifetime of the key, in
      seconds. The <i>arg4</i> argument (cast to <i>unsigned int</i>) specifies
      the error to be returned when a search hits this key; typically, this is
      one of <b>EKEYREJECTED</b>, <b>EKEYREVOKED</b>, or
    <b>EKEYEXPIRED</b>.</dd>
  <dt></dt>
  <dd>If <i>arg5</i> (cast to <i>key_serial_t</i>) is nonzero, then, subject to
      the same constraints and rules as <b>KEYCTL_LINK</b>, the negatively
      instantiated key is linked into the keyring whose ID is specified in
      <i>arg5</i>.</dd>
  <dt></dt>
  <dd>The caller must have the appropriate authorization key. In other words,
      this operation is available only from a <b>request-key</b>(8)-style
      program. See <b>request_key</b>(2).</dd>
  <dt></dt>
  <dd>The caller must have the appropriate authorization key, and once the
      uninstantiated key has been instantiated, the authorization key is
      revoked. In other words, this operation is available only from a
      <b>request-key</b>(8)-style program. See <b>request_key</b>(2) for an
      explanation of uninstantiated keys and key instantiation.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_reject</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_INSTANTIATE_IOV</b> (since Linux 2.6.39)</dt>
  <dd>Instantiate an uninstantiated key with a payload specified via a vector of
      buffers.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This operation is the same as <b>KEYCTL_INSTANTIATE</b>, but the payload
      data is specified as an array of <i>iovec</i> structures:</dd>
  <dt></dt>
  <dd>
    <br/>
    <pre>
struct iovec {
    void  *iov_base;    /* Starting address of buffer */
    size_t iov_len;     /* Size of buffer (in bytes) */
};

    </pre>
    <br/>
  </dd>
  <dt></dt>
  <dd>The pointer to the payload vector is specified in <i>arg3</i> (cast as
      <i>const struct iovec&#x00A0;*</i>). The number of items in the vector is
      specified in <i>arg4</i> (cast as <i>unsigned int</i>).</dd>
  <dt></dt>
  <dd>The <i>arg2</i> (key ID) and <i>arg5</i> (keyring ID) are interpreted as
      for <b>KEYCTL_INSTANTIATE</b>.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_instantiate_iov</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_INVALIDATE</b> (since Linux 3.5)</dt>
  <dd>Mark a key as invalid.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The ID of the key to be invalidated is specified in <i>arg2</i> (cast to
      <i>key_serial_t</i>).</dd>
  <dt></dt>
  <dd>To invalidate a key, the caller must have <i>search</i> permission on the
      key.</dd>
  <dt></dt>
  <dd>This operation marks the key as invalid and schedules immediate garbage
      collection. The garbage collector removes the invalidated key from all
      keyrings and deletes the key when its reference count reaches zero. After
      this operation, the key will be ignored by all searches, even if it is not
      yet deleted.</dd>
  <dt></dt>
  <dd>Keys that are marked invalid become invisible to normal key operations
      immediately, though they are still visible in <i>/proc/keys</i> (marked
      with an 'i' flag) until they are actually removed.</dd>
  <dt></dt>
  <dd>The arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_invalidate</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_GET_PERSISTENT</b> (since Linux 3.13)</dt>
  <dd>Get the persistent keyring (<b>persistent-keyring</b>(7)) for a specified
      user and link it to a specified keyring.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The user ID is specified in <i>arg2</i> (cast to <i>uid_t</i>). If the
      value -1 is specified, the caller's real user ID is used. The ID of the
      destination keyring is specified in <i>arg3</i> (cast to
      <i>key_serial_t</i>).</dd>
  <dt></dt>
  <dd>The caller must have the <b>CAP_SETUID</b> capability in its user
      namespace in order to fetch the persistent keyring for a user ID that does
      not match either the real or effective user ID of the caller.</dd>
  <dt></dt>
  <dd>If the call is successful, a link to the persistent keyring is added to
      the keyring whose ID was specified in <i>arg3</i>.</dd>
  <dt></dt>
  <dd>The caller must have <i>write</i> permission on the keyring.</dd>
  <dt></dt>
  <dd>The persistent keyring will be created by the kernel if it does not yet
      exist.</dd>
  <dt></dt>
  <dd>Each time the <b>KEYCTL_GET_PERSISTENT</b> operation is performed, the
      persistent keyring will have its expiration timeout reset to the value
    in:</dd>
  <dt></dt>
  <dd>
    <br/>
    <pre>
/proc/sys/kernel/keys/persistent_keyring_expiry

    </pre>
    <br/>
  </dd>
  <dt></dt>
  <dd>Should the timeout be reached, the persistent keyring will be removed and
      everything it pins can then be garbage collected.</dd>
  <dt></dt>
  <dd>Persistent keyrings were added to Linux in kernel version 3.13.</dd>
  <dt></dt>
  <dd>The arguments <i>arg4</i> and <i>arg5</i> are ignored.</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> via the function
      <b>keyctl_get_persistent</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_DH_COMPUTE</b> (since Linux 4.7)</dt>
  <dd>Compute a Diffie-Hellman shared secret or public key, optionally applying
      key derivation function (KDF) to the result.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <i>arg2</i> argument is a pointer to a set of parameters containing
      serial numbers for three <i>&quot;user&quot;</i> keys used in the
      Diffie-Hellman calculation, packaged in a structure of the following
    form:</dd>
  <dt></dt>
  <dd>
    <br/>
    <pre>
struct keyctl_dh_params {
    int32_t private; /* The local private key */
    int32_t prime; /* The prime, known to both parties */
    int32_t base;  /* The base integer: either a shared
                      generator or the remote public key */
};

    </pre>
    <br/>
  </dd>
  <dt></dt>
  <dd>Each of the three keys specified in this structure must grant the caller
      <i>read</i> permission. The payloads of these keys are used to calculate
      the Diffie-Hellman result as:</dd>
  <dt></dt>
  <dd>
     base ^ private mod prime</dd>
  <dt></dt>
  <dd>If the base is the shared generator, the result is the local public key.
      If the base is the remote public key, the result is the shared
    secret.</dd>
  <dt></dt>
  <dd>The <i>arg3</i> argument (cast to <i>char&#x00A0;*</i>) points to a buffer
      where the result of the calculation is placed. The size of that buffer is
      specified in <i>arg4</i> (cast to <i>size_t</i>).</dd>
  <dt></dt>
  <dd>The buffer must be large enough to accommodate the output data, otherwise
      an error is returned. If <i>arg4</i> is specified zero, in which case the
      buffer is not used and the operation returns the minimum required buffer
      size (i.e., the length of the prime).</dd>
  <dt></dt>
  <dd>Diffie-Hellman computations can be performed in user space, but require a
      multiple-precision integer (MPI) library. Moving the implementation into
      the kernel gives access to the kernel MPI implementation, and allows
      access to secure or acceleration hardware.</dd>
  <dt></dt>
  <dd>Adding support for DH computation to the <b>keyctl</b>() system call was
      considered a good fit due to the DH algorithm's use for deriving shared
      keys; it also allows the type of the key to determine which DH
      implementation (software or hardware) is appropriate.</dd>
  <dt></dt>
  <dd>If the <i>arg5</i> argument is <b>NULL</b>, then the DH result itself is
      returned. Otherwise (since Linux 4.12), it is a pointer to a structure
      which specifies parameters of the KDF operation to be applied:</dd>
  <dt></dt>
  <dd>
    <br/>
    <pre>
struct keyctl_kdf_params {
    char *hashname;     /* Hash algorithm name */
    char *otherinfo;    /* SP800-56A OtherInfo */
    __u32 otherinfolen; /* Length of otherinfo data */
    __u32 __spare[8];   /* Reserved */
};

    </pre>
    <br/>
  </dd>
  <dt></dt>
  <dd>The <i>hashname</i> field is a null-terminated string which specifies a
      hash name (available in the kernel's crypto API; the list of the hashes
      available is rather tricky to observe; please refer to the
      <a class="Lk" href="https://www.kernel.org/doc/html/latest/crypto/architecture.html">&quot;Kernel
      Crypto API Architecture&quot;</a> documentation for the information
      regarding how hash names are constructed and your kernel's source and
      configuration regarding what ciphers and templates with type
      <b>CRYPTO_ALG_TYPE_SHASH</b> are available) to be applied to DH result in
      KDF operation.</dd>
  <dt></dt>
  <dd>The <i>otherinfo</i> field is an <i>OtherInfo</i> data as described in
      SP800-56A section 5.8.1.2 and is algorithm-specific. This data is
      concatenated with the result of DH operation and is provided as an input
      to the KDF operation. Its size is provided in the <i>otherinfolen</i>
      field and is limited by <b>KEYCTL_KDF_MAX_OI_LEN</b> constant that defined
      in <i>security/keys/internal.h</i> to a value of 64.</dd>
  <dt></dt>
  <dd>The <b>__spare</b> field is currently unused. It was ignored until Linux
      4.13 (but still should be user-addressable since it is copied to the
      kernel), and should contain zeros since Linux 4.13.</dd>
  <dt></dt>
  <dd>The KDF implementation complies with SP800-56A as well as with SP800-108
      (the counter KDF).</dd>
  <dt></dt>
  <dd>This operation is exposed by <i>libkeyutils</i> (from version 1.5.10
      onwards) via the functions <b>keyctl_dh_compute</b>(3) and
      <b>keyctl_dh_compute_alloc</b>(3).</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>KEYCTL_RESTRICT_KEYRING</b> (since Linux 4.12)</dt>
  <dd>Apply a key-linking restriction to the keyring with the ID provided in
      <i>arg2</i> (cast to <i>key_serial_t</i>). The caller must have
      <i>setattr</i> permission on the key. If <i>arg3</i> is NULL, any attempt
      to add a key to the keyring is blocked; otherwise it contains a pointer to
      a string with a key type name and <i>arg4</i> contains a pointer to string
      that describes the type-specific restriction. As of Linux 4.12, only the
      type &quot;asymmetric&quot; has restrictions defined:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>builtin_trusted</b></dt>
  <dd>Allows only keys that are signed by a key linked to the built-in keyring
      (&quot;.builtin_trusted_keys&quot;).</dd>
  <dt><b>builtin_and_secondary_trusted</b></dt>
  <dd>Allows only keys that are signed by a key linked to the secondary keyring
      (&quot;.secondary_trusted_keys&quot;) or, by extension, a key in a
      built-in keyring, as the latter is linked to the former.</dd>
  <dt><b>key_or_keyring:</b><i>key</i></dt>
  <dd></dd>
  <dt><b>key_or_keyring:</b><i>key</i><b>:chain</b></dt>
  <dd>If <i>key</i> specifies the ID of a key of type &quot;asymmetric&quot;,
      then only keys that are signed by this key are allowed.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If <i>key</i> specifies the ID of a keyring, then only keys that are
      signed by a key linked to this keyring are allowed.</dd>
  <dt></dt>
  <dd>If &quot;:chain&quot; is specified, keys that are signed by a keys linked
      to the destination keyring (that is, the keyring with the ID specified in
      the <i>arg2</i> argument) are also allowed.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note that a restriction can be configured only once for the specified
      keyring; once a restriction is set, it can't be overridden.</dd>
  <dt></dt>
  <dd>The argument <i>arg5</i> is ignored.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
For a successful call, the return value depends on the operation:
<dl class="Bl-tag">
  <dt><b>KEYCTL_GET_KEYRING_ID</b></dt>
  <dd>The ID of the requested keyring.</dd>
  <dt><b>KEYCTL_JOIN_SESSION_KEYRING</b></dt>
  <dd>The ID of the joined session keyring.</dd>
  <dt><b>KEYCTL_DESCRIBE</b></dt>
  <dd>The size of the description (including the terminating null byte),
      irrespective of the provided buffer size.</dd>
  <dt><b>KEYCTL_SEARCH</b></dt>
  <dd>The ID of the key that was found.</dd>
  <dt><b>KEYCTL_READ</b></dt>
  <dd>The amount of data that is available in the key, irrespective of the
      provided buffer size.</dd>
  <dt><b>KEYCTL_SET_REQKEY_KEYRING</b></dt>
  <dd>The ID of the previous default keyring to which implicitly requested keys
      were linked (one of <b>KEY_REQKEY_DEFL_USER_*</b>).</dd>
  <dt><b>KEYCTL_ASSUME_AUTHORITY</b></dt>
  <dd>Either 0, if the ID given was 0, or the ID of the authorization key
      matching the specified key, if a nonzero key ID was provided.</dd>
  <dt><b>KEYCTL_GET_SECURITY</b></dt>
  <dd>The size of the LSM security label string (including the terminating null
      byte), irrespective of the provided buffer size.</dd>
  <dt><b>KEYCTL_GET_PERSISTENT</b></dt>
  <dd>The ID of the persistent keyring.</dd>
  <dt><b>KEYCTL_DH_COMPUTE</b></dt>
  <dd>The number of bytes copied to the buffer, or, if <i>arg4</i> is 0, the
      required buffer size.</dd>
  <dt>All other operations</dt>
  <dd>Zero.</dd>
</dl>
<p class="Pp">On error, -1 is returned, and <i>errno</i> is set appropriately to
    indicate the error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<dl class="Bl-tag">
  <dt><b>EACCES</b></dt>
  <dd>The requested operation wasn't permitted.</dd>
  <dt><b>EAGAIN</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_DH_COMPUTE</b> and there was an error
      during crypto module initialization.</dd>
  <dt><b>EDEADLK</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_LINK</b> and the requested link would
      result in a cycle.</dd>
  <dt><b>EDEADLK</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_RESTRICT_KEYRING</b> and the requested
      keyring restriction would result in a cycle.</dd>
  <dt><b>EDQUOT</b></dt>
  <dd>The key quota for the caller's user would be exceeded by creating a key or
      linking it to the keyring.</dd>
  <dt><b>EEXIST</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_RESTRICT_KEYRING</b> and keyring provided
      in <i>arg2</i> argument already has a restriction set.</dd>
  <dt><b>EFAULT</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_DH_COMPUTE</b> and one of the following has
      failed:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>copying of the <i>struct keyctl_dh_params</i>, provided in the <i>arg2</i>
      argument, from user space;</li>
  <li>copying of the <i>struct keyctl_kdf_params</i>, provided in the non-NULL
      <i>arg5</i> argument, from user space (in case kernel supports performing
      KDF operation on DH operation result);</li>
  <li>copying of data pointed by the <i>hashname</i> field of the <i>struct
      keyctl_kdf_params</i> from user space;</li>
  <li>copying of data pointed by the <i>otherinfo</i> field of the <i>struct
      keyctl_kdf_params</i> from user space if the <i>otherinfolen</i> field was
      nonzero;</li>
  <li>copying of the result to user space.</li>
</ul>
</div>
<dl class="Bl-tag">
  <dt><b>EINVAL</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_SETPERM</b> and an invalid permission bit
      was specified in <i>arg3</i>.</dd>
  <dt><b>EINVAL</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_SEARCH</b> and the size of the description
      in <i>arg4</i> (including the terminating null byte) exceeded 4096 bytes.
      size of the string (including the terminating null byte) specified in
      <i>arg3</i> (the key type) or <i>arg4</i> (the key description) exceeded
      the limit (32 bytes and 4096 bytes respectively).</dd>
  <dt><b>EINVAL</b> (Linux kernels before 4.12)</dt>
  <dd><i>operation</i> was <b>KEYCTL_DH_COMPUTE</b>, argument <i>arg5</i> was
      non-NULL.</dd>
  <dt><b>EINVAL</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_DH_COMPUTE</b> And the digest size of the
      hashing algorithm supplied is zero.</dd>
  <dt><b>EINVAL</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_DH_COMPUTE</b> and the buffer size provided
      is not enough to hold the result. Provide 0 as a buffer size in order to
      obtain the minimum buffer size.</dd>
  <dt><b>EINVAL</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_DH_COMPUTE</b> and the hash name provided
      in the <i>hashname</i> field of the <i>struct keyctl_kdf_params</i>
      pointed by <i>arg5</i> argument is too big (the limit is
      implementation-specific and varies between kernel versions, but it is
      deemed big enough for all valid algorithm names).</dd>
  <dt><b>EINVAL</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_DH_COMPUTE</b> and the <i>__spare</i> field
      of the <i>struct keyctl_kdf_params</i> provided in the <i>arg5</i>
      argument contains nonzero values.</dd>
  <dt><b>EKEYEXPIRED</b></dt>
  <dd>An expired key was found or specified.</dd>
  <dt><b>EKEYREJECTED</b></dt>
  <dd>A rejected key was found or specified.</dd>
  <dt><b>EKEYREVOKED</b></dt>
  <dd>A revoked key was found or specified.</dd>
  <dt><b>ELOOP</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_LINK</b> and the requested link would cause
      the maximum nesting depth for keyrings to be exceeded.</dd>
  <dt><b>EMSGSIZE</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_DH_COMPUTE</b> and the buffer length
      exceeds <b>KEYCTL_KDF_MAX_OUTPUT_LEN</b> (which is 1024 currently) or the
      <i>otherinfolen</i> field of the <i>struct keyctl_kdf_parms</i> passed in
      <i>arg5</i> exceeds <b>KEYCTL_KDF_MAX_OI_LEN</b> (which is 64
    currently).</dd>
  <dt><b>ENFILE</b> (Linux kernels before 3.13)</dt>
  <dd><i>operation</i> was <b>KEYCTL_LINK</b> and the keyring is full. (Before
      Linux 3.13, the available space for storing keyring links was limited to a
      single page of memory; since Linux 3.13, there is no fixed limit.)</dd>
  <dt><b>ENOENT</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_UNLINK</b> and the key to be unlinked isn't
      linked to the keyring.</dd>
  <dt><b>ENOENT</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_DH_COMPUTE</b> and the hashing algorithm
      specified in the <i>hashname</i> field of the <i>struct
      keyctl_kdf_params</i> pointed by <i>arg5</i> argument hasn't been
    found.</dd>
  <dt><b>ENOENT</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_RESTRICT_KEYRING</b> and the type provided
      in <i>arg3</i> argument doesn't support setting key linking
    restrictions.</dd>
  <dt><b>ENOKEY</b></dt>
  <dd>No matching key was found or an invalid key was specified.</dd>
  <dt><b>ENOKEY</b></dt>
  <dd>The value <b>KEYCTL_GET_KEYRING_ID</b> was specified in <i>operation</i>,
      the key specified in <i>arg2</i> did not exist, and <i>arg3</i> was zero
      (meaning don't create the key if it didn't exist).</dd>
  <dt><b>ENOMEM</b></dt>
  <dd>One of kernel memory allocation routines failed during the execution of
      the syscall.</dd>
  <dt><b>ENOTDIR</b></dt>
  <dd>A key of keyring type was expected but the ID of a key with a different
      type was provided.</dd>
  <dt><b>EOPNOTSUPP</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_READ</b> and the key type does not support
      reading (e.g., the type is <i>&quot;login&quot;</i>).</dd>
  <dt><b>EOPNOTSUPP</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_UPDATE</b> and the key type does not
      support updating.</dd>
  <dt><b>EOPNOTSUPP</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_RESTRICT_KEYRING</b>, the type provided in
      <i>arg3</i> argument was &quot;asymmetric&quot;, and the key specified in
      the restriction specification provided in <i>arg4</i> has type other than
      &quot;asymmetric&quot; or &quot;keyring&quot;.</dd>
  <dt><b>EPERM</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_GET_PERSISTENT</b>, <i>arg2</i> specified a
      UID other than the calling thread's real or effective UID, and the caller
      did not have the <b>CAP_SETUID</b> capability.</dd>
  <dt><b>EPERM</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_SESSION_TO_PARENT</b> and either: all of
      the UIDs (GIDs) of the parent process do not match the effective UID (GID)
      of the calling process; the UID of the parent's existing session keyring
      or the UID of the caller's session keyring did not match the effective UID
      of the caller; the parent process is not single-thread; or the parent
      process is <b>init</b>(1) or a kernel thread.</dd>
  <dt><b>ETIMEDOUT</b></dt>
  <dd><i>operation</i> was <b>KEYCTL_DH_COMPUTE</b> and the initialization of
      crypto modules has timed out.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSIONS"><a class="permalink" href="#VERSIONS">VERSIONS</a></h1>
This system call first appeared in Linux 2.6.10.
</section>
<section class="Sh">
<h1 class="Sh" id="CONFORMING_TO"><a class="permalink" href="#CONFORMING_TO">CONFORMING
  TO</a></h1>
This system call is a nonstandard Linux extension.
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
No wrapper for this system call is provided in glibc. A wrapper is provided in
  the <i>libkeyutils</i> library. When employing the wrapper in that library,
  link with <i>-lkeyutils</i>. However, rather than using this system call
  directly, you probably want to use the various library functions mentioned in
  the descriptions of individual operations above.
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
The program below provide subset of the functionality of the
  <b>request-key</b>(8) program provided by the <i>keyutils</i> package. For
  informational purposes, the program records various information in a log file.
<p class="Pp">As described in <b>request_key</b>(2), the <b>request-key</b>(8)
    program is invoked with command-line arguments that describe a key that is
    to be instantiated. The example program fetches and logs these arguments.
    The program assumes authority to instantiate the requested key, and then
    instantiates that key.</p>
<p class="Pp">The following shell session demonstrates the use of this program.
    In the session, we compile the program and then use it to temporarily
    replace the standard <b>request-key</b>(8) program. (Note that temporarily
    disabling the standard <b>request-key</b>(8) program may not be safe on some
    systems.) While our example program is installed, we use the example program
    shown in <b>request_key</b>(2) to request a key.</p>
<p class="Pp">
  <br/>
</p>
<pre>
$ <b>cc -o key_instantiate key_instantiate.c -lkeyutils</b>
$ <b>sudo mv /sbin/request-key /sbin/request-key.backup</b>
$ <b>sudo cp key_instantiate /sbin/request-key</b>
$ <b>./t_request_key user mykey somepayloaddata</b>
Key ID is 20d035bf
$ <b>sudo mv /sbin/request-key.backup /sbin/request-key</b>

</pre>
<br/>
<p class="Pp">Looking at the log file created by this program, we can see the
    command-line arguments supplied to our example program:</p>
<p class="Pp">
  <br/>
</p>
<pre>
$ <b>cat /tmp/key_instantiate.log </b>
Time: Mon Nov  7 13:06:47 2016
Command line arguments:
  argv[0]:            /sbin/request-key
  operation:          create
  key_to_instantiate: 20d035bf
  UID:                1000
  GID:                1000
  thread_keyring:     0
  process_keyring:    0
  session_keyring:    256e6a6
Key description:      user;1000;1000;3f010000;mykey
Auth key payload:     somepayloaddata
Destination keyring:  256e6a6
Auth key description: .request_key_auth;1000;1000;0b010000;20d035bf

</pre>
<br/>
<p class="Pp">The last few lines of the above output show that the example
    program was able to fetch:</p>
<ul class="Bl-bullet">
  <li>the description of the key to be instantiated, which included the name of
      the key (<i>mykey</i>);</li>
  <li>the payload of the authorization key, which consisted of the data
      (<i>somepayloaddata</i>) passed to <b>request_key</b>(2);</li>
  <li>the destination keyring that was specified in the call to
      <b>request_key</b>(2); and</li>
  <li>the description of the authorization key, where we can see that the name
      of the authorization key matches the ID of the key that is to be
      instantiated (<i>20d035bf</i>).</li>
</ul>
<p class="Pp">The example program in <b>request_key</b>(2) specified the
    destination keyring as <b>KEY_SPEC_SESSION_KEYRING</b>. By examining the
    contents of <i>/proc/keys</i>, we can see that this was translated to the ID
    of the destination keyring (<i>0256e6a6</i>) shown in the log output above;
    we can also see the newly created key with the name <i>mykey</i> and ID
    <i>20d035bf</i>.</p>
<p class="Pp">
  <br/>
</p>
<pre>
$ <b>cat /proc/keys | egrep 'mykey|256e6a6'</b>
0256e6a6 I--Q---  194 perm 3f030000  1000  1000 keyring  _ses: 3
20d035bf I--Q---    1 perm 3f010000  1000  1000 user     mykey: 16

</pre>
<br/>
<section class="Ss">
<h2 class="Ss" id="Program_source"><a class="permalink" href="#Program_source">Program
  source</a></h2>
<pre>
/* key_instantiate.c */
#include &lt;sys/types.h&gt;
#include &lt;keyutils.h&gt;
#include &lt;time.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#ifndef KEY_SPEC_REQUESTOR_KEYRING
#define KEY_SPEC_REQUESTOR_KEYRING      -8
#endif
int
main(int argc, char *argv[])
{
    FILE *fp;
    time_t t;
    char *operation;
    key_serial_t key_to_instantiate, dest_keyring;
    key_serial_t thread_keyring, process_keyring, session_keyring;
    uid_t uid;
    gid_t gid;
    char dbuf[256];
    char auth_key_payload[256];
    int akp_size;       /* Size of auth_key_payload */
    fp = fopen(&quot;/tmp/key_instantiate.log&quot;, &quot;w&quot;);
    if (fp == NULL)
        exit(EXIT_FAILURE);
    setbuf(fp, NULL);
    t = time(NULL);
    fprintf(fp, &quot;Time: %s\n&quot;, ctime(&amp;t));
    /*
     * The kernel passes a fixed set of arguments to the program
     * that it execs; fetch them.
     */
    operation = argv[1];
    key_to_instantiate = atoi(argv[2]);
    uid = atoi(argv[3]);
    gid = atoi(argv[4]);
    thread_keyring = atoi(argv[5]);
    process_keyring = atoi(argv[6]);
    session_keyring = atoi(argv[7]);
    fprintf(fp, &quot;Command line arguments:\n&quot;);
    fprintf(fp, &quot;  argv[0]:            %s\n&quot;, argv[0]);
    fprintf(fp, &quot;  operation:          %s\n&quot;, operation);
    fprintf(fp, &quot;  key_to_instantiate: %lx\n&quot;,
            (long) key_to_instantiate);
    fprintf(fp, &quot;  UID:                %ld\n&quot;, (long) uid);
    fprintf(fp, &quot;  GID:                %ld\n&quot;, (long) gid);
    fprintf(fp, &quot;  thread_keyring:     %lx\n&quot;, (long) thread_keyring);
    fprintf(fp, &quot;  process_keyring:    %lx\n&quot;, (long) process_keyring);
    fprintf(fp, &quot;  session_keyring:    %lx\n&quot;, (long) session_keyring);
    fprintf(fp, &quot;\n&quot;);
    /*
     * Assume the authority to instantiate the key named in argv[2]
     */
    if (keyctl(KEYCTL_ASSUME_AUTHORITY, key_to_instantiate) == -1) {
        fprintf(fp, &quot;KEYCTL_ASSUME_AUTHORITY failed: %s\n&quot;,
                strerror(errno));
        exit(EXIT_FAILURE);
    }
    /*
     * Fetch the description of the key that is to be instantiated
     */
    if (keyctl(KEYCTL_DESCRIBE, key_to_instantiate,
                dbuf, sizeof(dbuf)) == -1) {
        fprintf(fp, &quot;KEYCTL_DESCRIBE failed: %s\n&quot;, strerror(errno));
        exit(EXIT_FAILURE);
    }
    fprintf(fp, &quot;Key description:      %s\n&quot;, dbuf);
    /*
     * Fetch the payload of the authorization key, which is
     * actually the callout data given to request_key()
     */
    akp_size = keyctl(KEYCTL_READ, KEY_SPEC_REQKEY_AUTH_KEY,
                      auth_key_payload, sizeof(auth_key_payload));
    if (akp_size == -1) {
        fprintf(fp, &quot;KEYCTL_READ failed: %s\n&quot;, strerror(errno));
        exit(EXIT_FAILURE);
    }
    auth_key_payload[akp_size] = '\0';
    fprintf(fp, &quot;Auth key payload:     %s\n&quot;, auth_key_payload);
    /*
     * For interest, get the ID of the authorization key and
     * display it.
     */
    auth_key = keyctl(KEYCTL_GET_KEYRING_ID,
            KEY_SPEC_REQKEY_AUTH_KEY);
    if (auth_key == -1) {
        fprintf(fp, &quot;KEYCTL_GET_KEYRING_ID failed: %s\n&quot;,
                strerror(errno));
        exit(EXIT_FAILURE);
    }
    fprintf(fp, &quot;Auth key ID:          %lx\n&quot;, (long) auth_key);
    /*
     * Fetch key ID for the request_key(2) destination keyring.
     */
    dest_keyring = keyctl(KEYCTL_GET_KEYRING_ID,
                          KEY_SPEC_REQUESTOR_KEYRING);
    if (dest_keyring == -1) {
        fprintf(fp, &quot;KEYCTL_GET_KEYRING_ID failed: %s\n&quot;,
                strerror(errno));
        exit(EXIT_FAILURE);
    }
    fprintf(fp, &quot;Destination keyring:  %lx\n&quot;, (long) dest_keyring);
    /*
     * Fetch the description of the authorization key. This
     * allows us to see the key type, UID, GID, permissions,
     * and description (name) of the key. Among other things,
     * we will see that the name of the key is a hexadecimal
     * string representing the ID of the key to be instantiated.
     */
    if (keyctl(KEYCTL_DESCRIBE, KEY_SPEC_REQKEY_AUTH_KEY,
                dbuf, sizeof(dbuf)) == -1) {
        fprintf(fp, &quot;KEYCTL_DESCRIBE failed: %s\n&quot;, strerror(errno));
        exit(EXIT_FAILURE);
    }
    fprintf(fp, &quot;Auth key description: %s\n&quot;, dbuf);
    /*
     * Instantiate the key using the callout data that was supplied
     * in the payload of the authorization key.
     */
    if (keyctl(KEYCTL_INSTANTIATE, key_to_instantiate,
               auth_key_payload, akp_size + 1, dest_keyring) == -1) {
        fprintf(fp, &quot;KEYCTL_INSTANTIATE failed: %s\n&quot;,
                strerror(errno));
        exit(EXIT_FAILURE);
    }
    exit(EXIT_SUCCESS);
}
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>keyctl</b>(1), <b>add_key</b>(2), <b>request_key</b>(2), <b>keyctl</b>(3),
  <b>keyctl_assume_authority</b>(3), <b>keyctl_chown</b>(3),
  <b>keyctl_clear</b>(3), <b>keyctl_describe</b>(3),
  <b>keyctl_describe_alloc</b>(3), <b>keyctl_dh_compute</b>(3),
  <b>keyctl_dh_compute_alloc</b>(3), <b>keyctl_get_keyring_ID</b>(3),
  <b>keyctl_get_persistent</b>(3), <b>keyctl_get_security</b>(3),
  <b>keyctl_get_security_alloc</b>(3), <b>keyctl_instantiate</b>(3),
  <b>keyctl_instantiate_iov</b>(3), <b>keyctl_invalidate</b>(3),
  <b>keyctl_join_session_keyring</b>(3), <b>keyctl_link</b>(3),
  <b>keyctl_negate</b>(3), <b>keyctl_read</b>(3), <b>keyctl_read_alloc</b>(3),
  <b>keyctl_reject</b>(3), <b>keyctl_revoke</b>(3), <b>keyctl_search</b>(3),
  <b>keyctl_session_to_parent</b>(3), <b>keyctl_set_reqkey_keyring</b>(3),
  <b>keyctl_set_timeout</b>(3), <b>keyctl_setperm</b>(3),
  <b>keyctl_unlink</b>(3), <b>keyctl_update</b>(3),
  <b>recursive_key_scan</b>(3), <b>recursive_session_key_scan</b>(3),
  <b>capabilities</b>(7), <b>credentials</b>(7), <b>keyrings</b>(7),
  <b>keyutils</b>(7), <b>persistent-keyring</b>(7), <b>process-keyring</b>(7),
  <b>session-keyring</b>(7), <b>thread-keyring</b>(7), <b>user-keyring</b>(7),
  <b>user_namespaces</b>(7), <b>user-session-keyring</b>(7),
  <b>request-key</b>(8)
<p class="Pp">The kernel source files under <i>Documentation/security/keys/</i>
    (or, before Linux 4.13, in the file
  <i>Documentation/security/keys.txt</i>).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COLOPHON"><a class="permalink" href="#COLOPHON">COLOPHON</a></h1>
This page is part of release 5.05 of the Linux <i>man-pages</i> project. A
  description of the project, information about reporting bugs, and the latest
  version of this page, can be found at https://www.kernel.org/doc/man-pages/.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-03-06</td>
    <td class="foot-os">Linux</td>
  </tr>
</table>

	<div class=footer>
		<p>Copyright 2020 Scott Court</p>
	</div>
	</div>
</body>
