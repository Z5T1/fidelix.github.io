
<!DOCTYPE HTML>
<head>
	<title>/usr/share/man/man5/interfaces.5</title>		<link rel='stylesheet' href='/mandoc.css' />
	<link rel='stylesheet' href='/style.css' />
</head>
<body>
	<div class=contents>
	<div class=header>
	<h1>The Fidelix Linux Distribution</h1>
	<h2>Simple, Stable, and Secure</h2>
	</div>
<div class=menubar>
	<ul>
		<li><a href=/>News</a></li>
		<li><a href=/about.html>About</a></li>
		<li><a href=https://github.com/Z5T1/fidelix/releases>Download</a></li>
		<div class=dropdown>
			<li><a href=#>Documentation</a></li>
			<ul class=dropdown-content>
				<li><a href=/handbook/>Handbook</a></li>
				<li><a href=/man/>Manual Pages</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Development</a></li>
			<ul class=dropdown-content>
				<li><a href=https://github.com/Z5T1/fidelix>GitHub</a></li>
			</ul>
		</div>
	</ul>
</div>


	<div class=body><table class="head">
  <tr>
    <td class="head-ltitle">INTERFACES(5)</td>
    <td class="head-vol">File formats</td>
    <td class="head-rtitle">INTERFACES(5)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
/etc/network/interfaces - network interface configuration for ifup and ifdown
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
/etc/network/interfaces contains network interface configuration information for
  the <b>ifup</b>(8) and <b>ifdown</b>(8) commands. This is where you configure
  how your system is connected to the network.
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
The following example configures two network interfaces: eth0 is brought up at
  boot, and uses DHCP for IPv4 and SLAAC for IPv6, whereas eth1 is brought up
  whenever the network hardware is detected, and is configured with static IPv4
  and IPv6 addresses.
<p class="Pp"></p>
<pre>
auto eth0
allow-hotplug eth1
iface eth0 inet dhcp
iface eth0 inet6 auto
iface eth1 inet static
	address 192.168.1.2/24
	gateway 192.168.1.1
iface eth1 inet6 static
	address fec0:0:0:1::2/64
	gateway fec0:0:0:1::1
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="FILE_FORMAT"><a class="permalink" href="#FILE_FORMAT">FILE
  FORMAT</a></h1>
Lines starting with `#' are ignored. Note that end-of-line comments are NOT
  supported, comments must be on a line of their own.
<p class="Pp">A line may be extended across multiple lines by making the last
    character a backslash.</p>
<p class="Pp">The file consists of zero or more &quot;iface&quot;,
    &quot;mapping&quot;, &quot;auto&quot;, &quot;allow-&quot;,
    &quot;rename&quot;, &quot;source&quot; and &quot;source-directory&quot;
    stanzas. These will be described in more detail in the following
  sections.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERFACE_SELECTION"><a class="permalink" href="#INTERFACE_SELECTION">INTERFACE
  SELECTION</a></h1>
Lines beginning with the word &quot;auto&quot; are used to identify the physical
  interfaces to be brought up when <b>ifup</b> is run with the <b>-a</b> option.
  (This option is also used by the system boot scripts, so interfaces marked
  &quot;auto&quot; are brought up at boot time.) Physical interface names should
  follow the word &quot;auto&quot; on the same line. There can be multiple
  &quot;auto&quot; stanzas. <b>ifup</b> brings the named interfaces up in the
  order listed.
<p class="Pp">Lines beginning with &quot;allow-&quot; are used to identify
    interfaces that should be brought up automatically by various subsystems.
    This may be done using a command such as &quot;ifup --allow=hotplug eth0
    eth1&quot;, which will only bring up eth0 or eth1 if it is listed in an
    &quot;allow-hotplug&quot; line. Note that &quot;allow-auto&quot; and
    &quot;auto&quot; are synonyms. (Interfaces marked &quot;allow-hotplug&quot;
    are brought up when udev detects them. This can either be during boot if the
    interface is already present, or at a later time, for example when plugging
    in a USB network card. Please note that this does not have anything to do
    with detecting a network cable being plugged in.)</p>
<p class="Pp">Lines beginning with &quot;no-auto-down&quot; are used to identify
    interfaces that should not be brought down by the command &quot;ifdown
    -a&quot;. Its main use is to prevent an interface from being brought down
    during system shutdown time, for example if the root filesystem is a network
    filesystem and the interface should stay up until the very end. Note that
    you can still bring down the interface by specifying the interface name
    explicitly.</p>
<p class="Pp">Lines beginning with &quot;no-scripts&quot; are used to identify
    interfaces for which scripts in <i>/etc/network/if-*.d/</i> should not be
    run when those interfaces are brought up or down. he above will match eth0
    and eth1, and will bring up both interfaces using the &quot;iface eth&quot;
    stanza.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERFACE_RENAMING"><a class="permalink" href="#INTERFACE_RENAMING">INTERFACE
  RENAMING</a></h1>
Lines beginning with &quot;rename&quot; are used to rename interfaces. It takes
  one or more arguments in the form of &quot;CUR=NEW&quot;, where CUR is the
  name of an existing interface, and NEW is the new name. This becomes very
  powerful when combined with pattern matching for the CUR interface.
<p class="Pp">Interfaces are renamed whenever &quot;ifup&quot; is called.
    Renaming logically happens before anything else is done. So if an interface
    is started with the name &quot;foo&quot;, and it has to be renamed to
    &quot;bar&quot; and brought up at boot time, then one should use the
    following /etc/network/interfaces file:</p>
<p class="Pp"></p>
<pre>
rename foo=bar
auto bar
iface bar ...
</pre>
<p class="Pp">However, if the interface is not renamed yet, it is possible to
    use both &quot;ifup foo&quot; and &quot;ifup bar&quot;. The former command
    will then automatically be converted to the latter. This is mainly useful
    when ifup is called automatically whenever an interface is hotplugged.</p>
<p class="Pp">Interface renaming only works if the operating system supports it,
    if an interface is not renamed to another existing interface, and may
    require that the interface that is to be renamed has not been brought up
    yet. If ifup tries to rename an interface and it fails, it will exit with an
    error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INCLUDING_OTHER_FILES"><a class="permalink" href="#INCLUDING_OTHER_FILES">INCLUDING
  OTHER FILES</a></h1>
Lines beginning with &quot;source&quot; are used to include stanzas from other
  files, so configuration can be split into many files. The word
  &quot;source&quot; is followed by the path of file to be sourced. Shell
  wildcards can be used. (See <b>wordexp</b>(3) for details.)
<p class="Pp">Similarly, &quot;source-directory&quot; keyword is used to source
    multiple files at once, without specifying them individually or using shell
    globs. Additionally, when &quot;source-directory&quot; is used, names of the
    files are checked to match the following regular expression:
    <i>^[a-zA-Z0-9_-]+$</i>. In other words, the names must consist entirely of
    ASCII upper- and lower-case letters, ASCII digits, ASCII underscores, and
    ASCII minus-hyphens. In the directory path, shell wildcards may be used as
    well.</p>
<p class="Pp">When sourcing files or directories, if a path doesn't have a
    leading slash, it's considered relative to the directory containing the file
    in which the keyword is placed. In the example above, if the file is located
    at <i>/etc/network/interfaces,</i> paths to the included files are
    understood to be under <i>/etc/network.</i></p>
<p class="Pp">By default, on a freshly installed Debian system, the interfaces
    file includes a line to source files in the <i>/etc/network/interfaces.d</i>
    directory.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAPPINGS"><a class="permalink" href="#MAPPINGS">MAPPINGS</a></h1>
Stanzas beginning with the word &quot;mapping&quot; are used to determine how a
  logical interface name is chosen for a physical interface that is to be
  brought up. The first line of a mapping stanza consists of the word
  &quot;mapping&quot; followed by a pattern in shell glob syntax. Each mapping
  stanza must contain a <b>script</b> definition. The named script is run with
  the physical interface name as its argument and with the contents of all
  following &quot;map&quot; lines (<b>without</b> the leading &quot;map&quot;)
  in the stanza provided to it on its standard input. The script must print a
  string on its standard output before exiting. See
  <i>/usr/share/doc/ifupdown/examples</i> for examples of what the script must
  print.
<p class="Pp">Mapping a name consists of searching the remaining mapping
    patterns and running the script corresponding to the first match; the script
    outputs the name to which the original is mapped.</p>
<p class="Pp"><b>ifup</b> is normally given a physical interface name as its
    first non-option argument. <b>ifup</b> also uses this name as the initial
    logical name for the interface unless it is accompanied by a suffix of the
    form <i>=LOGICAL</i>, in which case ifup chooses <i>LOGICAL</i> as the
    initial logical name for the interface. It then maps this name, possibly
    more than once according to successive mapping specifications, until no
    further mappings are possible. If the resulting name is the name of some
    defined logical interface then <b>ifup</b> attempts to bring up the physical
    interface as that logical interface. Otherwise <b>ifup</b> exits with an
    error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERFACE_DEFINITIONS"><a class="permalink" href="#INTERFACE_DEFINITIONS">INTERFACE
  DEFINITIONS</a></h1>
Stanzas defining logical interfaces start with a line consisting of the word
  &quot;iface&quot; followed by the name of the logical interface. In simple
  configurations without mapping stanzas this name should simply be the name of
  the physical interface to which it is to be applied. (The default mapping
  script is, in effect, the <b>echo</b> command.) The interface name is followed
  by the name of the address family that the interface uses. This will be
  &quot;inet&quot; for TCP/IP networking, but there is also some support for IPX
  networking (&quot;ipx&quot;), and IPv6 networking (&quot;inet6&quot;).
  Following that is the name of the method used to configure the interface.
<p class="Pp">Additional options can be given on subsequent lines in the stanza.
    Which options are available depends on the family and method, as described
    below. Additional options can be made available by other Debian packages.
    For example, the wireless-tools package makes available a number of options
    prefixed with &quot;wireless-&quot; which can be used to configure the
    interface using <b>iwconfig</b>(8)<b>.</b> (See <b>wireless</b>(7) for
    details.) A list of packages providing additional options is mentioned in
    the section &quot;OPTIONS PROVIDED BY OTHER PACKAGE&quot;.</p>
<p class="Pp">Options are usually indented for clarity (as in the example above)
    but are not required to be.</p>
<p class="Pp">Multiple &quot;iface&quot; stanzas can be given for the same
    interface, in which case all of the configured addresses and options for
    that interface will be applied when bringing up that interface. This is
    useful to configure both IPv4 and IPv6 addresses on the same interface
    (although if no inet6 stanza is present, the kernel will normally still
    perform stateless address autoconfiguration if there is an IPv6 route
    advertisement daemon on the network). It can also be used to configure
    multiple addresses of the same type on a single interface.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERFACE_TEMPLATES"><a class="permalink" href="#INTERFACE_TEMPLATES">INTERFACE
  TEMPLATES</a></h1>
It is possible to define interface definition templates and extend them using
  the <b>inherits</b> keyword:
<p class="Pp"></p>
<pre>
iface ethernet inet static
	mtu 1500
	hwaddress 11:22:33:44:55:66
iface eth0 inet static inherits ethernet
	address 192.168.1.2/24
</pre>
<p class="Pp">This may be useful to separate link-level settings shared by
    multiple interfaces from, for example, IP address settings specific to every
    interface.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PATTERN_MATCHING_INTERFACES"><a class="permalink" href="#PATTERN_MATCHING_INTERFACES">PATTERN
  MATCHING INTERFACES</a></h1>
It is possible to use patterns to match one or more real interfaces. These
  patterns can currently appear in lines beginning with &quot;auto&quot;,
  &quot;allow-&quot;, &quot;rename&quot; and on the command line. A pattern has
  the following format (see below for exceptions for GNU/Hurd):
<p class="Pp"></p>
<pre>
[VARIABLE]/VALUE[/[OPTIONS]][=LOGICAL]
</pre>
<p class="Pp">If no VARIABLE is given, this pattern will match interface names
    against the given VALUE. VALUE can contain wildcard patterns such as ? and
    *, see the <b>fnmatch</b>(3) function. When <b>ifup</b> or <b>ifdown</b> is
    run, patterns are replaces by all real interfaces that are currently known
    to the operating system kernel and whose names match the pattern. For
    example, given the following line:</p>
<p class="Pp"></p>
<pre>
auto /eth*
</pre>
<p class="Pp">If the kernel knows about the interfaces with names lo, eth0 and
    eth1, then the above line is then interpreted as:</p>
<p class="Pp"></p>
<pre>
auto eth0 eth1
</pre>
<p class="Pp">Note that there must still be valid &quot;iface&quot; stanzas for
    each matching interface. However, it is possible to combine a pattern with a
    mapping to a logical interface, like so:</p>
<p class="Pp"></p>
<pre>
auto /eth*=eth
iface eth inet dhcp
</pre>
<p class="Pp">Valid variable names are &quot;mac&quot;, in which case value is
    matched against the interface's MAC address. On Linux, the variable name can
    also be any filename in /sys/class/net/&lt;iface&gt;/, in which case the
    value is matched against the contents of the corresponding file.</p>
<p class="Pp">The OPTIONS field currently only supports a number. If given, only
    the n-th interface that has a matching value will actually be used, where n
    is the number given, starting at 1. So /eth*/1 will match the first
    interface whose name starts with eth.</p>
<p class="Pp">On GNU/Hurd, interface names start with /dev/, and this obviously
    clashes with the format for patterns. To ensure an interface name like
    /dev/eth0 does not get interpreted as a pattern, any pattern that starts
    with /dev/ is ignored, and instead interpreted as a literal interface name.
    To make a pattern that matches interface names on GNU/Hurd, use something
    like:</p>
<p class="Pp"></p>
<pre>
auto /?dev?eth*=eth
iface eth inet dhcp
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="VLAN_INTERFACES"><a class="permalink" href="#VLAN_INTERFACES">VLAN
  INTERFACES</a></h1>
To ease the configuration of VLAN interfaces, interfaces having <b>.</b> (full
  stop character) in the name are configured as 802.1q tagged virtual LAN
  interface. For example, interface <b>eth0.1</b> is a virtual interface with
  VLAN ID 1 having <b>eth0</b> as its parent interface.
<p class="Pp">VLAN interfaces are mostly treated as independent interfaces. As
    such, a VLAN interface is normally not automatically brought up when its
    parent interface is brought up. The exception is when ifup is called with
    the --allow option, in which case all VLAN interfaces that are in the same
    allow class as the parent interface are brought up together with the parent
    interface. For example:</p>
<p class="Pp"></p>
<pre>
allow-hotplug eth0 eth0.1
iface eth0 inet static
     address ...
iface eth0.1 inet static
     address ...
iface eth0.2 inet static
     address ...
</pre>
<p class="Pp">In the above example, when &quot;ifup --allow hotplug eth0&quot;
    is called (either manually or because udev triggers this when a network
    device is hotplugged), the interface eth0 and the VLAN interface eth0.1 are
    brought up, but eth0.2 is not.</p>
<p class="Pp">Keep in mind that pattern matching will only match interfaces the
    kernel knows about, so it is not possible to specify &quot;auto
    /eth0.*&quot; and have all VLAN interfaces for eth0 be brought up at boot
    time. Another way to ensure that a VLAN interface is brought up
    automatically when the parent interface is brought up, is to use a recursive
    call to ifup, like so:</p>
<p class="Pp"></p>
<pre>
iface eth0 inet manual
     up ifup eth0.3
iface eth0.3 inet static
     address ...
</pre>
<p class="Pp">Note that there is no need to add an explicit call to ifdown,
    since VLAN interfaces are automatically brought down whenever their parent
    interfaces are brought down.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="IFACE_OPTIONS"><a class="permalink" href="#IFACE_OPTIONS">IFACE
  OPTIONS</a></h1>
The following &quot;command&quot; options are available for every family and
  method. Each of these options can be given multiple times in a single stanza,
  in which case the commands are executed in the order in which they appear in
  the stanza. (You can ensure a command never fails by suffixing them with
  &quot;|| true&quot;.)
<dl class="Bl-tag">
  <dt><b>pre-up</b><i> command</i></dt>
  <dd>Run <i>command</i> before bringing the interface up. If this command fails
      then <b>ifup</b> aborts, refraining from marking the interface as
      configured, prints an error message, and exits with status 0. This
      behavior may change in the future.</dd>
  <dt><b>up</b><i> command</i></dt>
  <dd></dd>
  <dt><b>post-up</b><i> command</i></dt>
  <dd>Run <i>command</i> after bringing the interface up. If this command fails
      then <b>ifup</b> aborts, refraining from marking the interface as
      configured (even though it has really been configured), prints an error
      message, and exits with status 0. This behavior may change in the
    future.</dd>
  <dt><b>down</b><i> command</i></dt>
  <dd></dd>
  <dt><b>pre-down</b><i> command</i></dt>
  <dd>Run <i>command</i> before taking the interface down. If this command fails
      then <b>ifdown</b> aborts, marks the interface as deconfigured (even
      though it has not really been deconfigured), and exits with status 0. This
      behavior may change in the future.</dd>
  <dt><b>post-down</b><i> command</i></dt>
  <dd>Run <i>command</i> after taking the interface down. If this command fails
      then <b>ifdown</b> aborts, marks the interface as deconfigured, and exits
      with status 0. This behavior may change in the future.</dd>
  <dt><b>description</b><i> name</i></dt>
  <dd>Alias interface by <i>name</i></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="HOOK_SCRIPTS"><a class="permalink" href="#HOOK_SCRIPTS">HOOK
  SCRIPTS</a></h1>
There are four directories in which scripts can be placed which will always be
  run for any interface during certain phases of ifup and ifdown commands. These
  are:
<dl class="Bl-tag">
  <dt><i>/etc/network/if-pre-up.d/</i></dt>
  <dd>Scripts in this directory are run before bringing the interface up.</dd>
  <dt><i>/etc/network/if-up.d/</i></dt>
  <dd>Scripts in this directory are run after bringing the interface up.</dd>
  <dt><i>/etc/network/if-down.d/</i></dt>
  <dd>Scripts in this directory are run before bringing the interface down.</dd>
  <dt><i>/etc/network/if-post-down.d/</i></dt>
  <dd>Scripts in this directory are run after bringing the interface down.</dd>
</dl>
<p class="Pp">The scripts in which are run (with no arguments) using
    <b>run-parts</b>(8) after the corresponding <b>pre-up,</b> <b>up,</b>
    <b>down</b> and <b>post-down</b> options in the
    <i>/etc/network/interfaces</i> file itself have been processed. Please note
    that as <b>post-up</b> and <b>pre-down</b> are aliases, no files in the
    corresponding directories are processed. Please use <i>if-up.d</i> and
    <i>if-down.d</i> directories instead.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT_VARIABLES"><a class="permalink" href="#ENVIRONMENT_VARIABLES">ENVIRONMENT
  VARIABLES</a></h1>
All hook scripts, and the commands executed by <b>pre-up,</b> <b>up,</b>
  <b>post-up,</b> <b>pre-down,</b> <b>down</b> and <b>post-down</b> have access
  to the following environment variables:
<dl class="Bl-tag">
  <dt><b>IFACE</b></dt>
  <dd>The physical name of the interface being processed, or &quot;--all&quot;
      (see below).</dd>
  <dt><b>LOGICAL</b></dt>
  <dd>The logical name of the interface being processed, or &quot;auto&quot;
      (see below).</dd>
  <dt><b>ADDRFAM</b></dt>
  <dd>The address family of the interface, or &quot;meta&quot; (see below).</dd>
  <dt><b>METHOD</b></dt>
  <dd>The method of the interface (e.g., <i>static</i>), or &quot;none&quot;
      (see below).</dd>
  <dt><b>CLASS</b></dt>
  <dd>The class of interfaces being processed. This is a copy of the value given
      to the <b>--allow</b> option when running ifup or ifdown, otherwise it is
      set to &quot;auto&quot; when the <b>--all</b> option is used.</dd>
  <dt><b>MODE</b></dt>
  <dd><i>start</i> if run from ifup, <i>stop</i> if run from ifdown<i>.</i></dd>
  <dt><b>PHASE</b></dt>
  <dd>As per MODE, but with finer granularity, distinguishing the <i>pre-up</i>,
      <i>post-up</i>, <i>pre-down</i> and <i>post-down</i> phases.</dd>
  <dt><b>VERBOSITY</b></dt>
  <dd>Indicates whether <b>--verbose</b> was used; set to 1 if so, 0 if
    not.</dd>
  <dt><b>PATH</b></dt>
  <dd>The command search path:
      <i>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</i></dd>
</dl>
<p class="Pp">Additionally, all options given in an interface definition stanza
    are exported to the environment in upper case with &quot;IF_&quot; prepended
    and with hyphens converted to underscores and non-alphanumeric characters
    discarded.</p>
<p class="Pp">When ifupdown is being called with the <b>--all</b> option, before
    doing anything to interfaces, it calls all the hook scripts (<i>pre-up</i>
    or <i>down</i>) with <b>IFACE</b> set to &quot;--all&quot;, <b>LOGICAL</b>
    set to the current value of --allow parameter (or &quot;auto&quot; if it's
    not set), <b>ADDRFAM</b>=&quot;meta&quot; and
    <b>METHOD</b>=&quot;none&quot;. After all the interfaces have been brought
    up or taken down, the appropriate scripts (<i>up</i> or <i>post-down</i>)
    are executed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONCURRENCY_AND_PARALLEL_EXECUTION"><a class="permalink" href="#CONCURRENCY_AND_PARALLEL_EXECUTION">CONCURRENCY
  AND PARALLEL EXECUTION</a></h1>
Ifupdown uses per-interface locking to ensure that concurrent ifup and ifdown
  calls to the same interface are run in serial. However, calls to different
  interfaces will be able to run in parallel. It is therefore important that any
  hook scripts and <i>pre-up</i>, <i>up</i>, <i>down</i> and <i>post-down</i>
  commands are written with the possibility of parallel execution in mind.
<p class="Pp">It is allowed to recursively call <b>ifup</b> and <b>ifdown</b>
    from hook scripts and interface commands, as long as these calls refer to a
    different interface than the one that is already being (de)configured. Loops
    are detected and will result in the call failing instead of a deadlock,
    although it is best if one does not rely on that.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS_PROVIDED_BY_OTHER_PACKAGES"><a class="permalink" href="#OPTIONS_PROVIDED_BY_OTHER_PACKAGES">OPTIONS
  PROVIDED BY OTHER PACKAGES</a></h1>
This manual page documents the configuration options provided by the ifupdown
  package. However, other packages can make other options available for use in
  /etc/network/interfaces. Here is a list of packages that provide such
  extensions:
<p class="Pp">arping, avahi-autoipd, avahi-daemon, bind9, bridge-utils,
    clamav-freshclam, controlaula, epoptes-client, ethtool, guidedog,
    hostap-utils, hostapd, htpdate, ifenslave, ifmetric, ifupdown-extra,
    ifupdown-multi, ifupdown-scripts-zg2, initscripts, isatapd, linux-wlan-ng,
    lprng, macchanger, miredo, nslcd, ntpdate, openntpd, openresolv,
    openssh-server, openvpn, openvswitch-switch, postfix, resolvconf,
    sendmail-base, shorewall-init, slrn, slrnpull, tinc, ucarp, uml-utilities,
    uruk, vde2, vlan, vzctl, whereami, wide-dhcpv6-client, wireless-tools,
    wpasupplicant.</p>
<p class="Pp">Please consult the documentation of those packages for information
    about how they extend ifupdown.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INET_ADDRESS_FAMILY"><a class="permalink" href="#INET_ADDRESS_FAMILY">INET
  ADDRESS FAMILY</a></h1>
This section documents the methods available in the inet address family.
<section class="Ss">
<h2 class="Ss" id="The_loopback_Method"><a class="permalink" href="#The_loopback_Method">The
  loopback Method</a></h2>
This method may be used to define the IPv4 loopback interface.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>(No options)</dt>
  <dd></dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_static_Method"><a class="permalink" href="#The_static_Method">The
  static Method</a></h2>
This method may be used to define Ethernet interfaces with statically allocated
  IPv4 addresses.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>address</b><i> address </i></dt>
  <dd>Address (dotted quad/netmask) <b>required</b></dd>
  <dt><b>netmask</b><i> mask </i></dt>
  <dd>Netmask (dotted quad or number of bits) <b>deprecated</b></dd>
  <dt><b>broadcast</b><i> broadcast_address</i></dt>
  <dd>Broadcast address (dotted quad, + or -) <b>deprecated</b>. Default value:
      &quot;+&quot;</dd>
  <dt><b>metric</b><i> metric </i></dt>
  <dd>Routing metric for default gateway (integer)</dd>
  <dt><b>gateway</b><i> address </i></dt>
  <dd>Default gateway (dotted quad)</dd>
  <dt><b>pointopoint</b><i> address </i></dt>
  <dd>Address of other end point (dotted quad). Note the spelling of
      &quot;point-to&quot;.</dd>
  <dt><b>hwaddress</b><i> address </i></dt>
  <dd>Link local address or &quot;random&quot;.</dd>
  <dt><b>mtu</b><i> size </i></dt>
  <dd>MTU size</dd>
  <dt><b>scope</b></dt>
  <dd>Address validity scope. Possible values: global, link, host</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_manual_Method"><a class="permalink" href="#The_manual_Method">The
  manual Method</a></h2>
This method may be used to define interfaces for which no configuration is done
  by default. Such interfaces can be configured manually by means of <b>up</b>
  and <b>down</b> commands or /etc/network/if-*.d scripts.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>hwaddress</b><i> address </i></dt>
  <dd>Link local address or &quot;random&quot;.</dd>
  <dt><b>mtu</b><i> size </i></dt>
  <dd>MTU size</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_dhcp_Method"><a class="permalink" href="#The_dhcp_Method">The
  dhcp Method</a></h2>
This method may be used to obtain an address via DHCP with any of the tools:
  dhclient, pump, udhcpc, dhcpcd. (They have been listed in their order of
  precedence.) If you have a complicated DHCP setup you should note that some of
  these clients use their own configuration files and do not obtain their
  configuration information via <b>ifup</b>.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>hostname</b><i> hostname </i></dt>
  <dd>Hostname to be requested (pump, dhcpcd, udhcpc)</dd>
  <dt><b>metric</b><i> metric </i></dt>
  <dd>Metric for added routes (dhclient)</dd>
  <dt><b>leasehours</b><i> leasehours </i></dt>
  <dd>Preferred lease time in hours (pump)</dd>
  <dt><b>leasetime</b><i> leasetime </i></dt>
  <dd>Preferred lease time in seconds (dhcpcd)</dd>
  <dt><b>vendor</b><i> vendor </i></dt>
  <dd>Vendor class identifier (dhcpcd)</dd>
  <dt><b>client</b><i> client </i></dt>
  <dd>Client identifier (dhcpcd)</dd>
  <dt><b>hwaddress</b><i> address </i></dt>
  <dd>Hardware address.</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_bootp_Method"><a class="permalink" href="#The_bootp_Method">The
  bootp Method</a></h2>
This method may be used to obtain an address via bootp.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>bootfile</b><i> file </i></dt>
  <dd>Tell the server to use <i>file</i> as the bootfile.</dd>
  <dt><b>server</b><i> address</i></dt>
  <dd>Use the IP address <i>address</i> to communicate with the server.</dd>
  <dt><b>hwaddr</b><i> addr </i></dt>
  <dd>Use <i>addr</i> as the hardware address instead of whatever it really
    is.</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_tunnel_Method"><a class="permalink" href="#The_tunnel_Method">The
  tunnel Method</a></h2>
This method is used to create GRE or IPIP tunnels. You need to have the
  <b>ip</b> binary from the <b>iproute</b> package. For GRE tunnels, you will
  need to load the ip_gre module and the ipip module for IPIP tunnels.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>address</b><i> address </i></dt>
  <dd>Local address (dotted quad) <b>required</b></dd>
  <dt><b>mode</b><i> type </i></dt>
  <dd>Tunnel type (either GRE or IPIP) <b>required</b></dd>
  <dt><b>endpoint</b><i> address </i></dt>
  <dd>Address of other tunnel endpoint <b>required</b></dd>
  <dt><b>dstaddr</b><i> address </i></dt>
  <dd>Remote address (remote address inside tunnel)</dd>
  <dt><b>local</b><i> address </i></dt>
  <dd>Address of the local endpoint</dd>
  <dt><b>metric</b><i> metric </i></dt>
  <dd>Routing metric for default gateway (integer)</dd>
  <dt><b>gateway</b><i> address </i></dt>
  <dd>Default gateway</dd>
  <dt><b>ttl</b><i> time </i></dt>
  <dd>TTL setting</dd>
  <dt><b>mtu</b><i> size </i></dt>
  <dd>MTU size</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_ppp_Method"><a class="permalink" href="#The_ppp_Method">The
  ppp Method</a></h2>
This method uses pon/poff to configure a PPP interface. See those commands for
  details.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>provider</b><i> name </i></dt>
  <dd>Use <i>name</i> as the provider (from /etc/ppp/peers).</dd>
  <dt><b>unit</b><i> number </i></dt>
  <dd>Use <i>number</i> as the ppp unit number.</dd>
  <dt><b>options</b><i> string</i></dt>
  <dd>Pass <i>string</i> as additional options to pon.</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_wvdial_Method"><a class="permalink" href="#The_wvdial_Method">The
  wvdial Method</a></h2>
This method uses wvdial to configure a PPP interface. See that command for more
  details.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>provider</b><i> name </i></dt>
  <dd>Use <i>name</i> as the provider (from /etc/wvdial.conf).</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_ipv4ll_Method"><a class="permalink" href="#The_ipv4ll_Method">The
  ipv4ll Method</a></h2>
This method uses avahi-autoipd to configure an interface with an IPv4 Link-Layer
  address (169.254.0.0/16 family). This method is also known as APIPA or IPAC,
  and often colloquially referred to as &quot;Zeroconf address&quot;.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>(No options)</dt>
  <dd></dd>
</dl>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="IPX_ADDRESS_FAMILY"><a class="permalink" href="#IPX_ADDRESS_FAMILY">IPX
  ADDRESS FAMILY</a></h1>
This section documents the methods available in the ipx address family.
<section class="Ss">
<h2 class="Ss" id="The_static_Method_2"><a class="permalink" href="#The_static_Method_2">The
  static Method</a></h2>
This method may be used to setup an IPX interface. It requires the
  <i>ipx_interface</i> command.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>frame</b><i> type </i></dt>
  <dd><i>type</i> of Ethernet frames to use (e.g. <b>802.2</b>)</dd>
  <dt><b>netnum</b><i> id </i></dt>
  <dd>Network number</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_dynamic_Method"><a class="permalink" href="#The_dynamic_Method">The
  dynamic Method</a></h2>
This method may be used to setup an IPX interface dynamically.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>frame</b><i> type </i></dt>
  <dd><i>type</i> of Ethernet frames to use (e.g. <b>802.2</b>)</dd>
</dl>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="INET6_ADDRESS_FAMILY"><a class="permalink" href="#INET6_ADDRESS_FAMILY">INET6
  ADDRESS FAMILY</a></h1>
This section documents the methods available in the inet6 address family.
<section class="Ss">
<h2 class="Ss" id="The_auto_Method"><a class="permalink" href="#The_auto_Method">The
  auto Method</a></h2>
This method may be used to define interfaces with automatically assigned IPv6
  addresses. Using this method on its own doesn't mean that RDNSS options will
  be applied, too. To make this happen, <b>rdnssd</b> daemon must be installed,
  properly configured and running. If stateless DHCPv6 support is turned on,
  then additional network configuration parameters such as DNS and NTP servers
  will be retrieved from a DHCP server. Please note that on ifdown, the lease is
  not currently released (a known bug).
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>privext</b><i> int </i></dt>
  <dd>Privacy extensions (RFC4941) (0=off, 1=assign, 2=prefer)</dd>
  <dt><b>accept_ra</b><i> int </i></dt>
  <dd>Accept router advertisements (0=off, 1=on, 2=on+forwarding). Default
      value: &quot;2&quot;</dd>
  <dt><b>dhcp</b><i> int </i></dt>
  <dd>Use stateless DHCPv6 (0=off, 1=on)</dd>
  <dt><b>request_prefix</b><i> int </i></dt>
  <dd>Request a prefix through DHCPv6 Prefix Delegation (0=off, 1=on). Default
      value: &quot;0&quot;</dd>
  <dt><b>ll-attempts</b></dt>
  <dd>Number of attempts to wait for a link-local address. Default value:
      &quot;60&quot;</dd>
  <dt><b>ll-interval</b></dt>
  <dd>Link-local address polling interval in seconds. Default value:
      &quot;0.1&quot;</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_loopback_Method_2"><a class="permalink" href="#The_loopback_Method_2">The
  loopback Method</a></h2>
This method may be used to define the IPv6 loopback interface.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>(No options)</dt>
  <dd></dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_static_Method_3"><a class="permalink" href="#The_static_Method_3">The
  static Method</a></h2>
This method may be used to define interfaces with statically assigned IPv6
  addresses. By default, stateless autoconfiguration is disabled for this
  interface.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>address</b><i> address </i></dt>
  <dd>Address (colon delimited/netmask) <b>required</b></dd>
  <dt><b>netmask</b><i> mask </i></dt>
  <dd>Netmask (number of bits, eg 64) <b>deprecated</b></dd>
  <dt><b>metric</b><i> metric </i></dt>
  <dd>Routing metric for default gateway (integer)</dd>
  <dt><b>gateway</b><i> address </i></dt>
  <dd>Default gateway (colon delimited)</dd>
  <dt><b>media</b><i> type </i></dt>
  <dd>Medium type, driver dependent</dd>
  <dt><b>hwaddress</b><i> address </i></dt>
  <dd>Hardware address or &quot;random&quot;</dd>
  <dt><b>mtu</b><i> size </i></dt>
  <dd>MTU size</dd>
  <dt><b>accept_ra</b><i> int </i></dt>
  <dd>Accept router advertisements (0=off, 1=on, 2=on+forwarding)</dd>
  <dt><b>autoconf</b><i> int </i></dt>
  <dd>Perform stateless autoconfiguration (0=off, 1=on). Default value:
      &quot;0&quot;</dd>
  <dt><b>privext</b><i> int </i></dt>
  <dd>Privacy extensions (RFC3041) (0=off, 1=assign, 2=prefer)</dd>
  <dt><b>scope</b></dt>
  <dd>Address validity scope. Possible values: global, site, link, host</dd>
  <dt><b>preferred-lifetime</b><i> int</i></dt>
  <dd>Time that address remains preferred</dd>
  <dt><b>dad-attempts</b></dt>
  <dd>Number of attempts to settle DAD (0 to disable DAD). Default value:
      &quot;60&quot;</dd>
  <dt><b>dad-interval</b></dt>
  <dd>DAD state polling interval in seconds. Default value: &quot;0.1&quot;</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_manual_Method_2"><a class="permalink" href="#The_manual_Method_2">The
  manual Method</a></h2>
This method may be used to define interfaces for which no configuration is done
  by default. Such interfaces can be configured manually by means of <b>up</b>
  and <b>down</b> commands or /etc/network/if-*.d scripts.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>hwaddress</b><i> address </i></dt>
  <dd>Hardware address or &quot;random&quot;</dd>
  <dt><b>mtu</b><i> size </i></dt>
  <dd>MTU size</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_dhcp_Method_2"><a class="permalink" href="#The_dhcp_Method_2">The
  dhcp Method</a></h2>
This method may be used to obtain network interface configuration via stateful
  DHCPv6 with dhclient. In stateful DHCPv6, the DHCP server is responsible for
  assigning addresses to clients.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>hwaddress</b><i> address </i></dt>
  <dd>Hardware address or &quot;random&quot;</dd>
  <dt><b>accept_ra</b><i> int </i></dt>
  <dd>Accept router advertisements (0=off, 1=on, 2=on+forwarding). Default
      value: &quot;1&quot;</dd>
  <dt><b>autoconf</b><i> int </i></dt>
  <dd>Perform stateless autoconfiguration (0=off, 1=on)</dd>
  <dt><b>request_prefix</b><i> int </i></dt>
  <dd>Request a prefix through DHCPv6 Prefix Delegation (0=off, 1=on). Default
      value: &quot;0&quot;</dd>
  <dt><b>ll-attempts</b></dt>
  <dd>Number of attempts to wait for a link-local address. Default value:
      &quot;60&quot;</dd>
  <dt><b>ll-interval</b></dt>
  <dd>Link-local address polling interval in seconds. Default value:
      &quot;0.1&quot;</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_v4tunnel_Method"><a class="permalink" href="#The_v4tunnel_Method">The
  v4tunnel Method</a></h2>
This method may be used to setup an IPv6-over-IPv4 tunnel. It requires the
  <b>ip</b> command from the <b>iproute</b> package.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>address</b><i> address </i></dt>
  <dd>Address (colon delimited/netmask) <b>required</b></dd>
  <dt><b>netmask</b><i> mask </i></dt>
  <dd>Netmask (number of bits, eg 64) <b>deprecated</b></dd>
  <dt><b>endpoint</b><i> address </i></dt>
  <dd>Address of other tunnel endpoint (IPv4 dotted quad) <b>required</b></dd>
  <dt><b>local</b><i> address </i></dt>
  <dd>Address of the local endpoint (IPv4 dotted quad)</dd>
  <dt><b>metric</b><i> metric </i></dt>
  <dd>Routing metric for default gateway (integer)</dd>
  <dt><b>gateway</b><i> address </i></dt>
  <dd>Default gateway (colon delimited)</dd>
  <dt><b>ttl</b><i> time </i></dt>
  <dd>TTL setting</dd>
  <dt><b>mtu</b><i> size </i></dt>
  <dd>MTU size</dd>
  <dt><b>preferred-lifetime</b><i> int</i></dt>
  <dd>Time that address remains preferred</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="The_6to4_Method"><a class="permalink" href="#The_6to4_Method">The
  6to4 Method</a></h2>
This method may be used to setup an 6to4 tunnel. It requires the <b>ip</b>
  command from the <b>iproute</b> package.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>local</b><i> address </i></dt>
  <dd>Address of the local endpoint (IPv4 dotted quad) <b>required</b></dd>
  <dt><b>metric</b><i> metric </i></dt>
  <dd>Routing metric for default gateway (integer)</dd>
  <dt><b>ttl</b><i> time </i></dt>
  <dd>TTL setting</dd>
  <dt><b>mtu</b><i> size </i></dt>
  <dd>MTU size</dd>
  <dt><b>preferred-lifetime</b><i> int</i></dt>
  <dd>Time that address remains preferred</dd>
</dl>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAN_ADDRESS_FAMILY"><a class="permalink" href="#CAN_ADDRESS_FAMILY">CAN
  ADDRESS FAMILY</a></h1>
This section documents the methods available in the can address family.
<section class="Ss">
<h2 class="Ss" id="The_static_Method_4"><a class="permalink" href="#The_static_Method_4">The
  static Method</a></h2>
This method may be used to setup an Controller Area Network (CAN) interface. It
  requires the the <b>ip</b> command from the <b>iproute</b> package.
<p class="Pp"><b>Options</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>bitrate</b><i> bitrate	</i></dt>
  <dd>bitrate (1..1000000) <b>required</b></dd>
  <dt><b>samplepoint</b><i> samplepoint</i></dt>
  <dd>sample point (0.000..0.999)</dd>
  <dt><b>loopback</b><i> loopback	</i></dt>
  <dd>loop back CAN Messages (on|off)</dd>
  <dt><b>listenonly</b><i> listenonly</i></dt>
  <dd>listen only mode (on|off)</dd>
  <dt><b>triple</b><i> triple	</i></dt>
  <dd>activate triple sampling (on|off)</dd>
  <dt><b>oneshot</b><i> oneshot	</i></dt>
  <dd>one shot mode (on|off)</dd>
  <dt><b>berr</b><i> berr		</i></dt>
  <dd>activate berr reporting (on|off)</dd>
</dl>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS/LIMITATIONS"><a class="permalink" href="#KNOWN_BUGS/LIMITATIONS">KNOWN
  BUGS/LIMITATIONS</a></h1>
The <b>ifup</b> and <b>ifdown</b> programs work with so-called
  &quot;physical&quot; interface names. These names are assigned to hardware by
  the kernel. Unfortunately it can happen that the kernel assigns different
  physical interface names to the same hardware at different times; for example,
  what was called &quot;eth0&quot; last time you booted is now called
  &quot;eth1&quot; and vice versa. This creates a problem if you want to
  configure the interfaces appropriately. A way to deal with this problem is to
  use mapping scripts that choose logical interface names according to the
  properties of the interface hardware. See the <b>get-mac-address.sh</b> script
  in the examples directory for an example of such a mapping script. See also
  Debian bug #101728.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
The ifupdown suite was written by Anthony Towns &lt;aj@azure.humbug.org.au&gt;.
  This manpage was contributed by Joey Hess &lt;joey@kitenet.net&gt;.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>ifup</b>(8), <b>ip</b>(8), <b>ifconfig</b>(8), <b>run-parts</b>(8),
  <b>resolvconf</b>(8).
<p class="Pp">For advice on configuring this package read the <b>Network
    Configuration</b> chapter of the <i>Debian Reference</i> manual, available
    at <i>http://www.debian.org/doc/manuals/debian-reference/ch05.en.html</i> or
    in the <b>debian-reference-en</b> package.</p>
<p class="Pp">Examples of how to set up interfaces can be found in
    <b>/usr/share/doc/ifupdown/examples/network-interfaces.gz</b>.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">24 July 2017</td>
    <td class="foot-os">ifupdown</td>
  </tr>
</table>

	</div>
	<div class=footer>
		<p>Copyright 2020 Scott Court</p>
	</div>
	</div>
</body>
