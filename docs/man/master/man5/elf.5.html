
<!DOCTYPE HTML>
<head>
	<title>/usr/share/man/man5/elf.5</title>		<link rel='stylesheet' href='/mandoc.css' />
	<link rel='stylesheet' href='/style.css' />
</head>
<body>
	<div class=contents>
	<div class=header>
	<h1>The Fidelix Linux Distribution</h1>
	<h2>Simple, Stable, and Secure</h2>
	</div>
<div class=menubar>
	<ul>
		<li><a href=/>News</a></li>
		<li><a href=/about.html>About</a></li>
		<div class=dropdown>
			<li><a href=/download>Download</a></li>
			<ul class=dropdown-content>
				<li><a href=/download/>Latest Downloads</a></li>
				<li><a href=/download/all.html>All Downloads</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Documentation</a></li>
			<ul class=dropdown-content>
				<li><a href=/handbook/>Handbook</a></li>
				<li><a href=/man/>Manual Pages</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Development</a></li>
			<ul class=dropdown-content>
				<li><a href=https://github.com/Z5T1/fidelix>GitHub</a></li>
			</ul>
		</div>
	</ul>
</div>


	<div class=body><table class="head">
  <tr>
    <td class="head-ltitle">ELF(5)</td>
    <td class="head-vol">Linux Programmer's Manual</td>
    <td class="head-rtitle">ELF(5)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
elf - format of Executable and Linking Format (ELF) files
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
<b>#include &lt;elf.h&gt;</b>
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The header file <i>&lt;elf.h&gt;</i> defines the format of ELF executable binary
  files. Amongst these files are normal executable files, relocatable object
  files, core files, and shared objects.
<p class="Pp">An executable file using the ELF file format consists of an ELF
    header, followed by a program header table or a section header table, or
    both. The ELF header is always at offset zero of the file. The program
    header table and the section header table's offset in the file are defined
    in the ELF header. The two tables describe the rest of the particularities
    of the file.</p>
<p class="Pp">This header file describes the above mentioned headers as C
    structures and also includes structures for dynamic sections, relocation
    sections and symbol tables.</p>
<section class="Ss">
<h2 class="Ss" id="Basic_types"><a class="permalink" href="#Basic_types">Basic
  types</a></h2>
The following types are used for N-bit architectures (N=32,64, <i>ElfN</i>
  stands for <i>Elf32</i> or <i>Elf64</i>, <i>uintN_t</i> stands for
  <i>uint32_t</i> or <i>uint64_t</i>):
<p class="Pp">
  <br/>
</p>
<pre>
ElfN_Addr       Unsigned program address, uintN_t
ElfN_Off        Unsigned file offset, uintN_t
ElfN_Section    Unsigned section index, uint16_t
ElfN_Versym     Unsigned version symbol information, uint16_t
Elf_Byte        unsigned char
ElfN_Half       uint16_t
ElfN_Sword      int32_t
ElfN_Word       uint32_t
ElfN_Sxword     int64_t
ElfN_Xword      uint64_t

</pre>
<br/>
<p class="Pp">(Note: the *BSD terminology is a bit different. There,
    <i>Elf64_Half</i> is twice as large as <i>Elf32_Half</i>, and
    <i>Elf64Quarter</i> is used for <i>uint16_t</i>. In order to avoid confusion
    these types are replaced by explicit ones in the below.)</p>
<p class="Pp">All data structures that the file format defines follow the
    &quot;natural&quot; size and alignment guidelines for the relevant class. If
    necessary, data structures contain explicit padding to ensure 4-byte
    alignment for 4-byte objects, to force structure sizes to a multiple of 4,
    and so on.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ELF_header_(Ehdr)"><a class="permalink" href="#ELF_header_(Ehdr)">ELF
  header (Ehdr)</a></h2>
The ELF header is described by the type <i>Elf32_Ehdr</i> or <i>Elf64_Ehdr</i>:
<p class="Pp">
  <br/>
</p>
<pre>
#define EI_NIDENT 16
typedef struct {
    unsigned char e_ident[EI_NIDENT];
    uint16_t      e_type;
    uint16_t      e_machine;
    uint32_t      e_version;
    ElfN_Addr     e_entry;
    ElfN_Off      e_phoff;
    ElfN_Off      e_shoff;
    uint32_t      e_flags;
    uint16_t      e_ehsize;
    uint16_t      e_phentsize;
    uint16_t      e_phnum;
    uint16_t      e_shentsize;
    uint16_t      e_shnum;
    uint16_t      e_shstrndx;
} ElfN_Ehdr;

</pre>
<br/>
<p class="Pp">The fields have the following meanings:</p>
<dl class="Bl-tag">
  <dt><i>e_ident</i></dt>
  <dd>This array of bytes specifies how to interpret the file, independent of
      the processor or the file's remaining contents. Within this array
      everything is named by macros, which start with the prefix <b>EI_</b> and
      may contain values which start with the prefix <b>ELF</b>. The following
      macros are defined:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>EI_MAG0</b></dt>
  <dd>The first byte of the magic number. It must be filled with <b>ELFMAG0</b>.
      (0: 0x7f)</dd>
  <dt><b>EI_MAG1</b></dt>
  <dd>The second byte of the magic number. It must be filled with
      <b>ELFMAG1</b>. (1: 'E')</dd>
  <dt><b>EI_MAG2</b></dt>
  <dd>The third byte of the magic number. It must be filled with <b>ELFMAG2</b>.
      (2: 'L')</dd>
  <dt><b>EI_MAG3</b></dt>
  <dd>The fourth byte of the magic number. It must be filled with
      <b>ELFMAG3</b>. (3: 'F')</dd>
  <dt><b>EI_CLASS</b></dt>
  <dd>The fifth byte identifies the architecture for this binary:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>ELFCLASSNONE</b></dt>
  <dd>This class is invalid.</dd>
  <dt><b>ELFCLASS32</b></dt>
  <dd>This defines the 32-bit architecture. It supports machines with files and
      virtual address spaces up to 4 Gigabytes.</dd>
  <dt><b>ELFCLASS64</b></dt>
  <dd>This defines the 64-bit architecture.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>EI_DATA</b></dt>
  <dd>The sixth byte specifies the data encoding of the processor-specific data
      in the file. Currently, these encodings are supported:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>ELFDATANONE</b></dt>
  <dd>Unknown data format.</dd>
  <dt><b>ELFDATA2LSB</b></dt>
  <dd>Two's complement, little-endian.</dd>
  <dt><b>ELFDATA2MSB</b></dt>
  <dd>Two's complement, big-endian.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>EI_VERSION</b></dt>
  <dd>The seventh byte is the version number of the ELF specification:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>EV_NONE</b></dt>
  <dd>Invalid version.</dd>
  <dt><b>EV_CURRENT</b></dt>
  <dd>Current version.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>EI_OSABI</b></dt>
  <dd>The eighth byte identifies the operating system and ABI to which the
      object is targeted. Some fields in other ELF structures have flags and
      values that have platform-specific meanings; the interpretation of those
      fields is determined by the value of this byte. For example:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>ELFOSABI_NONE</b></dt>
  <dd>Same as ELFOSABI_SYSV</dd>
  <dt><b>ELFOSABI_SYSV</b></dt>
  <dd>UNIX System V ABI</dd>
  <dt><b>ELFOSABI_HPUX</b></dt>
  <dd>HP-UX ABI</dd>
  <dt><b>ELFOSABI_NETBSD</b></dt>
  <dd>NetBSD ABI</dd>
  <dt><b>ELFOSABI_LINUX</b></dt>
  <dd>Linux ABI</dd>
  <dt><b>ELFOSABI_SOLARIS</b></dt>
  <dd>Solaris ABI</dd>
  <dt><b>ELFOSABI_IRIX</b></dt>
  <dd>IRIX ABI</dd>
  <dt><b>ELFOSABI_FREEBSD</b></dt>
  <dd>FreeBSD ABI</dd>
  <dt><b>ELFOSABI_TRU64</b></dt>
  <dd>TRU64 UNIX ABI</dd>
  <dt><b>ELFOSABI_ARM</b></dt>
  <dd>ARM architecture ABI</dd>
  <dt><b>ELFOSABI_STANDALONE</b></dt>
  <dd>Stand-alone (embedded) ABI</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>EI_ABIVERSION</b></dt>
  <dd>The ninth byte identifies the version of the ABI to which the object is
      targeted. This field is used to distinguish among incompatible versions of
      an ABI. The interpretation of this version number is dependent on the ABI
      identified by the <b>EI_OSABI</b> field. Applications conforming to this
      specification use the value 0.</dd>
  <dt><b>EI_PAD</b></dt>
  <dd>Start of padding. These bytes are reserved and set to zero. Programs which
      read them should ignore them. The value for <b>EI_PAD</b> will change in
      the future if currently unused bytes are given meanings.</dd>
  <dt><b>EI_NIDENT</b></dt>
  <dd>The size of the <i>e_ident</i> array.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>e_type</i></dt>
  <dd>This member of the structure identifies the object file type:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>ET_NONE</b></dt>
  <dd>An unknown type.</dd>
  <dt><b>ET_REL</b></dt>
  <dd>A relocatable file.</dd>
  <dt><b>ET_EXEC</b></dt>
  <dd>An executable file.</dd>
  <dt><b>ET_DYN</b></dt>
  <dd>A shared object.</dd>
  <dt><b>ET_CORE</b></dt>
  <dd>A core file.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>e_machine</i></dt>
  <dd>This member specifies the required architecture for an individual file.
      For example:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>EM_NONE</b></dt>
  <dd>An unknown machine</dd>
  <dt><b>EM_M32</b></dt>
  <dd>AT&amp;T WE 32100</dd>
  <dt><b>EM_SPARC</b></dt>
  <dd>Sun Microsystems SPARC</dd>
  <dt><b>EM_386</b></dt>
  <dd>Intel 80386</dd>
  <dt><b>EM_68K</b></dt>
  <dd>Motorola 68000</dd>
  <dt><b>EM_88K</b></dt>
  <dd>Motorola 88000</dd>
  <dt><b>EM_860</b></dt>
  <dd>Intel 80860</dd>
  <dt><b>EM_MIPS</b></dt>
  <dd>MIPS RS3000 (big-endian only)</dd>
  <dt><b>EM_PARISC</b></dt>
  <dd>HP/PA</dd>
  <dt><b>EM_SPARC32PLUS</b></dt>
  <dd>SPARC with enhanced instruction set</dd>
  <dt><b>EM_PPC</b></dt>
  <dd>PowerPC</dd>
  <dt><b>EM_PPC64</b></dt>
  <dd>PowerPC 64-bit</dd>
  <dt><b>EM_S390</b></dt>
  <dd>IBM S/390</dd>
  <dt><b>EM_ARM</b></dt>
  <dd>Advanced RISC Machines</dd>
  <dt><b>EM_SH</b></dt>
  <dd>Renesas SuperH</dd>
  <dt><b>EM_SPARCV9</b></dt>
  <dd>SPARC v9 64-bit</dd>
  <dt><b>EM_IA_64</b></dt>
  <dd>Intel Itanium</dd>
  <dt><b>EM_X86_64</b></dt>
  <dd>AMD x86-64</dd>
  <dt><b>EM_VAX</b></dt>
  <dd>DEC Vax</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>e_version</i></dt>
  <dd>This member identifies the file version:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>EV_NONE</b></dt>
  <dd>Invalid version</dd>
  <dt><b>EV_CURRENT</b></dt>
  <dd>Current version</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>e_entry</i></dt>
  <dd>This member gives the virtual address to which the system first transfers
      control, thus starting the process. If the file has no associated entry
      point, this member holds zero.</dd>
  <dt><i>e_phoff</i></dt>
  <dd>This member holds the program header table's file offset in bytes. If the
      file has no program header table, this member holds zero.</dd>
  <dt><i>e_shoff</i></dt>
  <dd>This member holds the section header table's file offset in bytes. If the
      file has no section header table, this member holds zero.</dd>
  <dt><i>e_flags</i></dt>
  <dd>This member holds processor-specific flags associated with the file. Flag
      names take the form EF_`machine_flag'. Currently, no flags have been
      defined.</dd>
  <dt><i>e_ehsize</i></dt>
  <dd>This member holds the ELF header's size in bytes.</dd>
  <dt><i>e_phentsize</i></dt>
  <dd>This member holds the size in bytes of one entry in the file's program
      header table; all entries are the same size.</dd>
  <dt><i>e_phnum</i></dt>
  <dd>This member holds the number of entries in the program header table. Thus
      the product of <i>e_phentsize</i> and <i>e_phnum</i> gives the table's
      size in bytes. If a file has no program header, <i>e_phnum</i> holds the
      value zero.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If the number of entries in the program header table is larger than or
      equal to <b>PN_XNUM</b> (0xffff), this member holds <b>PN_XNUM</b>
      (0xffff) and the real number of entries in the program header table is
      held in the <i>sh_info</i> member of the initial entry in section header
      table. Otherwise, the <i>sh_info</i> member of the initial entry contains
      the value zero.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>PN_XNUM</b></dt>
  <dd>This is defined as 0xffff, the largest number <i>e_phnum</i> can have,
      specifying where the actual number of program headers is assigned.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>e_shentsize</i></dt>
  <dd>This member holds a sections header's size in bytes. A section header is
      one entry in the section header table; all entries are the same size.</dd>
  <dt><i>e_shnum</i></dt>
  <dd>This member holds the number of entries in the section header table. Thus
      the product of <i>e_shentsize</i> and <i>e_shnum</i> gives the section
      header table's size in bytes. If a file has no section header table,
      <i>e_shnum</i> holds the value of zero.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If the number of entries in the section header table is larger than or
      equal to <b>SHN_LORESERVE</b> (0xff00), <i>e_shnum</i> holds the value
      zero and the real number of entries in the section header table is held in
      the <i>sh_size</i> member of the initial entry in section header table.
      Otherwise, the <i>sh_size</i> member of the initial entry in the section
      header table holds the value zero.</dd>
</dl>
<dl class="Bl-tag">
  <dt><i>e_shstrndx</i></dt>
  <dd>This member holds the section header table index of the entry associated
      with the section name string table. If the file has no section name string
      table, this member holds the value <b>SHN_UNDEF</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If the index of section name string table section is larger than or equal
      to <b>SHN_LORESERVE</b> (0xff00), this member holds <b>SHN_XINDEX</b>
      (0xffff) and the real index of the section name string table section is
      held in the <i>sh_link</i> member of the initial entry in section header
      table. Otherwise, the <i>sh_link</i> member of the initial entry in
      section header table contains the value zero.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Program_header_(Phdr)"><a class="permalink" href="#Program_header_(Phdr)">Program
  header (Phdr)</a></h2>
An executable or shared object file's program header table is an array of
  structures, each describing a segment or other information the system needs to
  prepare the program for execution. An object file <i>segment</i> contains one
  or more <i>sections</i>. Program headers are meaningful only for executable
  and shared object files. A file specifies its own program header size with the
  ELF header's <i>e_phentsize</i> and <i>e_phnum</i> members. The ELF program
  header is described by the type <i>Elf32_Phdr</i> or <i>Elf64_Phdr</i>
  depending on the architecture:
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    uint32_t   p_type;
    Elf32_Off  p_offset;
    Elf32_Addr p_vaddr;
    Elf32_Addr p_paddr;
    uint32_t   p_filesz;
    uint32_t   p_memsz;
    uint32_t   p_flags;
    uint32_t   p_align;
} Elf32_Phdr;

</pre>
<br/>
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    uint32_t   p_type;
    uint32_t   p_flags;
    Elf64_Off  p_offset;
    Elf64_Addr p_vaddr;
    Elf64_Addr p_paddr;
    uint64_t   p_filesz;
    uint64_t   p_memsz;
    uint64_t   p_align;
} Elf64_Phdr;

</pre>
<br/>
<p class="Pp">The main difference between the 32-bit and the 64-bit program
    header lies in the location of the <i>p_flags</i> member in the total
    struct.</p>
<dl class="Bl-tag">
  <dt><i>p_type</i></dt>
  <dd>This member of the structure indicates what kind of segment this array
      element describes or how to interpret the array element's
    information.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>PT_NULL</b></dt>
  <dd>The array element is unused and the other members' values are undefined.
      This lets the program header have ignored entries.</dd>
  <dt><b>PT_LOAD</b></dt>
  <dd>The array element specifies a loadable segment, described by
      <i>p_filesz</i> and <i>p_memsz</i>. The bytes from the file are mapped to
      the beginning of the memory segment. If the segment's memory size
      <i>p_memsz</i> is larger than the file size <i>p_filesz</i>, the
      &quot;extra&quot; bytes are defined to hold the value 0 and to follow the
      segment's initialized area. The file size may not be larger than the
      memory size. Loadable segment entries in the program header table appear
      in ascending order, sorted on the <i>p_vaddr</i> member.</dd>
  <dt><b>PT_DYNAMIC</b></dt>
  <dd>The array element specifies dynamic linking information.</dd>
  <dt><b>PT_INTERP</b></dt>
  <dd>The array element specifies the location and size of a null-terminated
      pathname to invoke as an interpreter. This segment type is meaningful only
      for executable files (though it may occur for shared objects). However it
      may not occur more than once in a file. If it is present, it must precede
      any loadable segment entry.</dd>
  <dt><b>PT_NOTE</b></dt>
  <dd>The array element specifies the location of notes (ElfN_Nhdr).</dd>
  <dt><b>PT_SHLIB</b></dt>
  <dd>This segment type is reserved but has unspecified semantics. Programs that
      contain an array element of this type do not conform to the ABI.</dd>
  <dt><b>PT_PHDR</b></dt>
  <dd>The array element, if present, specifies the location and size of the
      program header table itself, both in the file and in the memory image of
      the program. This segment type may not occur more than once in a file.
      Moreover, it may occur only if the program header table is part of the
      memory image of the program. If it is present, it must precede any
      loadable segment entry.</dd>
  <dt><b>PT_LOPROC</b>, <b>PT_HIPROC</b></dt>
  <dd>Values in the inclusive range [<b>PT_LOPROC</b>, <b>PT_HIPROC</b>] are
      reserved for processor-specific semantics.</dd>
  <dt><b>PT_GNU_STACK</b></dt>
  <dd>GNU extension which is used by the Linux kernel to control the state of
      the stack via the flags set in the <i>p_flags</i> member.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>p_offset</i></dt>
  <dd>This member holds the offset from the beginning of the file at which the
      first byte of the segment resides.</dd>
  <dt><i>p_vaddr</i></dt>
  <dd>This member holds the virtual address at which the first byte of the
      segment resides in memory.</dd>
  <dt><i>p_paddr</i></dt>
  <dd>On systems for which physical addressing is relevant, this member is
      reserved for the segment's physical address. Under BSD this member is not
      used and must be zero.</dd>
  <dt><i>p_filesz</i></dt>
  <dd>This member holds the number of bytes in the file image of the segment. It
      may be zero.</dd>
  <dt><i>p_memsz</i></dt>
  <dd>This member holds the number of bytes in the memory image of the segment.
      It may be zero.</dd>
  <dt><i>p_flags</i></dt>
  <dd>This member holds a bit mask of flags relevant to the segment:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>PF_X</b></dt>
  <dd>An executable segment.</dd>
  <dt><b>PF_W</b></dt>
  <dd>A writable segment.</dd>
  <dt><b>PF_R</b></dt>
  <dd>A readable segment.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>A text segment commonly has the flags <b>PF_X</b> and <b>PF_R</b>. A data
      segment commonly has <b>PF_W</b> and <b>PF_R</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt><i>p_align</i></dt>
  <dd>This member holds the value to which the segments are aligned in memory
      and in the file. Loadable process segments must have congruent values for
      <i>p_vaddr</i> and <i>p_offset</i>, modulo the page size. Values of zero
      and one mean no alignment is required. Otherwise, <i>p_align</i> should be
      a positive, integral power of two, and <i>p_vaddr</i> should equal
      <i>p_offset</i>, modulo <i>p_align</i>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Section_header_(Shdr)"><a class="permalink" href="#Section_header_(Shdr)">Section
  header (Shdr)</a></h2>
A file's section header table lets one locate all the file's sections. The
  section header table is an array of <i>Elf32_Shdr</i> or <i>Elf64_Shdr</i>
  structures. The ELF header's <i>e_shoff</i> member gives the byte offset from
  the beginning of the file to the section header table. <i>e_shnum</i> holds
  the number of entries the section header table contains. <i>e_shentsize</i>
  holds the size in bytes of each entry.
<p class="Pp">A section header table index is a subscript into this array. Some
    section header table indices are reserved: the initial entry and the indices
    between <b>SHN_LORESERVE</b> and <b>SHN_HIRESERVE</b>. The initial entry is
    used in ELF extensions for <i>e_phnum</i>, <i>e_shnum</i> and
    <i>e_shstrndx</i>; in other cases, each field in the initial entry is set to
    zero. An object file does not have sections for these special indices:</p>
<dl class="Bl-tag">
  <dt><b>SHN_UNDEF</b></dt>
  <dd>This value marks an undefined, missing, irrelevant, or otherwise
      meaningless section reference.</dd>
  <dt><b>SHN_LORESERVE</b></dt>
  <dd>This value specifies the lower bound of the range of reserved
    indices.</dd>
  <dt><b>SHN_LOPROC</b>, <b>SHN_HIPROC</b></dt>
  <dd>Values greater in the inclusive range [<b>SHN_LOPROC</b>,
      <b>SHN_HIPROC</b>] are reserved for processor-specific semantics.</dd>
  <dt><b>SHN_ABS</b></dt>
  <dd>This value specifies the absolute value for the corresponding reference.
      For example, a symbol defined relative to section number <b>SHN_ABS</b>
      has an absolute value and is not affected by relocation.</dd>
  <dt><b>SHN_COMMON</b></dt>
  <dd>Symbols defined relative to this section are common symbols, such as
      FORTRAN COMMON or unallocated C external variables.</dd>
  <dt><b>SHN_HIRESERVE</b></dt>
  <dd>This value specifies the upper bound of the range of reserved indices. The
      system reserves indices between <b>SHN_LORESERVE</b> and
      <b>SHN_HIRESERVE</b>, inclusive. The section header table does not contain
      entries for the reserved indices.</dd>
</dl>
<p class="Pp">The section header has the following structure:</p>
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    uint32_t   sh_name;
    uint32_t   sh_type;
    uint32_t   sh_flags;
    Elf32_Addr sh_addr;
    Elf32_Off  sh_offset;
    uint32_t   sh_size;
    uint32_t   sh_link;
    uint32_t   sh_info;
    uint32_t   sh_addralign;
    uint32_t   sh_entsize;
} Elf32_Shdr;

</pre>
<br/>
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    uint32_t   sh_name;
    uint32_t   sh_type;
    uint64_t   sh_flags;
    Elf64_Addr sh_addr;
    Elf64_Off  sh_offset;
    uint64_t   sh_size;
    uint32_t   sh_link;
    uint32_t   sh_info;
    uint64_t   sh_addralign;
    uint64_t   sh_entsize;
} Elf64_Shdr;

</pre>
<br/>
<p class="Pp">No real differences exist between the 32-bit and 64-bit section
    headers.</p>
<dl class="Bl-tag">
  <dt><i>sh_name</i></dt>
  <dd>This member specifies the name of the section. Its value is an index into
      the section header string table section, giving the location of a
      null-terminated string.</dd>
  <dt><i>sh_type</i></dt>
  <dd>This member categorizes the section's contents and semantics.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>SHT_NULL</b></dt>
  <dd>This value marks the section header as inactive. It does not have an
      associated section. Other members of the section header have undefined
      values.</dd>
  <dt><b>SHT_PROGBITS</b></dt>
  <dd>This section holds information defined by the program, whose format and
      meaning are determined solely by the program.</dd>
  <dt><b>SHT_SYMTAB</b></dt>
  <dd>This section holds a symbol table. Typically, <b>SHT_SYMTAB</b> provides
      symbols for link editing, though it may also be used for dynamic linking.
      As a complete symbol table, it may contain many symbols unnecessary for
      dynamic linking. An object file can also contain a <b>SHT_DYNSYM</b>
      section.</dd>
  <dt><b>SHT_STRTAB</b></dt>
  <dd>This section holds a string table. An object file may have multiple string
      table sections.</dd>
  <dt><b>SHT_RELA</b></dt>
  <dd>This section holds relocation entries with explicit addends, such as type
      <i>Elf32_Rela</i> for the 32-bit class of object files. An object may have
      multiple relocation sections.</dd>
  <dt><b>SHT_HASH</b></dt>
  <dd>This section holds a symbol hash table. An object participating in dynamic
      linking must contain a symbol hash table. An object file may have only one
      hash table.</dd>
  <dt><b>SHT_DYNAMIC</b></dt>
  <dd>This section holds information for dynamic linking. An object file may
      have only one dynamic section.</dd>
  <dt><b>SHT_NOTE</b></dt>
  <dd>This section holds notes (ElfN_Nhdr).</dd>
  <dt><b>SHT_NOBITS</b></dt>
  <dd>A section of this type occupies no space in the file but otherwise
      resembles <b>SHT_PROGBITS</b>. Although this section contains no bytes,
      the <i>sh_offset</i> member contains the conceptual file offset.</dd>
  <dt><b>SHT_REL</b></dt>
  <dd>This section holds relocation offsets without explicit addends, such as
      type <i>Elf32_Rel</i> for the 32-bit class of object files. An object file
      may have multiple relocation sections.</dd>
  <dt><b>SHT_SHLIB</b></dt>
  <dd>This section is reserved but has unspecified semantics.</dd>
  <dt><b>SHT_DYNSYM</b></dt>
  <dd>This section holds a minimal set of dynamic linking symbols. An object
      file can also contain a <b>SHT_SYMTAB</b> section.</dd>
  <dt><b>SHT_LOPROC</b>, <b>SHT_HIPROC</b></dt>
  <dd>Values in the inclusive range [<b>SHT_LOPROC</b>, <b>SHT_HIPROC</b>] are
      reserved for processor-specific semantics.</dd>
  <dt><b>SHT_LOUSER</b></dt>
  <dd>This value specifies the lower bound of the range of indices reserved for
      application programs.</dd>
  <dt><b>SHT_HIUSER</b></dt>
  <dd>This value specifies the upper bound of the range of indices reserved for
      application programs. Section types between <b>SHT_LOUSER</b> and
      <b>SHT_HIUSER</b> may be used by the application, without conflicting with
      current or future system-defined section types.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>sh_flags</i></dt>
  <dd>Sections support one-bit flags that describe miscellaneous attributes. If
      a flag bit is set in <i>sh_flags</i>, the attribute is &quot;on&quot; for
      the section. Otherwise, the attribute is &quot;off&quot; or does not
      apply. Undefined attributes are set to zero.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>SHF_WRITE</b></dt>
  <dd>This section contains data that should be writable during process
      execution.</dd>
  <dt><b>SHF_ALLOC</b></dt>
  <dd>This section occupies memory during process execution. Some control
      sections do not reside in the memory image of an object file. This
      attribute is off for those sections.</dd>
  <dt><b>SHF_EXECINSTR</b></dt>
  <dd>This section contains executable machine instructions.</dd>
  <dt><b>SHF_MASKPROC</b></dt>
  <dd>All bits included in this mask are reserved for processor-specific
      semantics.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>sh_addr</i></dt>
  <dd>If this section appears in the memory image of a process, this member
      holds the address at which the section's first byte should reside.
      Otherwise, the member contains zero.</dd>
  <dt><i>sh_offset</i></dt>
  <dd>This member's value holds the byte offset from the beginning of the file
      to the first byte in the section. One section type, <b>SHT_NOBITS</b>,
      occupies no space in the file, and its <i>sh_offset</i> member locates the
      conceptual placement in the file.</dd>
  <dt><i>sh_size</i></dt>
  <dd>This member holds the section's size in bytes. Unless the section type is
      <b>SHT_NOBITS</b>, the section occupies <i>sh_size</i> bytes in the file.
      A section of type <b>SHT_NOBITS</b> may have a nonzero size, but it
      occupies no space in the file.</dd>
  <dt><i>sh_link</i></dt>
  <dd>This member holds a section header table index link, whose interpretation
      depends on the section type.</dd>
  <dt><i>sh_info</i></dt>
  <dd>This member holds extra information, whose interpretation depends on the
      section type.</dd>
  <dt><i>sh_addralign</i></dt>
  <dd>Some sections have address alignment constraints. If a section holds a
      doubleword, the system must ensure doubleword alignment for the entire
      section. That is, the value of <i>sh_addr</i> must be congruent to zero,
      modulo the value of <i>sh_addralign</i>. Only zero and positive integral
      powers of two are allowed. The value 0 or 1 means that the section has no
      alignment constraints.</dd>
  <dt><i>sh_entsize</i></dt>
  <dd>Some sections hold a table of fixed-sized entries, such as a symbol table.
      For such a section, this member gives the size in bytes for each entry.
      This member contains zero if the section does not hold a table of
      fixed-size entries.</dd>
</dl>
<p class="Pp">Various sections hold program and control information:</p>
<dl class="Bl-tag">
  <dt><i>.bss</i></dt>
  <dd>This section holds uninitialized data that contributes to the program's
      memory image. By definition, the system initializes the data with zeros
      when the program begins to run. This section is of type <b>SHT_NOBITS</b>.
      The attribute types are <b>SHF_ALLOC</b> and <b>SHF_WRITE</b>.</dd>
  <dt><i>.comment</i></dt>
  <dd>This section holds version control information. This section is of type
      <b>SHT_PROGBITS</b>. No attribute types are used.</dd>
  <dt><i>.ctors</i></dt>
  <dd>This section holds initialized pointers to the C++ constructor functions.
      This section is of type <b>SHT_PROGBITS</b>. The attribute types are
      <b>SHF_ALLOC</b> and <b>SHF_WRITE</b>.</dd>
  <dt><i>.data</i></dt>
  <dd>This section holds initialized data that contribute to the program's
      memory image. This section is of type <b>SHT_PROGBITS</b>. The attribute
      types are <b>SHF_ALLOC</b> and <b>SHF_WRITE</b>.</dd>
  <dt><i>.data1</i></dt>
  <dd>This section holds initialized data that contribute to the program's
      memory image. This section is of type <b>SHT_PROGBITS</b>. The attribute
      types are <b>SHF_ALLOC</b> and <b>SHF_WRITE</b>.</dd>
  <dt><i>.debug</i></dt>
  <dd>This section holds information for symbolic debugging. The contents are
      unspecified. This section is of type <b>SHT_PROGBITS</b>. No attribute
      types are used.</dd>
  <dt><i>.dtors</i></dt>
  <dd>This section holds initialized pointers to the C++ destructor functions.
      This section is of type <b>SHT_PROGBITS</b>. The attribute types are
      <b>SHF_ALLOC</b> and <b>SHF_WRITE</b>.</dd>
  <dt><i>.dynamic</i></dt>
  <dd>This section holds dynamic linking information. The section's attributes
      will include the <b>SHF_ALLOC</b> bit. Whether the <b>SHF_WRITE</b> bit is
      set is processor-specific. This section is of type <b>SHT_DYNAMIC</b>. See
      the attributes above.</dd>
  <dt><i>.dynstr</i></dt>
  <dd>This section holds strings needed for dynamic linking, most commonly the
      strings that represent the names associated with symbol table entries.
      This section is of type <b>SHT_STRTAB</b>. The attribute type used is
      <b>SHF_ALLOC</b>.</dd>
  <dt><i>.dynsym</i></dt>
  <dd>This section holds the dynamic linking symbol table. This section is of
      type <b>SHT_DYNSYM</b>. The attribute used is <b>SHF_ALLOC</b>.</dd>
  <dt><i>.fini</i></dt>
  <dd>This section holds executable instructions that contribute to the process
      termination code. When a program exits normally the system arranges to
      execute the code in this section. This section is of type
      <b>SHT_PROGBITS</b>. The attributes used are <b>SHF_ALLOC</b> and
      <b>SHF_EXECINSTR</b>.</dd>
  <dt><i>.gnu.version</i></dt>
  <dd>This section holds the version symbol table, an array of <i>ElfN_Half</i>
      elements. This section is of type <b>SHT_GNU_versym</b>. The attribute
      type used is <b>SHF_ALLOC</b>.</dd>
  <dt><i>.gnu.version_d</i></dt>
  <dd>This section holds the version symbol definitions, a table of
      <i>ElfN_Verdef</i> structures. This section is of type
      <b>SHT_GNU_verdef</b>. The attribute type used is <b>SHF_ALLOC</b>.</dd>
  <dt><i>.gnu.version_r</i></dt>
  <dd>This section holds the version symbol needed elements, a table of
      <i>ElfN_Verneed</i> structures. This section is of type
      <b>SHT_GNU_versym</b>. The attribute type used is <b>SHF_ALLOC</b>.</dd>
  <dt><i>.got</i></dt>
  <dd>This section holds the global offset table. This section is of type
      <b>SHT_PROGBITS</b>. The attributes are processor-specific.</dd>
  <dt><i>.hash</i></dt>
  <dd>This section holds a symbol hash table. This section is of type
      <b>SHT_HASH</b>. The attribute used is <b>SHF_ALLOC</b>.</dd>
  <dt><i>.init</i></dt>
  <dd>This section holds executable instructions that contribute to the process
      initialization code. When a program starts to run the system arranges to
      execute the code in this section before calling the main program entry
      point. This section is of type <b>SHT_PROGBITS</b>. The attributes used
      are <b>SHF_ALLOC</b> and <b>SHF_EXECINSTR</b>.</dd>
  <dt><i>.interp</i></dt>
  <dd>This section holds the pathname of a program interpreter. If the file has
      a loadable segment that includes the section, the section's attributes
      will include the <b>SHF_ALLOC</b> bit. Otherwise, that bit will be off.
      This section is of type <b>SHT_PROGBITS</b>.</dd>
  <dt><i>.line</i></dt>
  <dd>This section holds line number information for symbolic debugging, which
      describes the correspondence between the program source and the machine
      code. The contents are unspecified. This section is of type
      <b>SHT_PROGBITS</b>. No attribute types are used.</dd>
  <dt><i>.note</i></dt>
  <dd>This section holds various notes. This section is of type <b>SHT_NOTE</b>.
      No attribute types are used.</dd>
  <dt><i>.note.ABI-tag</i></dt>
  <dd>This section is used to declare the expected run-time ABI of the ELF
      image. It may include the operating system name and its run-time versions.
      This section is of type <b>SHT_NOTE</b>. The only attribute used is
      <b>SHF_ALLOC</b>.</dd>
  <dt><i>.note.gnu.build-id</i></dt>
  <dd>This section is used to hold an ID that uniquely identifies the contents
      of the ELF image. Different files with the same build ID should contain
      the same executable content. See the <b>--build-id</b> option to the GNU
      linker (<b>ld</b> (1)) for more details. This section is of type
      <b>SHT_NOTE</b>. The only attribute used is <b>SHF_ALLOC</b>.</dd>
  <dt><i>.note.GNU-stack</i></dt>
  <dd>This section is used in Linux object files for declaring stack attributes.
      This section is of type <b>SHT_PROGBITS</b>. The only attribute used is
      <b>SHF_EXECINSTR</b>. This indicates to the GNU linker that the object
      file requires an executable stack.</dd>
  <dt><i>.note.openbsd.ident</i></dt>
  <dd>OpenBSD native executables usually contain this section to identify
      themselves so the kernel can bypass any compatibility ELF binary emulation
      tests when loading the file.</dd>
  <dt><i>.plt</i></dt>
  <dd>This section holds the procedure linkage table. This section is of type
      <b>SHT_PROGBITS</b>. The attributes are processor-specific.</dd>
  <dt><i>.relNAME</i></dt>
  <dd>This section holds relocation information as described below. If the file
      has a loadable segment that includes relocation, the section's attributes
      will include the <b>SHF_ALLOC</b> bit. Otherwise, the bit will be off. By
      convention, &quot;NAME&quot; is supplied by the section to which the
      relocations apply. Thus a relocation section for <b>.text</b> normally
      would have the name <b>.rel.text</b>. This section is of type
      <b>SHT_REL</b>.</dd>
  <dt><i>.relaNAME</i></dt>
  <dd>This section holds relocation information as described below. If the file
      has a loadable segment that includes relocation, the section's attributes
      will include the <b>SHF_ALLOC</b> bit. Otherwise, the bit will be off. By
      convention, &quot;NAME&quot; is supplied by the section to which the
      relocations apply. Thus a relocation section for <b>.text</b> normally
      would have the name <b>.rela.text</b>. This section is of type
      <b>SHT_RELA</b>.</dd>
  <dt><i>.rodata</i></dt>
  <dd>This section holds read-only data that typically contributes to a
      nonwritable segment in the process image. This section is of type
      <b>SHT_PROGBITS</b>. The attribute used is <b>SHF_ALLOC</b>.</dd>
  <dt><i>.rodata1</i></dt>
  <dd>This section holds read-only data that typically contributes to a
      nonwritable segment in the process image. This section is of type
      <b>SHT_PROGBITS</b>. The attribute used is <b>SHF_ALLOC</b>.</dd>
  <dt><i>.shstrtab</i></dt>
  <dd>This section holds section names. This section is of type
      <b>SHT_STRTAB</b>. No attribute types are used.</dd>
  <dt><i>.strtab</i></dt>
  <dd>This section holds strings, most commonly the strings that represent the
      names associated with symbol table entries. If the file has a loadable
      segment that includes the symbol string table, the section's attributes
      will include the <b>SHF_ALLOC</b> bit. Otherwise, the bit will be off.
      This section is of type <b>SHT_STRTAB</b>.</dd>
  <dt><i>.symtab</i></dt>
  <dd>This section holds a symbol table. If the file has a loadable segment that
      includes the symbol table, the section's attributes will include the
      <b>SHF_ALLOC</b> bit. Otherwise, the bit will be off. This section is of
      type <b>SHT_SYMTAB</b>.</dd>
  <dt><i>.text</i></dt>
  <dd>This section holds the &quot;text&quot;, or executable instructions, of a
      program. This section is of type <b>SHT_PROGBITS</b>. The attributes used
      are <b>SHF_ALLOC</b> and <b>SHF_EXECINSTR</b>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="String_and_symbol_tables"><a class="permalink" href="#String_and_symbol_tables">String
  and symbol tables</a></h2>
String table sections hold null-terminated character sequences, commonly called
  strings. The object file uses these strings to represent symbol and section
  names. One references a string as an index into the string table section. The
  first byte, which is index zero, is defined to hold a null byte ('\0').
  Similarly, a string table's last byte is defined to hold a null byte, ensuring
  null termination for all strings.
<p class="Pp">An object file's symbol table holds information needed to locate
    and relocate a program's symbolic definitions and references. A symbol table
    index is a subscript into this array.</p>
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    uint32_t      st_name;
    Elf32_Addr    st_value;
    uint32_t      st_size;
    unsigned char st_info;
    unsigned char st_other;
    uint16_t      st_shndx;
} Elf32_Sym;

</pre>
<br/>
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    uint32_t      st_name;
    unsigned char st_info;
    unsigned char st_other;
    uint16_t      st_shndx;
    Elf64_Addr    st_value;
    uint64_t      st_size;
} Elf64_Sym;

</pre>
<br/>
<p class="Pp">The 32-bit and 64-bit versions have the same members, just in a
    different order.</p>
<dl class="Bl-tag">
  <dt><i>st_name</i></dt>
  <dd>This member holds an index into the object file's symbol string table,
      which holds character representations of the symbol names. If the value is
      nonzero, it represents a string table index that gives the symbol name.
      Otherwise, the symbol has no name.</dd>
  <dt><i>st_value</i></dt>
  <dd>This member gives the value of the associated symbol.</dd>
  <dt><i>st_size</i></dt>
  <dd>Many symbols have associated sizes. This member holds zero if the symbol
      has no size or an unknown size.</dd>
  <dt><i>st_info</i></dt>
  <dd>This member specifies the symbol's type and binding attributes:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>STT_NOTYPE</b></dt>
  <dd>The symbol's type is not defined.</dd>
  <dt><b>STT_OBJECT</b></dt>
  <dd>The symbol is associated with a data object.</dd>
  <dt><b>STT_FUNC</b></dt>
  <dd>The symbol is associated with a function or other executable code.</dd>
  <dt><b>STT_SECTION</b></dt>
  <dd>The symbol is associated with a section. Symbol table entries of this type
      exist primarily for relocation and normally have <b>STB_LOCAL</b>
      bindings.</dd>
  <dt><b>STT_FILE</b></dt>
  <dd>By convention, the symbol's name gives the name of the source file
      associated with the object file. A file symbol has <b>STB_LOCAL</b>
      bindings, its section index is <b>SHN_ABS</b>, and it precedes the other
      <b>STB_LOCAL</b> symbols of the file, if it is present.</dd>
  <dt><b>STT_LOPROC</b>, <b>STT_HIPROC</b></dt>
  <dd>Values in the inclusive range [<b>STT_LOPROC</b>, <b>STT_HIPROC</b>] are
      reserved for processor-specific semantics.</dd>
  <dt><b>STB_LOCAL</b></dt>
  <dd>Local symbols are not visible outside the object file containing their
      definition. Local symbols of the same name may exist in multiple files
      without interfering with each other.</dd>
  <dt><b>STB_GLOBAL</b></dt>
  <dd>Global symbols are visible to all object files being combined. One file's
      definition of a global symbol will satisfy another file's undefined
      reference to the same symbol.</dd>
  <dt><b>STB_WEAK</b></dt>
  <dd>Weak symbols resemble global symbols, but their definitions have lower
      precedence.</dd>
  <dt><b>STB_LOPROC</b>, <b>STB_HIPROC</b></dt>
  <dd>Values in the inclusive range [<b>STB_LOPROC</b>, <b>STB_HIPROC</b>] are
      reserved for processor-specific semantics.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>There are macros for packing and unpacking the binding and type
    fields:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>ELF32_ST_BIND(</b><i>info</i><b>)</b>,
    <b>ELF64_ST_BIND(</b><i>info</i><b>)</b></dt>
  <dd>Extract a binding from an <i>st_info</i> value.</dd>
  <dt><b>ELF32_ST_TYPE(</b><i>info</i><b><i>)</i></b><i>,
    </i><b><i>ELF64_ST_TYPE(</i></b><i></i><i>info</i><i></i><b><i>)</i></b></dt>
  <dd>Extract a type from an <i>st_info</i> value.</dd>
  <dt><b>ELF32_ST_INFO(</b><i>bind</i><b>, </b><i>type</i><b>)</b>,
    <b>ELF64_ST_INFO(</b><i>bind</i><b>, </b><i>type</i><b>)</b></dt>
  <dd>Convert a binding and a type into an <i>st_info</i> value.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>st_other</i></dt>
  <dd>This member defines the symbol visibility.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>STV_DEFAULT</b></dt>
  <dd>Default symbol visibility rules. Global and weak symbols are available to
      other modules; references in the local module can be interposed by
      definitions in other modules.</dd>
  <dt><b>STV_INTERNAL</b></dt>
  <dd>Processor-specific hidden class.</dd>
  <dt><b>STV_HIDDEN</b></dt>
  <dd>Symbol is unavailable to other modules; references in the local module
      always resolve to the local symbol (i.e., the symbol can't be interposed
      by definitions in other modules).</dd>
  <dt><b>STV_PROTECTED</b></dt>
  <dd>Symbol is available to other modules, but references in the local module
      always resolve to the local symbol.</dd>
</dl>
<p class="Pp">There are macros for extracting the visibility type:</p>
<p class="Pp"><b>ELF32_ST_VISIBILITY</b>(other) or
    <b>ELF64_ST_VISIBILITY</b>(other)</p>
</div>
<dl class="Bl-tag">
  <dt><i>st_shndx</i></dt>
  <dd>Every symbol table entry is &quot;defined&quot; in relation to some
      section. This member holds the relevant section header table index.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Relocation_entries_(Rel_&amp;_Rela)"><a class="permalink" href="#Relocation_entries_(Rel_&amp;_Rela)">Relocation
  entries (Rel &amp; Rela)</a></h2>
Relocation is the process of connecting symbolic references with symbolic
  definitions. Relocatable files must have information that describes how to
  modify their section contents, thus allowing executable and shared object
  files to hold the right information for a process's program image. Relocation
  entries are these data.
<p class="Pp">Relocation structures that do not need an addend:</p>
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    Elf32_Addr r_offset;
    uint32_t   r_info;
} Elf32_Rel;

</pre>
<br/>
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    Elf64_Addr r_offset;
    uint64_t   r_info;
} Elf64_Rel;

</pre>
<br/>
<p class="Pp">Relocation structures that need an addend:</p>
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    Elf32_Addr r_offset;
    uint32_t   r_info;
    int32_t    r_addend;
} Elf32_Rela;

</pre>
<br/>
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    Elf64_Addr r_offset;
    uint64_t   r_info;
    int64_t    r_addend;
} Elf64_Rela;

</pre>
<br/>
<dl class="Bl-tag">
  <dt><i>r_offset</i></dt>
  <dd>This member gives the location at which to apply the relocation action.
      For a relocatable file, the value is the byte offset from the beginning of
      the section to the storage unit affected by the relocation. For an
      executable file or shared object, the value is the virtual address of the
      storage unit affected by the relocation.</dd>
  <dt><i>r_info</i></dt>
  <dd>This member gives both the symbol table index with respect to which the
      relocation must be made and the type of relocation to apply. Relocation
      types are processor-specific. When the text refers to a relocation entry's
      relocation type or symbol table index, it means the result of applying
      <b>ELF[32|64]_R_TYPE</b> or <b>ELF[32|64]_R_SYM</b>, respectively, to the
      entry's <i>r_info</i> member.</dd>
  <dt><i>r_addend</i></dt>
  <dd>This member specifies a constant addend used to compute the value to be
      stored into the relocatable field.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Dynamic_tags_(Dyn)"><a class="permalink" href="#Dynamic_tags_(Dyn)">Dynamic
  tags (Dyn)</a></h2>
The <i>.dynamic</i> section contains a series of structures that hold relevant
  dynamic linking information. The <i>d_tag</i> member controls the
  interpretation of <i>d_un</i>.
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    Elf32_Sword    d_tag;
    union {
        Elf32_Word d_val;
        Elf32_Addr d_ptr;
    } d_un;
} Elf32_Dyn;
extern Elf32_Dyn _DYNAMIC[];

</pre>
<br/>
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    Elf64_Sxword    d_tag;
    union {
        Elf64_Xword d_val;
        Elf64_Addr  d_ptr;
    } d_un;
} Elf64_Dyn;
extern Elf64_Dyn _DYNAMIC[];

</pre>
<br/>
<dl class="Bl-tag">
  <dt><i>d_tag</i></dt>
  <dd>This member may have any of the following values:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>DT_NULL</b></dt>
  <dd>Marks end of dynamic section</dd>
  <dt><b>DT_NEEDED</b></dt>
  <dd>String table offset to name of a needed library</dd>
  <dt><b>DT_PLTRELSZ</b></dt>
  <dd>Size in bytes of PLT relocation entries</dd>
  <dt><b>DT_PLTGOT</b></dt>
  <dd>Address of PLT and/or GOT</dd>
  <dt><b>DT_HASH</b></dt>
  <dd>Address of symbol hash table</dd>
  <dt><b>DT_STRTAB</b></dt>
  <dd>Address of string table</dd>
  <dt><b>DT_SYMTAB</b></dt>
  <dd>Address of symbol table</dd>
  <dt><b>DT_RELA</b></dt>
  <dd>Address of Rela relocation table</dd>
  <dt><b>DT_RELASZ</b></dt>
  <dd>Size in bytes of the Rela relocation table</dd>
  <dt><b>DT_RELAENT</b></dt>
  <dd>Size in bytes of a Rela relocation table entry</dd>
  <dt><b>DT_STRSZ</b></dt>
  <dd>Size in bytes of string table</dd>
  <dt><b>DT_SYMENT</b></dt>
  <dd>Size in bytes of a symbol table entry</dd>
  <dt><b>DT_INIT</b></dt>
  <dd>Address of the initialization function</dd>
  <dt><b>DT_FINI</b></dt>
  <dd>Address of the termination function</dd>
  <dt><b>DT_SONAME</b></dt>
  <dd>String table offset to name of shared object</dd>
  <dt><b>DT_RPATH</b></dt>
  <dd>String table offset to library search path (deprecated)</dd>
  <dt><b>DT_SYMBOLIC</b></dt>
  <dd>Alert linker to search this shared object before the executable for
      symbols</dd>
  <dt><b>DT_REL</b></dt>
  <dd>Address of Rel relocation table</dd>
  <dt><b>DT_RELSZ</b></dt>
  <dd>Size in bytes of Rel relocation table</dd>
  <dt><b>DT_RELENT</b></dt>
  <dd>Size in bytes of a Rel table entry</dd>
  <dt><b>DT_PLTREL</b></dt>
  <dd>Type of relocation entry to which the PLT refers (Rela or Rel)</dd>
  <dt><b>DT_DEBUG</b></dt>
  <dd>Undefined use for debugging</dd>
  <dt><b>DT_TEXTREL</b></dt>
  <dd>Absence of this entry indicates that no relocation entries should apply to
      a nonwritable segment</dd>
  <dt><b>DT_JMPREL</b></dt>
  <dd>Address of relocation entries associated solely with the PLT</dd>
  <dt><b>DT_BIND_NOW</b></dt>
  <dd>Instruct dynamic linker to process all relocations before transferring
      control to the executable</dd>
  <dt><b>DT_RUNPATH</b></dt>
  <dd>String table offset to library search path</dd>
  <dt><b>DT_LOPROC</b>, <b>DT_HIPROC</b></dt>
  <dd>Values in the inclusive range [<b>DT_LOPROC</b>, <b>DT_HIPROC</b>] are
      reserved for processor-specific semantics</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>d_val</i></dt>
  <dd>This member represents integer values with various interpretations.</dd>
  <dt><i>d_ptr</i></dt>
  <dd>This member represents program virtual addresses. When interpreting these
      addresses, the actual address should be computed based on the original
      file value and memory base address. Files do not contain relocation
      entries to fixup these addresses.</dd>
  <dt><i>_DYNAMIC</i></dt>
  <dd>Array containing all the dynamic structures in the <i>.dynamic</i>
      section. This is automatically populated by the linker.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Notes_(Nhdr)"><a class="permalink" href="#Notes_(Nhdr)">Notes
  (Nhdr)</a></h2>
ELF notes allow for appending arbitrary information for the system to use. They
  are largely used by core files (<i>e_type</i> of <b>ET_CORE</b>), but many
  projects define their own set of extensions. For example, the GNU tool chain
  uses ELF notes to pass information from the linker to the C library.
<p class="Pp">Note sections contain a series of notes (see the <i>struct</i>
    definitions below). Each note is followed by the name field (whose length is
    defined in <i>n_namesz</i>) and then by the descriptor field (whose length
    is defined in <i>n_descsz</i>) and whose starting address has a 4 byte
    alignment. Neither field is defined in the note struct due to their
    arbitrary lengths.</p>
<p class="Pp">An example for parsing out two consecutive notes should clarify
    their layout in memory:</p>
<p class="Pp">
  <br/>
</p>
<pre>
void *memory, *name, *desc;
Elf64_Nhdr *note, *next_note;
/* The buffer is pointing to the start of the section/segment */
note = memory;
/* If the name is defined, it follows the note */
name = note-&gt;n_namesz == 0 ? NULL : memory + sizeof(*note);
/* If the descriptor is defined, it follows the name
   (with alignment) */
desc = note-&gt;n_descsz == 0 ? NULL :
       memory + sizeof(*note) + ALIGN_UP(note-&gt;n_namesz, 4);
/* The next note follows both (with alignment) */
next_note = memory + sizeof(*note) +
                     ALIGN_UP(note-&gt;n_namesz, 4) +
                     ALIGN_UP(note-&gt;n_descsz, 4);

</pre>
<br/>
<p class="Pp">Keep in mind that the interpretation of <i>n_type</i> depends on
    the namespace defined by the <i>n_namesz</i> field. If the <i>n_namesz</i>
    field is not set (e.g., is 0), then there are two sets of notes: one for
    core files and one for all other ELF types. If the namespace is unknown,
    then tools will usually fallback to these sets of notes as well.</p>
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    Elf32_Word n_namesz;
    Elf32_Word n_descsz;
    Elf32_Word n_type;
} Elf32_Nhdr;

</pre>
<br/>
<p class="Pp">
  <br/>
</p>
<pre>
typedef struct {
    Elf64_Word n_namesz;
    Elf64_Word n_descsz;
    Elf64_Word n_type;
} Elf64_Nhdr;

</pre>
<br/>
<dl class="Bl-tag">
  <dt><i>n_namesz</i></dt>
  <dd>The length of the name field in bytes. The contents will immediately
      follow this note in memory. The name is null terminated. For example, if
      the name is &quot;GNU&quot;, then <i>n_namesz</i> will be set to 4.</dd>
  <dt><i>n_descsz</i></dt>
  <dd>The length of the descriptor field in bytes. The contents will immediately
      follow the name field in memory.</dd>
  <dt><i>n_type</i></dt>
  <dd>Depending on the value of the name field, this member may have any of the
      following values:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Core files (e_type = ET_CORE)</b></dt>
  <dd>Notes used by all core files. These are highly operating system or
      architecture specific and often require close coordination with kernels, C
      libraries, and debuggers. These are used when the namespace is the default
      (i.e., <i>n_namesz</i> will be set to 0), or a fallback when the namespace
      is unknown.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>NT_PRSTATUS</b></dt>
  <dd>prstatus struct</dd>
  <dt><b>NT_FPREGSET</b></dt>
  <dd>fpregset struct</dd>
  <dt><b>NT_PRPSINFO</b></dt>
  <dd>prpsinfo struct</dd>
  <dt><b>NT_PRXREG</b></dt>
  <dd>prxregset struct</dd>
  <dt><b>NT_TASKSTRUCT</b></dt>
  <dd>task structure</dd>
  <dt><b>NT_PLATFORM</b></dt>
  <dd>String from sysinfo(SI_PLATFORM)</dd>
  <dt><b>NT_AUXV</b></dt>
  <dd>auxv array</dd>
  <dt><b>NT_GWINDOWS</b></dt>
  <dd>gwindows struct</dd>
  <dt><b>NT_ASRS</b></dt>
  <dd>asrset struct</dd>
  <dt><b>NT_PSTATUS</b></dt>
  <dd>pstatus struct</dd>
  <dt><b>NT_PSINFO</b></dt>
  <dd>psinfo struct</dd>
  <dt><b>NT_PRCRED</b></dt>
  <dd>prcred struct</dd>
  <dt><b>NT_UTSNAME</b></dt>
  <dd>utsname struct</dd>
  <dt><b>NT_LWPSTATUS</b></dt>
  <dd>lwpstatus struct</dd>
  <dt><b>NT_LWPSINFO</b></dt>
  <dd>lwpinfo struct</dd>
  <dt><b>NT_PRFPXREG</b></dt>
  <dd>fprxregset struct</dd>
  <dt><b>NT_SIGINFO</b></dt>
  <dd>siginfo_t (size might increase over time)</dd>
  <dt><b>NT_FILE</b></dt>
  <dd>Contains information about mapped files</dd>
  <dt><b>NT_PRXFPREG</b></dt>
  <dd>user_fxsr_struct</dd>
  <dt><b>NT_PPC_VMX</b></dt>
  <dd>PowerPC Altivec/VMX registers</dd>
  <dt><b>NT_PPC_SPE</b></dt>
  <dd>PowerPC SPE/EVR registers</dd>
  <dt><b>NT_PPC_VSX</b></dt>
  <dd>PowerPC VSX registers</dd>
  <dt><b>NT_386_TLS</b></dt>
  <dd>i386 TLS slots (struct user_desc)</dd>
  <dt><b>NT_386_IOPERM</b></dt>
  <dd>x86 io permission bitmap (1=deny)</dd>
  <dt><b>NT_X86_XSTATE</b></dt>
  <dd>x86 extended state using xsave</dd>
  <dt><b>NT_S390_HIGH_GPRS</b></dt>
  <dd>s390 upper register halves</dd>
  <dt><b>NT_S390_TIMER</b></dt>
  <dd>s390 timer register</dd>
  <dt><b>NT_S390_TODCMP</b></dt>
  <dd>s390 time-of-day (TOD) clock comparator register</dd>
  <dt><b>NT_S390_TODPREG</b></dt>
  <dd>s390 time-of-day (TOD) programmable register</dd>
  <dt><b>NT_S390_CTRS</b></dt>
  <dd>s390 control registers</dd>
  <dt><b>NT_S390_PREFIX</b></dt>
  <dd>s390 prefix register</dd>
  <dt><b>NT_S390_LAST_BREAK</b></dt>
  <dd>s390 breaking event address</dd>
  <dt><b>NT_S390_SYSTEM_CALL</b></dt>
  <dd>s390 system call restart data</dd>
  <dt><b>NT_S390_TDB</b></dt>
  <dd>s390 transaction diagnostic block</dd>
  <dt><b>NT_ARM_VFP</b></dt>
  <dd>ARM VFP/NEON registers</dd>
  <dt><b>NT_ARM_TLS</b></dt>
  <dd>ARM TLS register</dd>
  <dt><b>NT_ARM_HW_BREAK</b></dt>
  <dd>ARM hardware breakpoint registers</dd>
  <dt><b>NT_ARM_HW_WATCH</b></dt>
  <dd>ARM hardware watchpoint registers</dd>
  <dt><b>NT_ARM_SYSTEM_CALL</b></dt>
  <dd>ARM system call number</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>n_name = GNU</b></dt>
  <dd>Extensions used by the GNU tool chain.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>NT_GNU_ABI_TAG</b></dt>
  <dd>Operating system (OS) ABI information. The desc field will be 4
    words:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>word 0: OS descriptor (<b>ELF_NOTE_OS_LINUX</b>, <b>ELF_NOTE_OS_GNU</b>,
      and so on)`</li>
  <li>word 1: major version of the ABI</li>
  <li>word 2: minor version of the ABI</li>
  <li>word 3: subminor version of the ABI</li>
</ul>
</div>
<dl class="Bl-tag">
  <dt><b>NT_GNU_HWCAP</b></dt>
  <dd>Synthetic hwcap information. The desc field begins with two words:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>word 0: number of entries</li>
  <li>word 1: bit mask of enabled entries</li>
</ul>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Then follow variable-length entries, one byte followed by a
      null-terminated hwcap name string. The byte gives the bit number to test
      if enabled, (1U &lt;&lt; bit) &amp; bit mask.</dd>
</dl>
<dl class="Bl-tag">
  <dt><b>NT_GNU_BUILD_ID</b></dt>
  <dd>Unique build ID as generated by the GNU <b>ld</b>(1) <b>--build-id</b>
      option. The desc consists of any nonzero number of bytes.</dd>
  <dt><b>NT_GNU_GOLD_VERSION</b></dt>
  <dd>The desc contains the GNU Gold linker version used.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>Default/unknown namespace (e_type != ET_CORE)</b></dt>
  <dd>These are used when the namespace is the default (i.e., <i>n_namesz</i>
      will be set to 0), or a fallback when the namespace is unknown.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>NT_VERSION</b></dt>
  <dd>A version string of some sort.</dd>
  <dt><b>NT_ARCH</b></dt>
  <dd>Architecture information.</dd>
</dl>
</div>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
ELF first appeared in System V. The ELF format is an adopted standard.
<p class="Pp">The extensions for <i>e_phnum</i>, <i>e_shnum</i> and
    <i>e_shstrndx</i> respectively are Linux extensions. Sun, BSD and AMD64 also
    support them; for further information, look under SEE ALSO.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>as</b>(1), <b>elfedit</b>(1), <b>gdb</b>(1), <b>ld</b>(1), <b>nm</b>(1),
  <b>objdump</b>(1), <b>patchelf</b>(1), <b>readelf</b>(1), <b>size</b>(1),
  <b>strings</b>(1), <b>strip</b>(1), <b>execve</b>(2),
  <b>dl_iterate_phdr</b>(3), <b>core</b>(5), <b>ld.so</b>(8)
<p class="Pp">Hewlett-Packard, <i>Elf-64 Object File Format</i>.</p>
<p class="Pp">Santa Cruz Operation, <i>System V Application Binary
    Interface</i>.</p>
<p class="Pp">UNIX System Laboratories, &quot;Object Files&quot;, <i>Executable
    and Linking Format (ELF)</i>.</p>
<p class="Pp">Sun Microsystems, <i>Linker and Libraries Guide</i>.</p>
<p class="Pp">AMD64 ABI Draft, <i>System V Application Binary Interface AMD64
    Architecture Processor Supplement</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COLOPHON"><a class="permalink" href="#COLOPHON">COLOPHON</a></h1>
This page is part of release 5.05 of the Linux <i>man-pages</i> project. A
  description of the project, information about reporting bugs, and the latest
  version of this page, can be found at https://www.kernel.org/doc/man-pages/.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-05-09</td>
    <td class="foot-os">Linux</td>
  </tr>
</table>

	</div>
	<div class=footer>
		<p>Copyright 2020 Scott Court</p>
	</div>
	</div>
</body>
