
<!DOCTYPE HTML>
<head>
	<title>/usr/share/man/man7/bpf-helpers.7</title>		<link rel='stylesheet' href='/mandoc.css' />
	<link rel='stylesheet' href='/style.css' />
</head>
<body>
	<div class=contents>
	<div class=header>
	<h1>The Fidelix Linux Distribution</h1>
	<h2>Simple, Stable, and Secure</h2>
	</div>
<div class=menubar>
	<ul>
		<li><a href=/>News</a></li>
		<li><a href=/about.html>About</a></li>
		<div class=dropdown>
			<li><a href=/download>Download</a></li>
			<ul class=dropdown-content>
				<li><a href=/download/>Latest Downloads</a></li>
				<li><a href=/download/all.html>All Downloads</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Documentation</a></li>
			<ul class=dropdown-content>
				<li><a href=/handbook/>Handbook</a></li>
				<li><a href=/man/>Manual Pages</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Development</a></li>
			<ul class=dropdown-content>
				<li><a href=https://github.com/Z5T1/fidelix>GitHub</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Community</a></li>
			<ul class=dropdown-content>
				<li><a href=https://discord.com/invite/Yz8DeUr>Discord</a></li>
			</ul>
		</div>
	</ul>
</div>


	<div class=body><table class="head">
  <tr>
    <td class="head-ltitle">BPF-HELPERS(7)</td>
    <td class="head-vol">Linux Programmer's Manual</td>
    <td class="head-rtitle">BPF-HELPERS(7)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
BPF-HELPERS - list of eBPF helper functions
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The extended Berkeley Packet Filter (eBPF) subsystem consists in programs
  written in a pseudo-assembly language, then attached to one of the several
  kernel hooks and run in reaction of specific events. This framework differs
  from the older, &quot;classic&quot; BPF (or &quot;cBPF&quot;) in several
  aspects, one of them being the ability to call special functions (or
  &quot;helpers&quot;) from within a program. These functions are restricted to
  a white-list of helpers defined in the kernel.
<p class="Pp">These helpers are used by eBPF programs to interact with the
    system, or with the context in which they work. For instance, they can be
    used to print debugging messages, to get the time since the system was
    booted, to interact with eBPF maps, or to manipulate network packets. Since
    there are several eBPF program types, and that they do not run in the same
    context, each program type can only call a subset of those helpers.</p>
<p class="Pp">Due to eBPF conventions, a helper can not have more than five
    arguments.</p>
<p class="Pp">Internally, eBPF programs call directly into the compiled helper
    functions without requiring any foreign-function interface. As a result,
    calling helpers introduces no overhead, thus offering excellent
  performance.</p>
<p class="Pp">This document is an attempt to list and document the helpers
    available to eBPF developers. They are sorted by chronological order (the
    oldest helpers in the kernel at the top).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HELPERS"><a class="permalink" href="#HELPERS">HELPERS</a></h1>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>void *bpf_map_lookup_elem(struct bpf_map *</b><i>map</i><b>, const
    void *</b><i>key</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Perform a lookup in <i>map</i> for an entry associated to <i>key</i>.</dd>
  <dt><b>Return</b></dt>
  <dd>Map value associated to <i>key</i>, or <b>NULL</b> if no entry was
    found.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_map_update_elem(struct bpf_map *</b><i>map</i><b>, const
    void *</b><i>key</i><b>, const void *</b><i>value</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Add or update the value of the entry associated to <i>key</i> in
      <i>map</i> with <i>value</i>. <i>flags</i> is one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>BPF_NOEXIST</b></b></dt>
  <dd>The entry for <i>key</i> must not exist in the map.</dd>
  <dt><b><b>BPF_EXIST</b></b></dt>
  <dd>The entry for <i>key</i> must already exist in the map.</dd>
  <dt><b><b>BPF_ANY</b></b></dt>
  <dd>No condition on the existence of the entry for <i>key</i>.</dd>
</dl>
</div>
<br/>
<p class="Pp">Flag value <b>BPF_NOEXIST</b> cannot be used for maps of types
    <b>BPF_MAP_TYPE_ARRAY</b> or <b>BPF_MAP_TYPE_PERCPU_ARRAY</b> (all elements
    always exist), the helper would return an error.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_map_delete_elem(struct bpf_map *</b><i>map</i><b>, const
    void *</b><i>key</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Delete entry with <i>key</i> from <i>map</i>.</dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_probe_read(void *</b><i>dst</i><b>, u32</b> <i>size</i><b>,
    const void *</b><i>src</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>For tracing programs, safely attempt to read <i>size</i> bytes from
      address <i>src</i> and store the data in <i>dst</i>.</dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u64 bpf_ktime_get_ns(void)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Return the time elapsed since system boot, in nanoseconds.</dd>
  <dt><b>Return</b></dt>
  <dd>Current <i>ktime</i>.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_trace_printk(const char *</b><i>fmt</i><b>, u32</b>
    <i>fmt_size</i><b>, ...)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>This helper is a &quot;printk()-like&quot; facility for debugging. It
      prints a message defined by format <i>fmt</i> (of size <i>fmt_size</i>) to
      file <i>/sys/kernel/debug/tracing/trace</i> from DebugFS, if available. It
      can take up to three additional <b>u64</b> arguments (as an eBPF helpers,
      the total number of arguments is limited to five).
    <p class="Pp">Each time the helper is called, it appends a line to the
        trace. Lines are discarded while <i>/sys/kernel/debug/tracing/trace</i>
        is open, use <i>/sys/kernel/debug/tracing/trace_pipe</i> to avoid this.
        The format of the trace is customizable, and the exact output one will
        get depends on the options set in
        <i>/sys/kernel/debug/tracing/trace_options</i> (see also the
        <i>README</i> file under the same directory). However, it usually
        defaults to something like:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>
telnet-470   [001] .N.. 419421.045894: 0x00000001: &lt;formatted msg&gt;
<i></i>
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">In the above:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><b>telnet</b> is the name of the current task.</li>
  <li><b>470</b> is the PID of the current task.</li>
  <li><b>001</b> is the CPU number on which the task is running.</li>
  <li>In <b>.N..</b>, each character refers to a set of options (whether irqs
      are enabled, scheduling options, whether hard/softirqs are running, level
      of preempt_disabled respectively). <b>N</b> means that
      <b>TIF_NEED_RESCHED</b> and <b>PREEMPT_NEED_RESCHED</b> are set.</li>
  <li><b>419421.045894</b> is a timestamp.</li>
  <li><b>0x00000001</b> is a fake value used by BPF for the instruction pointer
      register.</li>
  <li><b>&lt;formatted msg&gt;</b> is the message formatted with
    <i>fmt</i>.</li>
</ul>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<p class="Pp">The conversion specifiers supported by <i>fmt</i> are similar, but
    more limited than for printk(). They are <b>%d</b>, <b>%i</b>, <b>%u</b>,
    <b>%x</b>, <b>%ld</b>, <b>%li</b>, <b>%lu</b>, <b>%lx</b>, <b>%lld</b>,
    <b>%lli</b>, <b>%llu</b>, <b>%llx</b>, <b>%p</b>, <b>%s</b>. No modifier
    (size of field, padding with zeroes, etc.) is available, and the helper will
    return <b>-EINVAL</b> (but print nothing) if it encounters an unknown
    specifier.</p>
<p class="Pp">Also, note that <b>bpf_trace_printk</b>() is slow, and should only
    be used for debugging purposes. For this reason, a notice bloc (spanning
    several lines) is printed to kernel logs and states that the helper should
    not be used &quot;for production use&quot; the first time this helper is
    used (or more precisely, when <b>trace_printk</b>() buffers are allocated).
    For passing values to user space, perf events should be preferred.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>The number of bytes written to the buffer, or a negative error in case of
      failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u32 bpf_get_prandom_u32(void)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Get a pseudo-random number.
    <p class="Pp">From a security point of view, this helper uses its own
        pseudo-random internal state, and cannot be used to infer the seed of
        other random functions in the kernel. However, it is essential to note
        that the generator used by the helper is not cryptographically
      secure.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>A random 32-bit unsigned value.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u32 bpf_get_smp_processor_id(void)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Get the SMP (symmetric multiprocessing) processor id. Note that all
      programs run with preemption disabled, which means that the SMP processor
      id is stable during all the execution of the program.</dd>
  <dt><b>Return</b></dt>
  <dd>The SMP id of the processor running the program.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_store_bytes(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>offset</i><b>, const void *</b><i>from</i><b>, u32</b> <i>len</i><b>,
    u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Store <i>len</i> bytes from address <i>from</i> into the packet associated
      to <i>skb</i>, at <i>offset</i>. <i>flags</i> are a combination of
      <b>BPF_F_RECOMPUTE_CSUM</b> (automatically recompute the checksum for the
      packet after storing the bytes) and <b>BPF_F_INVALIDATE_HASH</b> (set
      <i>skb</i><b>-&gt;hash</b>, <i>skb</i><b>-&gt;swhash</b> and
      <i>skb</i><b>-&gt;l4hash</b> to 0).
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_l3_csum_replace(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>offset</i><b>, u64</b> <i>from</i><b>, u64</b> <i>to</i><b>, u64</b>
    <i>size</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Recompute the layer 3 (e.g. IP) checksum for the packet associated to
      <i>skb</i>. Computation is incremental, so the helper must know the former
      value of the header field that was modified (<i>from</i>), the new value
      of this field (<i>to</i>), and the number of bytes (2 or 4) for this
      field, stored in <i>size</i>. Alternatively, it is possible to store the
      difference between the previous and the new values of the header field in
      <i>to</i>, by setting <i>from</i> and <i>size</i> to 0. For both methods,
      <i>offset</i> indicates the location of the IP checksum within the packet.
    <p class="Pp">This helper works in combination with <b>bpf_csum_diff</b>(),
        which does not update the checksum in-place, but offers more flexibility
        and can handle sizes larger than 2 or 4 for the checksum to update.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_l4_csum_replace(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>offset</i><b>, u64</b> <i>from</i><b>, u64</b> <i>to</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Recompute the layer 4 (e.g. TCP, UDP or ICMP) checksum for the packet
      associated to <i>skb</i>. Computation is incremental, so the helper must
      know the former value of the header field that was modified (<i>from</i>),
      the new value of this field (<i>to</i>), and the number of bytes (2 or 4)
      for this field, stored on the lowest four bits of <i>flags</i>.
      Alternatively, it is possible to store the difference between the previous
      and the new values of the header field in <i>to</i>, by setting
      <i>from</i> and the four lowest bits of <i>flags</i> to 0. For both
      methods, <i>offset</i> indicates the location of the IP checksum within
      the packet. In addition to the size of the field, <i>flags</i> can be
      added (bitwise OR) actual flags. With <b>BPF_F_MARK_MANGLED_0</b>, a null
      checksum is left untouched (unless <b>BPF_F_MARK_ENFORCE</b> is added as
      well), and for updates resulting in a null checksum the value is set to
      <b>CSUM_MANGLED_0</b> instead. Flag <b>BPF_F_PSEUDO_HDR</b> indicates the
      checksum is to be computed against a pseudo-header.
    <p class="Pp">This helper works in combination with <b>bpf_csum_diff</b>(),
        which does not update the checksum in-place, but offers more flexibility
        and can handle sizes larger than 2 or 4 for the checksum to update.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_tail_call(void *</b><i>ctx</i><b>, struct bpf_map
    *</b><i>prog_array_map</i><b>, u32</b> <i>index</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>This special helper is used to trigger a &quot;tail call&quot;, or in
      other words, to jump into another eBPF program. The same stack frame is
      used (but values on stack and in registers for the caller are not
      accessible to the callee). This mechanism allows for program chaining,
      either for raising the maximum number of available eBPF instructions, or
      to execute given programs in conditional blocks. For security reasons,
      there is an upper limit to the number of successive tail calls that can be
      performed.
    <p class="Pp">Upon call of this helper, the program attempts to jump into a
        program referenced at index <i>index</i> in <i>prog_array_map</i>, a
        special map of type <b>BPF_MAP_TYPE_PROG_ARRAY</b>, and passes
        <i>ctx</i>, a pointer to the context.</p>
    <p class="Pp">If the call succeeds, the kernel immediately runs the first
        instruction of the new program. This is not a function call, and it
        never returns to the previous program. If the call fails, then the
        helper has no effect, and the caller continues to run its subsequent
        instructions. A call can fail if the destination program for the jump
        does not exist (i.e. <i>index</i> is superior to the number of entries
        in <i>prog_array_map</i>), or if the maximum number of tail calls has
        been reached for this chain of programs. This limit is defined in the
        kernel by the macro <b>MAX_TAIL_CALL_CNT</b> (not accessible to user
        space), which is currently set to 32.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_clone_redirect(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>ifindex</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Clone and redirect the packet associated to <i>skb</i> to another net
      device of index <i>ifindex</i>. Both ingress and egress interfaces can be
      used for redirection. The <b>BPF_F_INGRESS</b> value in <i>flags</i> is
      used to make the distinction (ingress path is selected if the flag is
      present, egress path otherwise). This is the only flag supported for now.
    <p class="Pp">In comparison with <b>bpf_redirect</b>() helper,
        <b>bpf_clone_redirect</b>() has the associated cost of duplicating the
        packet buffer, but this can be executed out of the eBPF program.
        Conversely, <b>bpf_redirect</b>() is more efficient, but it is handled
        through an action code where the redirection happens only after the eBPF
        program has returned.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u64 bpf_get_current_pid_tgid(void)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>A 64-bit integer containing the current tgid and pid, and created as such:
      <i>current_task</i><b>-&gt;tgid &lt;&lt; 32 |</b>
      <i>current_task</i><b>-&gt;pid</b>.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u64 bpf_get_current_uid_gid(void)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>A 64-bit integer containing the current GID and UID, and created as such:
      <i>current_gid</i> <b>&lt;&lt; 32 |</b> <i>current_uid</i>.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_get_current_comm(char *</b><i>buf</i><b>, u32</b>
    <i>size_of_buf</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Copy the <b>comm</b> attribute of the current task into <i>buf</i> of
      <i>size_of_buf</i>. The <b>comm</b> attribute contains the name of the
      executable (excluding the path) for the current task. The
      <i>size_of_buf</i> must be strictly positive. On success, the helper makes
      sure that the <i>buf</i> is NUL-terminated. On failure, it is filled with
      zeroes.</dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u32 bpf_get_cgroup_classid(struct sk_buff
    *</b><i>skb</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Retrieve the classid for the current task, i.e. for the net_cls cgroup to
      which <i>skb</i> belongs.
    <p class="Pp">This helper can be used on TC egress path, but not on
      ingress.</p>
    <p class="Pp">The net_cls cgroup provides an interface to tag network
        packets based on a user-provided identifier for all traffic coming from
        the tasks belonging to the related cgroup. See also the related kernel
        documentation, available from the Linux sources in file
        <i>Documentation/admin-guide/cgroup-v1/net_cls.rst</i>.</p>
    <p class="Pp">The Linux kernel has two versions for cgroups: there are
        cgroups v1 and cgroups v2. Both are available to users, who can use a
        mixture of them, but note that the net_cls cgroup is for cgroup v1 only.
        This makes it incompatible with BPF programs run on cgroups, which is a
        cgroup-v2-only feature (a socket can only hold data for one version of
        cgroups at a time).</p>
    <p class="Pp">This helper is only available is the kernel was compiled with
        the <b>CONFIG_CGROUP_NET_CLASSID</b> configuration option set to
        &quot;<b>y</b>&quot; or to &quot;<b>m</b>&quot;.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>The classid, or 0 for the default unconfigured classid.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_vlan_push(struct sk_buff *</b><i>skb</i><b>, __be16</b>
    <i>vlan_proto</i><b>, u16</b> <i>vlan_tci</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Push a <i>vlan_tci</i> (VLAN tag control information) of protocol
      <i>vlan_proto</i> to the packet associated to <i>skb</i>, then update the
      checksum. Note that if <i>vlan_proto</i> is different from
      <b>ETH_P_8021Q</b> and <b>ETH_P_8021AD</b>, it is considered to be
      <b>ETH_P_8021Q</b>.
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_vlan_pop(struct sk_buff *</b><i>skb</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Pop a VLAN header from the packet associated to <i>skb</i>.
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_get_tunnel_key(struct sk_buff *</b><i>skb</i><b>, struct
    bpf_tunnel_key *</b><i>key</i><b>, u32</b> <i>size</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Get tunnel metadata. This helper takes a pointer <i>key</i> to an empty
      <b>struct bpf_tunnel_key</b> of <b>size</b>, that will be filled with
      tunnel metadata for the packet associated to <i>skb</i>. The <i>flags</i>
      can be set to <b>BPF_F_TUNINFO_IPV6</b>, which indicates that the tunnel
      is based on IPv6 protocol instead of IPv4.
    <p class="Pp">The <b>struct bpf_tunnel_key</b> is an object that generalizes
        the principal parameters used by various tunneling protocols into a
        single struct. This way, it can be used to easily make a decision based
        on the contents of the encapsulation header, &quot;summarized&quot; in
        this struct. In particular, it holds the IP address of the remote end
        (IPv4 or IPv6, depending on the case) in
        <i>key</i><b>-&gt;remote_ipv4</b> or <i>key</i><b>-&gt;remote_ipv6</b>.
        Also, this struct exposes the <i>key</i><b>-&gt;tunnel_id</b>, which is
        generally mapped to a VNI (Virtual Network Identifier), making it
        programmable together with the <b>bpf_skb_set_tunnel_key</b>()
      helper.</p>
    <p class="Pp">Let's imagine that the following code is part of a program
        attached to the TC ingress interface, on one end of a GRE tunnel, and is
        supposed to filter out all messages coming from remote ends with IPv4
        address other than 10.0.0.1:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>
int ret;
struct bpf_tunnel_key key = {};
ret = bpf_skb_get_tunnel_key(skb, &amp;key, sizeof(key), 0);
if (ret &lt; 0)
        return TC_ACT_SHOT;     // drop packet
if (key.remote_ipv4 != 0x0a000001)
        return TC_ACT_SHOT;     // drop packet
return TC_ACT_OK;               // accept packet
<b></b>
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">This interface can also be used with all encapsulation devices
    that can operate in &quot;collect metadata&quot; mode: instead of having one
    network device per specific configuration, the &quot;collect metadata&quot;
    mode only requires a single device where the configuration can be extracted
    from this helper.</p>
<p class="Pp">This can be used together with various tunnels such as VXLan,
    Geneve, GRE or IP in IP (IPIP).</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_set_tunnel_key(struct sk_buff *</b><i>skb</i><b>, struct
    bpf_tunnel_key *</b><i>key</i><b>, u32</b> <i>size</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Populate tunnel metadata for packet associated to <i>skb.</i> The tunnel
      metadata is set to the contents of <i>key</i>, of <i>size</i>. The
      <i>flags</i> can be set to a combination of the following values:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>BPF_F_TUNINFO_IPV6</b></b></dt>
  <dd>Indicate that the tunnel is based on IPv6 protocol instead of IPv4.</dd>
  <dt><b><b>BPF_F_ZERO_CSUM_TX</b></b></dt>
  <dd>For IPv4 packets, add a flag to tunnel metadata indicating that checksum
      computation should be skipped and checksum set to zeroes.</dd>
  <dt><b><b>BPF_F_DONT_FRAGMENT</b></b></dt>
  <dd>Add a flag to tunnel metadata indicating that the packet should not be
      fragmented.</dd>
  <dt><b><b>BPF_F_SEQ_NUMBER</b></b></dt>
  <dd>Add a flag to tunnel metadata indicating that a sequence number should be
      added to tunnel header before sending the packet. This flag was added for
      GRE encapsulation, but might be used with other protocols as well in the
      future.</dd>
</dl>
</div>
<br/>
<p class="Pp">Here is a typical usage on the transmit path:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>
struct bpf_tunnel_key key;
     populate key ...
bpf_skb_set_tunnel_key(skb, &amp;key, sizeof(key), 0);
bpf_clone_redirect(skb, vxlan_dev_ifindex, 0);
<b></b>
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">See also the description of the <b>bpf_skb_get_tunnel_key</b>()
    helper for additional information.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u64 bpf_perf_event_read(struct bpf_map *</b><i>map</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Read the value of a perf event counter. This helper relies on a <i>map</i>
      of type <b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. The nature of the perf event
      counter is selected when <i>map</i> is updated with perf event file
      descriptors. The <i>map</i> is an array whose size is the number of
      available CPUs, and each cell contains a value relative to one CPU. The
      value to retrieve is indicated by <i>flags</i>, that contains the index of
      the CPU to look up, masked with <b>BPF_F_INDEX_MASK</b>. Alternatively,
      <i>flags</i> can be set to <b>BPF_F_CURRENT_CPU</b> to indicate that the
      value for the current CPU should be retrieved.
    <p class="Pp">Note that before Linux 4.13, only hardware perf event can be
        retrieved.</p>
    <p class="Pp">Also, be aware that the newer helper
        <b>bpf_perf_event_read_value</b>() is recommended over
        <b>bpf_perf_event_read</b>() in general. The latter has some ABI quirks
        where error and counter value are used as a return code (which is wrong
        to do since ranges may overlap). This issue is fixed with
        <b>bpf_perf_event_read_value</b>(), which at the same time provides more
        features over the <b>bpf_perf_event_read</b>() interface. Please refer
        to the description of <b>bpf_perf_event_read_value</b>() for
      details.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>The value of the perf event counter read from the map, or a negative error
      code in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_redirect(u32</b> <i>ifindex</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Redirect the packet to another net device of index <i>ifindex</i>. This
      helper is somewhat similar to <b>bpf_clone_redirect</b>(), except that the
      packet is not cloned, which provides increased performance.
    <p class="Pp">Except for XDP, both ingress and egress interfaces can be used
        for redirection. The <b>BPF_F_INGRESS</b> value in <i>flags</i> is used
        to make the distinction (ingress path is selected if the flag is
        present, egress path otherwise). Currently, XDP only supports
        redirection to the egress interface, and accepts no flag at all.</p>
    <p class="Pp">The same effect can be attained with the more generic
        <b>bpf_redirect_map</b>(), which requires specific maps to be used but
        offers better performance.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>For XDP, the helper returns <b>XDP_REDIRECT</b> on success or
      <b>XDP_ABORTED</b> on error. For other program types, the values are
      <b>TC_ACT_REDIRECT</b> on success or <b>TC_ACT_SHOT</b> on error.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u32 bpf_get_route_realm(struct sk_buff
    *</b><i>skb</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Retrieve the realm or the route, that is to say the <b>tclassid</b> field
      of the destination for the <i>skb</i>. The indentifier retrieved is a
      user-provided tag, similar to the one used with the net_cls cgroup (see
      description for <b>bpf_get_cgroup_classid</b>() helper), but here this tag
      is held by a route (a destination entry), not by a task.
    <p class="Pp">Retrieving this identifier works with the clsact TC egress
        hook (see also <b>tc-bpf(8)</b>), or alternatively on conventional
        classful egress qdiscs, but not on TC ingress path. In case of clsact TC
        egress hook, this has the advantage that, internally, the destination
        entry has not been dropped yet in the transmit path. Therefore, the
        destination entry does not need to be artificially held via
        <b>netif_keep_dst</b>() for a classful qdisc until the <i>skb</i> is
        freed.</p>
    <p class="Pp">This helper is available only if the kernel was compiled with
        <b>CONFIG_IP_ROUTE_CLASSID</b> configuration option.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>The realm of the route for the packet associated to <i>skb</i>, or 0 if
      none was found.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_perf_event_output(struct pt_regs *</b><i>ctx</i><b>, struct
    bpf_map *</b><i>map</i><b>, u64</b> <i>flags</i><b>, void
    *</b><i>data</i><b>, u64</b> <i>size</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Write raw <i>data</i> blob into a special BPF perf event held by
      <i>map</i> of type <b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. This perf event
      must have the following attributes: <b>PERF_SAMPLE_RAW</b> as
      <b>sample_type</b>, <b>PERF_TYPE_SOFTWARE</b> as <b>type</b>, and
      <b>PERF_COUNT_SW_BPF_OUTPUT</b> as <b>config</b>.
    <p class="Pp">The <i>flags</i> are used to indicate the index in <i>map</i>
        for which the value must be put, masked with <b>BPF_F_INDEX_MASK</b>.
        Alternatively, <i>flags</i> can be set to <b>BPF_F_CURRENT_CPU</b> to
        indicate that the index of the current CPU core should be used.</p>
    <p class="Pp">The value to write, of <i>size</i>, is passed through eBPF
        stack and pointed by <i>data</i>.</p>
    <p class="Pp">The context of the program <i>ctx</i> needs also be passed to
        the helper.</p>
    <p class="Pp">On user space, a program willing to read the values needs to
        call <b>perf_event_open</b>() on the perf event (either for one or for
        all CPUs) and to store the file descriptor into the <i>map</i>. This
        must be done before the eBPF program can send data into it. An example
        is available in file <i>samples/bpf/trace_output_user.c</i> in the Linux
        kernel source tree (the eBPF program counterpart is in
        <i>samples/bpf/trace_output_kern.c</i>).</p>
    <p class="Pp"><b>bpf_perf_event_output</b>() achieves better performance
        than <b>bpf_trace_printk</b>() for sharing data with user space, and is
        much better suitable for streaming data from eBPF programs.</p>
    <p class="Pp">Note that this helper is not restricted to tracing use cases
        and can be used with programs attached to TC or XDP as well, where it
        allows for passing data to user space listeners. Data can be:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Only custom structs,</li>
  <li>Only the packet payload, or</li>
  <li>A combination of both.</li>
</ul>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_load_bytes(const struct sk_buff *</b><i>skb</i><b>,
    u32</b> <i>offset</i><b>, void *</b><i>to</i><b>, u32</b>
    <i>len</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>This helper was provided as an easy way to load data from a packet. It can
      be used to load <i>len</i> bytes from <i>offset</i> from the packet
      associated to <i>skb</i>, into the buffer pointed by <i>to</i>.
    <p class="Pp">Since Linux 4.7, usage of this helper has mostly been replaced
        by &quot;direct packet access&quot;, enabling packet data to be
        manipulated with <i>skb</i><b>-&gt;data</b> and
        <i>skb</i><b>-&gt;data_end</b> pointing respectively to the first byte
        of packet data and to the byte after the last byte of packet data.
        However, it remains useful if one wishes to read large quantities of
        data at once from a packet into the eBPF stack.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_get_stackid(struct pt_regs *</b><i>ctx</i><b>, struct
    bpf_map *</b><i>map</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Walk a user or a kernel stack and return its id. To achieve this, the
      helper needs <i>ctx</i>, which is a pointer to the context on which the
      tracing program is executed, and a pointer to a <i>map</i> of type
      <b>BPF_MAP_TYPE_STACK_TRACE</b>.
    <p class="Pp">The last argument, <i>flags</i>, holds the number of stack
        frames to skip (from 0 to 255), masked with
        <b>BPF_F_SKIP_FIELD_MASK</b>. The next bits can be used to set a
        combination of the following flags:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>BPF_F_USER_STACK</b></b></dt>
  <dd>Collect a user space stack instead of a kernel stack.</dd>
  <dt><b><b>BPF_F_FAST_STACK_CMP</b></b></dt>
  <dd>Compare stacks by hash only.</dd>
  <dt><b><b>BPF_F_REUSE_STACKID</b></b></dt>
  <dd>If two different stacks hash into the same <i>stackid</i>, discard the old
      one.</dd>
</dl>
</div>
<br/>
<p class="Pp">The stack id retrieved is a 32 bit long integer handle which can
    be further combined with other data (including other stack ids) and used as
    a key into maps. This can be useful for generating a variety of graphs (such
    as flame graphs or off-cpu graphs).</p>
<p class="Pp">For walking a stack, this helper is an improvement over
    <b>bpf_probe_read</b>(), which can be used with unrolled loops but is not
    efficient and consumes a lot of eBPF instructions. Instead,
    <b>bpf_get_stackid</b>() can collect up to <b>PERF_MAX_STACK_DEPTH</b> both
    kernel and user frames. Note that this limit can be controlled with the
    <b>sysctl</b> program, and that it should be manually increased in order to
    profile long user stacks (such as stacks for Java programs). To do so,
  use:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>
# sysctl kernel.perf_event_max_stack=&lt;new value&gt;
<b></b>
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>The positive or null stack id on success, or a negative error in case of
      failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>s64 bpf_csum_diff(__be32 *</b><i>from</i><b>, u32</b>
    <i>from_size</i><b>, __be32 *</b><i>to</i><b>, u32</b> <i>to_size</i><b>,
    __wsum</b> <i>seed</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Compute a checksum difference, from the raw buffer pointed by <i>from</i>,
      of length <i>from_size</i> (that must be a multiple of 4), towards the raw
      buffer pointed by <i>to</i>, of size <i>to_size</i> (same remark). An
      optional <i>seed</i> can be added to the value (this can be cascaded, the
      seed may come from a previous call to the helper).
    <p class="Pp">This is flexible enough to be used in several ways:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>With <i>from_size</i> == 0, <i>to_size</i> &gt; 0 and <i>seed</i> set to
      checksum, it can be used when pushing new data.</li>
  <li>With <i>from_size</i> &gt; 0, <i>to_size</i> == 0 and <i>seed</i> set to
      checksum, it can be used when removing data from a packet.</li>
  <li>With <i>from_size</i> &gt; 0, <i>to_size</i> &gt; 0 and <i>seed</i> set to
      0, it can be used to compute a diff. Note that <i>from_size</i> and
      <i>to_size</i> do not need to be equal.</li>
</ul>
</div>
<br/>
<p class="Pp">This helper can be used in combination with
    <b>bpf_l3_csum_replace</b>() and <b>bpf_l4_csum_replace</b>(), to which one
    can feed in the difference computed with <b>bpf_csum_diff</b>().</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>The checksum result, or a negative error code in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_get_tunnel_opt(struct sk_buff *</b><i>skb</i><b>, u8
    *</b><i>opt</i><b>, u32</b> <i>size</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Retrieve tunnel options metadata for the packet associated to <i>skb</i>,
      and store the raw tunnel option data to the buffer <i>opt</i> of
      <i>size</i>.
    <p class="Pp">This helper can be used with encapsulation devices that can
        operate in &quot;collect metadata&quot; mode (please refer to the
        related note in the description of <b>bpf_skb_get_tunnel_key</b>() for
        more details). A particular example where this can be used is in
        combination with the Geneve encapsulation protocol, where it allows for
        pushing (with <b>bpf_skb_get_tunnel_opt</b>() helper) and retrieving
        arbitrary TLVs (Type-Length-Value headers) from the eBPF program. This
        allows for full customization of these headers.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>The size of the option data retrieved.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_set_tunnel_opt(struct sk_buff *</b><i>skb</i><b>, u8
    *</b><i>opt</i><b>, u32</b> <i>size</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Set tunnel options metadata for the packet associated to <i>skb</i> to the
      option data contained in the raw buffer <i>opt</i> of <i>size</i>.
    <p class="Pp">See also the description of the
        <b>bpf_skb_get_tunnel_opt</b>() helper for additional information.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_change_proto(struct sk_buff *</b><i>skb</i><b>,
    __be16</b> <i>proto</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Change the protocol of the <i>skb</i> to <i>proto</i>. Currently supported
      are transition from IPv4 to IPv6, and from IPv6 to IPv4. The helper takes
      care of the groundwork for the transition, including resizing the socket
      buffer. The eBPF program is expected to fill the new headers, if any, via
      <b>skb_store_bytes</b>() and to recompute the checksums with
      <b>bpf_l3_csum_replace</b>() and <b>bpf_l4_csum_replace</b>(). The main
      case for this helper is to perform NAT64 operations out of an eBPF
      program.
    <p class="Pp">Internally, the GSO type is marked as dodgy so that headers
        are checked and segments are recalculated by the GSO/GRO engine. The
        size for GSO target is adapted as well.</p>
    <p class="Pp">All values for <i>flags</i> are reserved for future usage, and
        must be left at zero.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_change_type(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>type</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Change the packet type for the packet associated to <i>skb</i>. This comes
      down to setting <i>skb</i><b>-&gt;pkt_type</b> to <i>type</i>, except the
      eBPF program does not have a write access to
      <i>skb</i><b>-&gt;pkt_type</b> beside this helper. Using a helper here
      allows for graceful handling of errors.
    <p class="Pp">The major use case is to change incoming <i>skb*s to</i>
        <i>**PACKET_HOST*</i> in a programmatic way instead of having to
        recirculate via <b>redirect</b>(..., <b>BPF_F_INGRESS</b>), for
      example.</p>
    <p class="Pp">Note that <i>type</i> only allows certain values. At this
        time, they are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>PACKET_HOST</b></b></dt>
  <dd>Packet is for us.</dd>
  <dt><b><b>PACKET_BROADCAST</b></b></dt>
  <dd>Send packet to all.</dd>
  <dt><b><b>PACKET_MULTICAST</b></b></dt>
  <dd>Send packet to group.</dd>
  <dt><b><b>PACKET_OTHERHOST</b></b></dt>
  <dd>Send packet to someone else.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_under_cgroup(struct sk_buff *</b><i>skb</i><b>, struct
    bpf_map *</b><i>map</i><b>, u32</b> <i>index</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Check whether <i>skb</i> is a descendant of the cgroup2 held by <i>map</i>
      of type <b>BPF_MAP_TYPE_CGROUP_ARRAY</b>, at <i>index</i>.</dd>
  <dt><b>Return</b></dt>
  <dd>The return value depends on the result of the test, and can be:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>0, if the <i>skb</i> failed the cgroup2 descendant test.</li>
  <li>1, if the <i>skb</i> succeeded the cgroup2 descendant test.</li>
  <li>A negative error code, if an error occurred.</li>
</ul>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u32 bpf_get_hash_recalc(struct sk_buff
    *</b><i>skb</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Retrieve the hash of the packet, <i>skb</i><b>-&gt;hash</b>. If it is not
      set, in particular if the hash was cleared due to mangling, recompute this
      hash. Later accesses to the hash can be done directly with
      <i>skb</i><b>-&gt;hash</b>.
    <p class="Pp">Calling <b>bpf_set_hash_invalid</b>(), changing a packet
        prototype with <b>bpf_skb_change_proto</b>(), or calling
        <b>bpf_skb_store_bytes</b>() with the <b>BPF_F_INVALIDATE_HASH</b> are
        actions susceptible to clear the hash and to trigger a new computation
        for the next call to <b>bpf_get_hash_recalc</b>().</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>The 32-bit hash.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u64 bpf_get_current_task(void)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>A pointer to the current task struct.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_probe_write_user(void *</b><i>dst</i><b>, const void
    *</b><i>src</i><b>, u32</b> <i>len</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Attempt in a safe way to write <i>len</i> bytes from the buffer <i>src</i>
      to <i>dst</i> in memory. It only works for threads that are in user
      context, and <i>dst</i> must be a valid user space address.
    <p class="Pp">This helper should not be used to implement any kind of
        security mechanism because of TOC-TOU attacks, but rather to debug,
        divert, and manipulate execution of semi-cooperative processes.</p>
    <p class="Pp">Keep in mind that this feature is meant for experiments, and
        it has a risk of crashing the system and running programs. Therefore,
        when an eBPF program using this helper is attached, a warning including
        PID and process name is printed to kernel logs.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_current_task_under_cgroup(struct bpf_map *</b><i>map</i><b>,
    u32</b> <i>index</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Check whether the probe is being run is the context of a given subset of
      the cgroup2 hierarchy. The cgroup2 to test is held by <i>map</i> of type
      <b>BPF_MAP_TYPE_CGROUP_ARRAY</b>, at <i>index</i>.</dd>
  <dt><b>Return</b></dt>
  <dd>The return value depends on the result of the test, and can be:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>0, if the <i>skb</i> task belongs to the cgroup2.</li>
  <li>1, if the <i>skb</i> task does not belong to the cgroup2.</li>
  <li>A negative error code, if an error occurred.</li>
</ul>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_change_tail(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>len</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Resize (trim or grow) the packet associated to <i>skb</i> to the new
      <i>len</i>. The <i>flags</i> are reserved for future usage, and must be
      left at zero.
    <p class="Pp">The basic idea is that the helper performs the needed work to
        change the size of the packet, then the eBPF program rewrites the rest
        via helpers like <b>bpf_skb_store_bytes</b>(),
        <b>bpf_l3_csum_replace</b>(), <b>bpf_l3_csum_replace</b>() and others.
        This helper is a slow path utility intended for replies with control
        messages. And because it is targeted for slow path, the helper itself
        can afford to be slow: it implicitly linearizes, unclones and drops
        offloads from the <i>skb</i>.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_pull_data(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>len</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Pull in non-linear data in case the <i>skb</i> is non-linear and not all
      of <i>len</i> are part of the linear section. Make <i>len</i> bytes from
      <i>skb</i> readable and writable. If a zero value is passed for
      <i>len</i>, then the whole length of the <i>skb</i> is pulled.
    <p class="Pp">This helper is only needed for reading and writing with direct
        packet access.</p>
    <p class="Pp">For direct packet access, testing that offsets to access are
        within packet boundaries (test on <i>skb</i><b>-&gt;data_end</b>) is
        susceptible to fail if offsets are invalid, or if the requested data is
        in non-linear parts of the <i>skb</i>. On failure the program can just
        bail out, or in the case of a non-linear buffer, use a helper to make
        the data available. The <b>bpf_skb_load_bytes</b>() helper is a first
        solution to access the data. Another one consists in using
        <b>bpf_skb_pull_data</b> to pull in once the non-linear parts, then
        retesting and eventually access the data.</p>
    <p class="Pp">At the same time, this also makes sure the <i>skb</i> is
        uncloned, which is a necessary condition for direct write. As this needs
        to be an invariant for the write part only, the verifier detects writes
        and adds a prologue that is calling <b>bpf_skb_pull_data()</b> to
        effectively unclone the <i>skb</i> from the very beginning in case it is
        indeed cloned.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>s64 bpf_csum_update(struct sk_buff *</b><i>skb</i><b>, __wsum</b>
    <i>csum</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Add the checksum <i>csum</i> into <i>skb</i><b>-&gt;csum</b> in case the
      driver has supplied a checksum for the entire packet into that field.
      Return an error otherwise. This helper is intended to be used in
      combination with <b>bpf_csum_diff</b>(), in particular when the checksum
      needs to be updated after data has been written into the packet through
      direct packet access.</dd>
  <dt><b>Return</b></dt>
  <dd>The checksum on success, or a negative error code in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>void bpf_set_hash_invalid(struct sk_buff
    *</b><i>skb</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Invalidate the current <i>skb</i><b>-&gt;hash</b>. It can be used after
      mangling on headers through direct packet access, in order to indicate
      that the hash is outdated and to trigger a recalculation the next time the
      kernel tries to access this hash or when the <b>bpf_get_hash_recalc</b>()
      helper is called.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_get_numa_node_id(void)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Return the id of the current NUMA node. The primary use case for this
      helper is the selection of sockets for the local NUMA node, when the
      program is attached to sockets using the <b>SO_ATTACH_REUSEPORT_EBPF</b>
      option (see also <b>socket(7)</b>), but the helper is also available to
      other eBPF program types, similarly to
    <b>bpf_get_smp_processor_id</b>().</dd>
  <dt><b>Return</b></dt>
  <dd>The id of current NUMA node.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_change_head(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>len</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Grows headroom of packet associated to <i>skb</i> and adjusts the offset
      of the MAC header accordingly, adding <i>len</i> bytes of space. It
      automatically extends and reallocates memory as required.
    <p class="Pp">This helper can be used on a layer 3 <i>skb</i> to push a MAC
        header for redirection into a layer 2 device.</p>
    <p class="Pp">All values for <i>flags</i> are reserved for future usage, and
        must be left at zero.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_xdp_adjust_head(struct xdp_buff *</b><i>xdp_md</i><b>,
    int</b> <i>delta</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Adjust (move) <i>xdp_md</i><b>-&gt;data</b> by <i>delta</i> bytes. Note
      that it is possible to use a negative value for <i>delta</i>. This helper
      can be used to prepare the packet for pushing or popping headers.
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_probe_read_str(void *</b><i>dst</i><b>, int</b>
    <i>size</i><b>, const void *</b><i>unsafe_ptr</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Copy a NUL terminated string from an unsafe address <i>unsafe_ptr</i> to
      <i>dst</i>. The <i>size</i> should include the terminating NUL byte. In
      case the string length is smaller than <i>size</i>, the target is not
      padded with further NUL bytes. If the string length is larger than
      <i>size</i>, just <i>size</i>-1 bytes are copied and the last byte is set
      to NUL.
    <p class="Pp">On success, the length of the copied string is returned. This
        makes this helper useful in tracing programs for reading strings, and
        more importantly to get its length at runtime. See the following
        snippet:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>
SEC(&quot;kprobe/sys_open&quot;)
void bpf_sys_open(struct pt_regs *ctx)
{
        char buf[PATHLEN]; // PATHLEN is defined to 256
        int res = bpf_probe_read_str(buf, sizeof(buf),
                                     ctx-&gt;di);
        // Consume buf, for example push it to
        // userspace via bpf_perf_event_output(); we
        // can use res (the string length) as event
        // size, after checking its boundaries.
}
<i></i>
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">In comparison, using <b>bpf_probe_read()</b> helper here instead
    to read the string would require to estimate the length at compile time, and
    would often result in copying more memory than necessary.</p>
<p class="Pp">Another useful use case is when parsing individual process
    arguments or individual environment variables navigating
    <i>current</i><b>-&gt;mm-&gt;arg_start</b> and
    <i>current</i><b>-&gt;mm-&gt;env_start</b>: using this helper and the return
    value, one can quickly iterate at the right offset of the memory area.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>On success, the strictly positive length of the string, including the
      trailing NUL character. On error, a negative value.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u64 bpf_get_socket_cookie(struct sk_buff
    *</b><i>skb</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>If the <b>struct sk_buff</b> pointed by <i>skb</i> has a known socket,
      retrieve the cookie (generated by the kernel) of this socket. If no cookie
      has been set yet, generate a new cookie. Once generated, the socket cookie
      remains stable for the life of the socket. This helper can be useful for
      monitoring per socket networking traffic statistics as it provides a
      global socket identifier that can be assumed unique.</dd>
  <dt><b>Return</b></dt>
  <dd>A 8-byte long non-decreasing number on success, or 0 if the socket field
      is missing inside <i>skb</i>.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u64 bpf_get_socket_cookie(struct bpf_sock_addr
    *</b><i>ctx</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Equivalent to bpf_get_socket_cookie() helper that accepts <i>skb</i>, but
      gets socket from <b>struct bpf_sock_addr</b> context.</dd>
  <dt><b>Return</b></dt>
  <dd>A 8-byte long non-decreasing number.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u64 bpf_get_socket_cookie(struct bpf_sock_ops
    *</b><i>ctx</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Equivalent to bpf_get_socket_cookie() helper that accepts <i>skb</i>, but
      gets socket from <b>struct bpf_sock_ops</b> context.</dd>
  <dt><b>Return</b></dt>
  <dd>A 8-byte long non-decreasing number.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u32 bpf_get_socket_uid(struct sk_buff
    *</b><i>skb</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>The owner UID of the socket associated to <i>skb</i>. If the socket is
      <b>NULL</b>, or if it is not a full socket (i.e. if it is a time-wait or a
      request socket instead), <b>overflowuid</b> value is returned (note that
      <b>overflowuid</b> might also be the actual UID value for the
    socket).</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u32 bpf_set_hash(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>hash</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Set the full hash for <i>skb</i> (set the field
      <i>skb</i><b>-&gt;hash</b>) to value <i>hash</i>.</dd>
  <dt><b>Return</b></dt>
  <dd>0</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_setsockopt(struct bpf_sock_ops *</b><i>bpf_socket</i><b>,
    int</b> <i>level</i><b>, int</b> <i>optname</i><b>, char
    *</b><i>optval</i><b>, int</b> <i>optlen</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Emulate a call to <b>setsockopt()</b> on the socket associated to
      <i>bpf_socket</i>, which must be a full socket. The <i>level</i> at which
      the option resides and the name <i>optname</i> of the option must be
      specified, see <b>setsockopt(2)</b> for more information. The option value
      of length <i>optlen</i> is pointed by <i>optval</i>.
    <p class="Pp">This helper actually implements a subset of
        <b>setsockopt()</b>. It supports the following <i>level</i>s:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><b>SOL_SOCKET</b>, which supports the following <i>optname</i>s:
      <b>SO_RCVBUF</b>, <b>SO_SNDBUF</b>, <b>SO_MAX_PACING_RATE</b>,
      <b>SO_PRIORITY</b>, <b>SO_RCVLOWAT</b>, <b>SO_MARK</b>.</li>
  <li><b>IPPROTO_TCP</b>, which supports the following <i>optname</i>s:
      <b>TCP_CONGESTION</b>, <b>TCP_BPF_IW</b>,
    <b>TCP_BPF_SNDCWND_CLAMP</b>.</li>
  <li><b>IPPROTO_IP</b>, which supports <i>optname</i> <b>IP_TOS</b>.</li>
  <li><b>IPPROTO_IPV6</b>, which supports <i>optname</i>
    <b>IPV6_TCLASS</b>.</li>
</ul>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_adjust_room(struct sk_buff *</b><i>skb</i><b>, s32</b>
    <i>len_diff</i><b>, u32</b> <i>mode</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Grow or shrink the room for data in the packet associated to <i>skb</i> by
      <i>len_diff</i>, and according to the selected <i>mode</i>.
    <p class="Pp">There are two supported modes at this time:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><b>BPF_ADJ_ROOM_MAC</b>: Adjust room at the mac layer (room space is added
      or removed below the layer 2 header).</li>
  <li><b>BPF_ADJ_ROOM_NET</b>: Adjust room at the network layer (room space is
      added or removed below the layer 3 header).</li>
</ul>
</div>
<br/>
<p class="Pp">The following flags are supported at this time:</p>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><b>BPF_F_ADJ_ROOM_FIXED_GSO</b>: Do not adjust gso_size. Adjusting mss in
      this way is not allowed for datagrams.</li>
  <li><b>BPF_F_ADJ_ROOM_ENCAP_L3_IPV4</b>, <b>BPF_F_ADJ_ROOM_ENCAP_L3_IPV6</b>:
      Any new space is reserved to hold a tunnel header. Configure skb offsets
      and other fields accordingly.</li>
  <li><b>BPF_F_ADJ_ROOM_ENCAP_L4_GRE</b>, <b>BPF_F_ADJ_ROOM_ENCAP_L4_UDP</b>:
      Use with ENCAP_L3 flags to further specify the tunnel type.</li>
  <li><b>BPF_F_ADJ_ROOM_ENCAP_L2</b>(<i>len</i>): Use with ENCAP_L3/L4 flags to
      further specify the tunnel type; <i>len</i> is the length of the inner MAC
      header.</li>
</ul>
</div>
<br/>
<p class="Pp">A call to this helper is susceptible to change the underlying
    packet buffer. Therefore, at load time, all checks on pointers previously
    done by the verifier are invalidated and must be performed again, if the
    helper is used in combination with direct packet access.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_redirect_map(struct bpf_map *</b><i>map</i><b>, u32</b>
    <i>key</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Redirect the packet to the endpoint referenced by <i>map</i> at index
      <i>key</i>. Depending on its type, this <i>map</i> can contain references
      to net devices (for forwarding packets through other ports), or to CPUs
      (for redirecting XDP frames to another CPU; but this is only implemented
      for native XDP (with driver support) as of this writing).
    <p class="Pp">The lower two bits of <i>flags</i> are used as the return code
        if the map lookup fails. This is so that the return value can be one of
        the XDP program return codes up to XDP_TX, as chosen by the caller. Any
        higher bits in the <i>flags</i> argument must be unset.</p>
    <p class="Pp">When used to redirect packets to net devices, this helper
        provides a high performance increase over <b>bpf_redirect</b>(). This is
        due to various implementation details of the underlying mechanisms, one
        of which is the fact that <b>bpf_redirect_map</b>() tries to send packet
        as a &quot;bulk&quot; to the device.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd><b>XDP_REDIRECT</b> on success, or <b>XDP_ABORTED</b> on error.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_sk_redirect_map(struct bpf_map *</b><i>map</i><b>, u32</b>
    <i>key</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Redirect the packet to the socket referenced by <i>map</i> (of type
      <b>BPF_MAP_TYPE_SOCKMAP</b>) at index <i>key</i>. Both ingress and egress
      interfaces can be used for redirection. The <b>BPF_F_INGRESS</b> value in
      <i>flags</i> is used to make the distinction (ingress path is selected if
      the flag is present, egress path otherwise). This is the only flag
      supported for now.</dd>
  <dt><b>Return</b></dt>
  <dd><b>SK_PASS</b> on success, or <b>SK_DROP</b> on error.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_sock_map_update(struct bpf_sock_ops *</b><i>skops</i><b>,
    struct bpf_map *</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Add an entry to, or update a <i>map</i> referencing sockets. The
      <i>skops</i> is used as a new value for the entry associated to
      <i>key</i>. <i>flags</i> is one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>BPF_NOEXIST</b></b></dt>
  <dd>The entry for <i>key</i> must not exist in the map.</dd>
  <dt><b><b>BPF_EXIST</b></b></dt>
  <dd>The entry for <i>key</i> must already exist in the map.</dd>
  <dt><b><b>BPF_ANY</b></b></dt>
  <dd>No condition on the existence of the entry for <i>key</i>.</dd>
</dl>
</div>
<br/>
<p class="Pp">If the <i>map</i> has eBPF programs (parser and verdict), those
    will be inherited by the socket being added. If the socket is already
    attached to eBPF programs, this results in an error.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_xdp_adjust_meta(struct xdp_buff *</b><i>xdp_md</i><b>,
    int</b> <i>delta</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Adjust the address pointed by <i>xdp_md</i><b>-&gt;data_meta</b> by
      <i>delta</i> (which can be positive or negative). Note that this operation
      modifies the address stored in <i>xdp_md</i><b>-&gt;data</b>, so the
      latter must be loaded only after the helper has been called.
    <p class="Pp">The use of <i>xdp_md</i><b>-&gt;data_meta</b> is optional and
        programs are not required to use it. The rationale is that when the
        packet is processed with XDP (e.g. as DoS filter), it is possible to
        push further meta data along with it before passing to the stack, and to
        give the guarantee that an ingress eBPF program attached as a TC
        classifier on the same device can pick this up for further
        post-processing. Since TC works with socket buffers, it remains possible
        to set from XDP the <b>mark</b> or <b>priority</b> pointers, or other
        pointers for the socket buffer. Having this scratch space generic and
        programmable allows for more flexibility as the user is free to store
        whatever meta data they need.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_perf_event_read_value(struct bpf_map *</b><i>map</i><b>,
    u64</b> <i>flags</i><b>, struct bpf_perf_event_value *</b><i>buf</i><b>,
    u32</b> <i>buf_size</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Read the value of a perf event counter, and store it into <i>buf</i> of
      size <i>buf_size</i>. This helper relies on a <i>map</i> of type
      <b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. The nature of the perf event counter
      is selected when <i>map</i> is updated with perf event file descriptors.
      The <i>map</i> is an array whose size is the number of available CPUs, and
      each cell contains a value relative to one CPU. The value to retrieve is
      indicated by <i>flags</i>, that contains the index of the CPU to look up,
      masked with <b>BPF_F_INDEX_MASK</b>. Alternatively, <i>flags</i> can be
      set to <b>BPF_F_CURRENT_CPU</b> to indicate that the value for the current
      CPU should be retrieved.
    <p class="Pp">This helper behaves in a way close to
        <b>bpf_perf_event_read</b>() helper, save that instead of just returning
        the value observed, it fills the <i>buf</i> structure. This allows for
        additional data to be retrieved: in particular, the enabled and running
        times (in <i>buf</i><b>-&gt;enabled</b> and
        <i>buf</i><b>-&gt;running</b>, respectively) are copied. In general,
        <b>bpf_perf_event_read_value</b>() is recommended over
        <b>bpf_perf_event_read</b>(), which has some ABI issues and provides
        fewer functionalities.</p>
    <p class="Pp">These values are interesting, because hardware PMU
        (Performance Monitoring Unit) counters are limited resources. When there
        are more PMU based perf events opened than available counters, kernel
        will multiplex these events so each event gets certain percentage (but
        not all) of the PMU time. In case that multiplexing happens, the number
        of samples or counter value will not reflect the case compared to when
        no multiplexing occurs. This makes comparison between different runs
        difficult. Typically, the counter value should be normalized before
        comparing to other experiments. The usual normalization is done as
        follows.</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>
normalized_counter = counter * t_enabled / t_running
<b></b>
</pre>
</div>
<br/>
</div>
<br/>
<p class="Pp">Where t_enabled is the time enabled for event and t_running is the
    time running for event since last normalization. The enabled and running
    times are accumulated since the perf event open. To achieve scaling factor
    between two invocations of an eBPF program, users can can use CPU id as the
    key (which is typical for perf array usage model) to remember the previous
    value and do the calculation inside the eBPF program.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_perf_prog_read_value(struct bpf_perf_event_data
    *</b><i>ctx</i><b>, struct bpf_perf_event_value *</b><i>buf</i><b>, u32</b>
    <i>buf_size</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>For en eBPF program attached to a perf event, retrieve the value of the
      event counter associated to <i>ctx</i> and store it in the structure
      pointed by <i>buf</i> and of size <i>buf_size</i>. Enabled and running
      times are also stored in the structure (see description of helper
      <b>bpf_perf_event_read_value</b>() for more details).</dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_getsockopt(struct bpf_sock_ops *</b><i>bpf_socket</i><b>,
    int</b> <i>level</i><b>, int</b> <i>optname</i><b>, char
    *</b><i>optval</i><b>, int</b> <i>optlen</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Emulate a call to <b>getsockopt()</b> on the socket associated to
      <i>bpf_socket</i>, which must be a full socket. The <i>level</i> at which
      the option resides and the name <i>optname</i> of the option must be
      specified, see <b>getsockopt(2)</b> for more information. The retrieved
      value is stored in the structure pointed by <i>opval</i> and of length
      <i>optlen</i>.
    <p class="Pp">This helper actually implements a subset of
        <b>getsockopt()</b>. It supports the following <i>level</i>s:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><b>IPPROTO_TCP</b>, which supports <i>optname</i>
    <b>TCP_CONGESTION</b>.</li>
  <li><b>IPPROTO_IP</b>, which supports <i>optname</i> <b>IP_TOS</b>.</li>
  <li><b>IPPROTO_IPV6</b>, which supports <i>optname</i>
    <b>IPV6_TCLASS</b>.</li>
</ul>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_override_return(struct pt_regs *</b><i>regs</i><b>, u64</b>
    <i>rc</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Used for error injection, this helper uses kprobes to override the return
      value of the probed function, and to set it to <i>rc</i>. The first
      argument is the context <i>regs</i> on which the kprobe works.
    <p class="Pp">This helper works by setting setting the PC (program counter)
        to an override function which is run in place of the original probed
        function. This means the probed function is not run at all. The
        replacement function just returns with the required value.</p>
    <p class="Pp">This helper has security implications, and thus is subject to
        restrictions. It is only available if the kernel was compiled with the
        <b>CONFIG_BPF_KPROBE_OVERRIDE</b> configuration option, and in this case
        it only works on functions tagged with <b>ALLOW_ERROR_INJECTION</b> in
        the kernel code.</p>
    <p class="Pp">Also, the helper is only available for the architectures
        having the CONFIG_FUNCTION_ERROR_INJECTION option. As of this writing,
        x86 architecture is the only one to support this feature.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_sock_ops_cb_flags_set(struct bpf_sock_ops
    *</b><i>bpf_sock</i><b>, int</b> <i>argval</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Attempt to set the value of the <b>bpf_sock_ops_cb_flags</b> field for the
      full TCP socket associated to <i>bpf_sock_ops</i> to <i>argval</i>.
    <p class="Pp">The primary use of this field is to determine if there should
        be calls to eBPF programs of type <b>BPF_PROG_TYPE_SOCK_OPS</b> at
        various points in the TCP code. A program of the same type can change
        its value, per connection and as necessary, when the connection is
        established. This field is directly accessible for reading, but this
        helper must be used for updates in order to return an error if an eBPF
        program tries to set a callback that is not supported in the current
        kernel.</p>
    <p class="Pp"><i>argval</i> is a flag array which can combine these
      flags:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><b>BPF_SOCK_OPS_RTO_CB_FLAG</b> (retransmission time out)</li>
  <li><b>BPF_SOCK_OPS_RETRANS_CB_FLAG</b> (retransmission)</li>
  <li><b>BPF_SOCK_OPS_STATE_CB_FLAG</b> (TCP state change)</li>
  <li><b>BPF_SOCK_OPS_RTT_CB_FLAG</b> (every RTT)</li>
</ul>
</div>
<br/>
<p class="Pp">Therefore, this function can be used to clear a callback flag by
    setting the appropriate bit to zero. e.g. to disable the RTO callback:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>bpf_sock_ops_cb_flags_set(bpf_sock,</b></b></dt>
  <dd><b>bpf_sock-&gt;bpf_sock_ops_cb_flags &amp;
    ~BPF_SOCK_OPS_RTO_CB_FLAG)</b></dd>
</dl>
</div>
<br/>
<p class="Pp">Here are some examples of where one could call such eBPF
  program:</p>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>When RTO fires.</li>
  <li>When a packet is retransmitted.</li>
  <li>When the connection terminates.</li>
  <li>When a packet is sent.</li>
  <li>When a packet is received.</li>
</ul>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>Code <b>-EINVAL</b> if the socket is not a full TCP socket; otherwise, a
      positive number containing the bits that could not be set is returned
      (which comes down to 0 if all bits were set as required).</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_msg_redirect_map(struct sk_msg_buff *</b><i>msg</i><b>,
    struct bpf_map *</b><i>map</i><b>, u32</b> <i>key</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>This helper is used in programs implementing policies at the socket level.
      If the message <i>msg</i> is allowed to pass (i.e. if the verdict eBPF
      program returns <b>SK_PASS</b>), redirect it to the socket referenced by
      <i>map</i> (of type <b>BPF_MAP_TYPE_SOCKMAP</b>) at index <i>key</i>. Both
      ingress and egress interfaces can be used for redirection. The
      <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to make the distinction
      (ingress path is selected if the flag is present, egress path otherwise).
      This is the only flag supported for now.</dd>
  <dt><b>Return</b></dt>
  <dd><b>SK_PASS</b> on success, or <b>SK_DROP</b> on error.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_msg_apply_bytes(struct sk_msg_buff *</b><i>msg</i><b>,
    u32</b> <i>bytes</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>For socket policies, apply the verdict of the eBPF program to the next
      <i>bytes</i> (number of bytes) of message <i>msg</i>.
    <p class="Pp">For example, this helper can be used in the following
      cases:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>A single <b>sendmsg</b>() or <b>sendfile</b>() system call contains
      multiple logical messages that the eBPF program is supposed to read and
      for which it should apply a verdict.</li>
  <li>An eBPF program only cares to read the first <i>bytes</i> of a <i>msg</i>.
      If the message has a large payload, then setting up and calling the eBPF
      program repeatedly for all bytes, even though the verdict is already
      known, would create unnecessary overhead.</li>
</ul>
</div>
<br/>
<p class="Pp">When called from within an eBPF program, the helper sets a counter
    internal to the BPF infrastructure, that is used to apply the last verdict
    to the next <i>bytes</i>. If <i>bytes</i> is smaller than the current data
    being processed from a <b>sendmsg</b>() or <b>sendfile</b>() system call,
    the first <i>bytes</i> will be sent and the eBPF program will be re-run with
    the pointer for start of data pointing to byte number <i>bytes</i> <b>+
    1</b>. If <i>bytes</i> is larger than the current data being processed, then
    the eBPF verdict will be applied to multiple <b>sendmsg</b>() or
    <b>sendfile</b>() calls until <i>bytes</i> are consumed.</p>
<p class="Pp">Note that if a socket closes with the internal counter holding a
    non-zero value, this is not a problem because data is not being buffered for
    <i>bytes</i> and is sent as it is received.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_msg_cork_bytes(struct sk_msg_buff *</b><i>msg</i><b>,
    u32</b> <i>bytes</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>For socket policies, prevent the execution of the verdict eBPF program for
      message <i>msg</i> until <i>bytes</i> (byte number) have been accumulated.
    <p class="Pp">This can be used when one needs a specific number of bytes
        before a verdict can be assigned, even if the data spans multiple
        <b>sendmsg</b>() or <b>sendfile</b>() calls. The extreme case would be a
        user calling <b>sendmsg</b>() repeatedly with 1-byte long message
        segments. Obviously, this is bad for performance, but it is still valid.
        If the eBPF program needs <i>bytes</i> bytes to validate a header, this
        helper can be used to prevent the eBPF program to be called again until
        <i>bytes</i> have been accumulated.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_msg_pull_data(struct sk_msg_buff *</b><i>msg</i><b>, u32</b>
    <i>start</i><b>, u32</b> <i>end</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>For socket policies, pull in non-linear data from user space for
      <i>msg</i> and set pointers <i>msg</i><b>-&gt;data</b> and
      <i>msg</i><b>-&gt;data_end</b> to <i>start</i> and <i>end</i> bytes
      offsets into <i>msg</i>, respectively.
    <p class="Pp">If a program of type <b>BPF_PROG_TYPE_SK_MSG</b> is run on a
        <i>msg</i> it can only parse data that the (<b>data</b>,
        <b>data_end</b>) pointers have already consumed. For <b>sendmsg</b>()
        hooks this is likely the first scatterlist element. But for calls
        relying on the <b>sendpage</b> handler (e.g. <b>sendfile</b>()) this
        will be the range (<b>0</b>, <b>0</b>) because the data is shared with
        user space and by default the objective is to avoid allowing user space
        to modify data while (or after) eBPF verdict is being decided. This
        helper can be used to pull in data and to set the start and end pointer
        to given values. Data will be copied if necessary (i.e. if data was not
        linear and if start and end pointers do not point to the same
      chunk).</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
    <p class="Pp">All values for <i>flags</i> are reserved for future usage, and
        must be left at zero.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_bind(struct bpf_sock_addr *</b><i>ctx</i><b>, struct
    sockaddr *</b><i>addr</i><b>, int</b> <i>addr_len</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Bind the socket associated to <i>ctx</i> to the address pointed by
      <i>addr</i>, of length <i>addr_len</i>. This allows for making outgoing
      connection from the desired IP address, which can be useful for example
      when all processes inside a cgroup should use one single IP address on a
      host that has multiple IP configured.
    <p class="Pp">This helper works for IPv4 and IPv6, TCP and UDP sockets. The
        domain (<i>addr</i><b>-&gt;sa_family</b>) must be <b>AF_INET</b> (or
        <b>AF_INET6</b>). Looking for a free port to bind to can be expensive,
        therefore binding to port is not permitted by the helper:
        <i>addr</i><b>-&gt;sin_port</b> (or <b>sin6_port</b>, respectively) must
        be set to zero.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_xdp_adjust_tail(struct xdp_buff *</b><i>xdp_md</i><b>,
    int</b> <i>delta</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Adjust (move) <i>xdp_md</i><b>-&gt;data_end</b> by <i>delta</i> bytes. It
      is only possible to shrink the packet as of this writing, therefore
      <i>delta</i> must be a negative integer.
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_get_xfrm_state(struct sk_buff *</b><i>skb</i><b>,
    u32</b> <i>index</i><b>, struct bpf_xfrm_state *</b><i>xfrm_state</i><b>,
    u32</b> <i>size</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Retrieve the XFRM state (IP transform framework, see also
      <b>ip-xfrm(8)</b>) at <i>index</i> in XFRM &quot;security path&quot; for
      <i>skb</i>.
    <p class="Pp">The retrieved value is stored in the <b>struct
        bpf_xfrm_state</b> pointed by <i>xfrm_state</i> and of length
        <i>size</i>.</p>
    <p class="Pp">All values for <i>flags</i> are reserved for future usage, and
        must be left at zero.</p>
    <p class="Pp">This helper is available only if the kernel was compiled with
        <b>CONFIG_XFRM</b> configuration option.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_get_stack(struct pt_regs *</b><i>regs</i><b>, void
    *</b><i>buf</i><b>, u32</b> <i>size</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Return a user or a kernel stack in bpf program provided buffer. To achieve
      this, the helper needs <i>ctx</i>, which is a pointer to the context on
      which the tracing program is executed. To store the stacktrace, the bpf
      program provides <i>buf</i> with a nonnegative <i>size</i>.
    <p class="Pp">The last argument, <i>flags</i>, holds the number of stack
        frames to skip (from 0 to 255), masked with
        <b>BPF_F_SKIP_FIELD_MASK</b>. The next bits can be used to set the
        following flags:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>BPF_F_USER_STACK</b></b></dt>
  <dd>Collect a user space stack instead of a kernel stack.</dd>
  <dt><b><b>BPF_F_USER_BUILD_ID</b></b></dt>
  <dd>Collect buildid+offset instead of ips for user stack, only valid if
      <b>BPF_F_USER_STACK</b> is also specified.</dd>
</dl>
</div>
<br/>
<p class="Pp"><b>bpf_get_stack</b>() can collect up to
    <b>PERF_MAX_STACK_DEPTH</b> both kernel and user frames, subject to
    sufficient large buffer size. Note that this limit can be controlled with
    the <b>sysctl</b> program, and that it should be manually increased in order
    to profile long user stacks (such as stacks for Java programs). To do so,
    use:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>
# sysctl kernel.perf_event_max_stack=&lt;new value&gt;
<b></b>
</pre>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>A non-negative value equal to or less than <i>size</i> on success, or a
      negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_load_bytes_relative(const struct sk_buff
    *</b><i>skb</i><b>, u32</b> <i>offset</i><b>, void *</b><i>to</i><b>,
    u32</b> <i>len</i><b>, u32</b> <i>start_header</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>This helper is similar to <b>bpf_skb_load_bytes</b>() in that it provides
      an easy way to load <i>len</i> bytes from <i>offset</i> from the packet
      associated to <i>skb</i>, into the buffer pointed by <i>to</i>. The
      difference to <b>bpf_skb_load_bytes</b>() is that a fifth argument
      <i>start_header</i> exists in order to select a base offset to start from.
      <i>start_header</i> can be one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>BPF_HDR_START_MAC</b></b></dt>
  <dd>Base offset to load data from is <i>skb</i>'s mac header.</dd>
  <dt><b><b>BPF_HDR_START_NET</b></b></dt>
  <dd>Base offset to load data from is <i>skb</i>'s network header.</dd>
</dl>
</div>
<br/>
<p class="Pp">In general, &quot;direct packet access&quot; is the preferred
    method to access packet data, however, this helper is in particular useful
    in socket filters where <i>skb</i><b>-&gt;data</b> does not always point to
    the start of the mac header and where &quot;direct packet access&quot; is
    not available.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_fib_lookup(void *</b><i>ctx</i><b>, struct bpf_fib_lookup
    *</b><i>params</i><b>, int</b> <i>plen</i><b>, u32</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Do FIB lookup in kernel tables using parameters in <i>params</i>. If
      lookup is successful and result shows packet is to be forwarded, the
      neighbor tables are searched for the nexthop. If successful (ie., FIB
      lookup shows forwarding and nexthop is resolved), the nexthop address is
      returned in ipv4_dst or ipv6_dst based on family, smac is set to mac
      address of egress device, dmac is set to nexthop mac address, rt_metric is
      set to metric from route (IPv4/IPv6 only), and ifindex is set to the
      device index of the nexthop from the FIB lookup.
    <p class="Pp"><i>plen</i> argument is the size of the passed in struct.
        <i>flags</i> argument can be a combination of one or more of the
        following values:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>BPF_FIB_LOOKUP_DIRECT</b></b></dt>
  <dd>Do a direct table lookup vs full lookup using FIB rules.</dd>
  <dt><b><b>BPF_FIB_LOOKUP_OUTPUT</b></b></dt>
  <dd>Perform lookup from an egress perspective (default is ingress).</dd>
</dl>
</div>
<br/>
<p class="Pp"><i>ctx</i> is either <b>struct xdp_md</b> for XDP programs or
    <b>struct sk_buff</b> tc cls_act programs.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>&lt; 0 if any input argument is invalid</li>
  <li>0 on success (packet is forwarded, nexthop neighbor exists)</li>
  <li>&gt; 0 one of <b>BPF_FIB_LKUP_RET_</b> codes explaining why the packet is
      not forwarded or needs assist from full stack</li>
</ul>
</div>
<br/>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_sock_hash_update(struct bpf_sock_ops_kern
    *</b><i>skops</i><b>, struct bpf_map *</b><i>map</i><b>, void
    *</b><i>key</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Add an entry to, or update a sockhash <i>map</i> referencing sockets. The
      <i>skops</i> is used as a new value for the entry associated to
      <i>key</i>. <i>flags</i> is one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>BPF_NOEXIST</b></b></dt>
  <dd>The entry for <i>key</i> must not exist in the map.</dd>
  <dt><b><b>BPF_EXIST</b></b></dt>
  <dd>The entry for <i>key</i> must already exist in the map.</dd>
  <dt><b><b>BPF_ANY</b></b></dt>
  <dd>No condition on the existence of the entry for <i>key</i>.</dd>
</dl>
</div>
<br/>
<p class="Pp">If the <i>map</i> has eBPF programs (parser and verdict), those
    will be inherited by the socket being added. If the socket is already
    attached to eBPF programs, this results in an error.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_msg_redirect_hash(struct sk_msg_buff *</b><i>msg</i><b>,
    struct bpf_map *</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>This helper is used in programs implementing policies at the socket level.
      If the message <i>msg</i> is allowed to pass (i.e. if the verdict eBPF
      program returns <b>SK_PASS</b>), redirect it to the socket referenced by
      <i>map</i> (of type <b>BPF_MAP_TYPE_SOCKHASH</b>) using hash <i>key</i>.
      Both ingress and egress interfaces can be used for redirection. The
      <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to make the distinction
      (ingress path is selected if the flag is present, egress path otherwise).
      This is the only flag supported for now.</dd>
  <dt><b>Return</b></dt>
  <dd><b>SK_PASS</b> on success, or <b>SK_DROP</b> on error.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_sk_redirect_hash(struct sk_buff *</b><i>skb</i><b>, struct
    bpf_map *</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>This helper is used in programs implementing policies at the skb socket
      level. If the sk_buff <i>skb</i> is allowed to pass (i.e. if the verdeict
      eBPF program returns <b>SK_PASS</b>), redirect it to the socket referenced
      by <i>map</i> (of type <b>BPF_MAP_TYPE_SOCKHASH</b>) using hash
      <i>key</i>. Both ingress and egress interfaces can be used for
      redirection. The <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to
      make the distinction (ingress path is selected if the flag is present,
      egress otherwise). This is the only flag supported for now.</dd>
  <dt><b>Return</b></dt>
  <dd><b>SK_PASS</b> on success, or <b>SK_DROP</b> on error.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_lwt_push_encap(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>type</i><b>, void *</b><i>hdr</i><b>, u32</b> <i>len</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Encapsulate the packet associated to <i>skb</i> within a Layer 3 protocol
      header. This header is provided in the buffer at address <i>hdr</i>, with
      <i>len</i> its size in bytes. <i>type</i> indicates the protocol of the
      header and can be one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>BPF_LWT_ENCAP_SEG6</b></b></dt>
  <dd>IPv6 encapsulation with Segment Routing Header (<b>struct
      ipv6_sr_hdr</b>). <i>hdr</i> only contains the SRH, the IPv6 header is
      computed by the kernel.</dd>
  <dt><b><b>BPF_LWT_ENCAP_SEG6_INLINE</b></b></dt>
  <dd>Only works if <i>skb</i> contains an IPv6 packet. Insert a Segment Routing
      Header (<b>struct ipv6_sr_hdr</b>) inside the IPv6 header.</dd>
  <dt><b><b>BPF_LWT_ENCAP_IP</b></b></dt>
  <dd>IP encapsulation (GRE/GUE/IPIP/etc). The outer header must be IPv4 or
      IPv6, followed by zero or more additional headers, up to
      <b>LWT_BPF_MAX_HEADROOM</b> total bytes in all prepended headers. Please
      note that if <b>skb_is_gso</b>(<i>skb</i>) is true, no more than two
      headers can be prepended, and the inner header, if present, should be
      either GRE or UDP/GUE.</dd>
</dl>
</div>
<br/>
<p class="Pp"><b>BPF_LWT_ENCAP_SEG6</b>* types can be called by BPF programs of
    type <b>BPF_PROG_TYPE_LWT_IN</b>; <b>BPF_LWT_ENCAP_IP</b> type can be called
    by bpf programs of types <b>BPF_PROG_TYPE_LWT_IN</b> and
    <b>BPF_PROG_TYPE_LWT_XMIT</b>.</p>
<p class="Pp">A call to this helper is susceptible to change the underlying
    packet buffer. Therefore, at load time, all checks on pointers previously
    done by the verifier are invalidated and must be performed again, if the
    helper is used in combination with direct packet access.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_lwt_seg6_store_bytes(struct sk_buff *</b><i>skb</i><b>,
    u32</b> <i>offset</i><b>, const void *</b><i>from</i><b>, u32</b>
    <i>len</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Store <i>len</i> bytes from address <i>from</i> into the packet associated
      to <i>skb</i>, at <i>offset</i>. Only the flags, tag and TLVs inside the
      outermost IPv6 Segment Routing Header can be modified through this helper.
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_lwt_seg6_adjust_srh(struct sk_buff *</b><i>skb</i><b>,
    u32</b> <i>offset</i><b>, s32</b> <i>delta</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Adjust the size allocated to TLVs in the outermost IPv6 Segment Routing
      Header contained in the packet associated to <i>skb</i>, at position
      <i>offset</i> by <i>delta</i> bytes. Only offsets after the segments are
      accepted. <i>delta</i> can be as well positive (growing) as negative
      (shrinking).
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_lwt_seg6_action(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>action</i><b>, void *</b><i>param</i><b>, u32</b>
    <i>param_len</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Apply an IPv6 Segment Routing action of type <i>action</i> to the packet
      associated to <i>skb</i>. Each action takes a parameter contained at
      address <i>param</i>, and of length <i>param_len</i> bytes. <i>action</i>
      can be one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>SEG6_LOCAL_ACTION_END_X</b></b></dt>
  <dd>End.X action: Endpoint with Layer-3 cross-connect. Type of <i>param</i>:
      <b>struct in6_addr</b>.</dd>
  <dt><b><b>SEG6_LOCAL_ACTION_END_T</b></b></dt>
  <dd>End.T action: Endpoint with specific IPv6 table lookup. Type of
      <i>param</i>: <b>int</b>.</dd>
  <dt><b><b>SEG6_LOCAL_ACTION_END_B6</b></b></dt>
  <dd>End.B6 action: Endpoint bound to an SRv6 policy. Type of <i>param</i>:
      <b>struct ipv6_sr_hdr</b>.</dd>
  <dt><b><b>SEG6_LOCAL_ACTION_END_B6_ENCAP</b></b></dt>
  <dd>End.B6.Encap action: Endpoint bound to an SRv6 encapsulation policy. Type
      of <i>param</i>: <b>struct ipv6_sr_hdr</b>.</dd>
</dl>
</div>
<br/>
<p class="Pp">A call to this helper is susceptible to change the underlying
    packet buffer. Therefore, at load time, all checks on pointers previously
    done by the verifier are invalidated and must be performed again, if the
    helper is used in combination with direct packet access.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_rc_repeat(void *</b><i>ctx</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>This helper is used in programs implementing IR decoding, to report a
      successfully decoded repeat key message. This delays the generation of a
      key up event for previously generated key down event.
    <p class="Pp">Some IR protocols like NEC have a special IR message for
        repeating last button, for when a button is held down.</p>
    <p class="Pp">The <i>ctx</i> should point to the lirc sample as passed into
        the program.</p>
    <p class="Pp">This helper is only available is the kernel was compiled with
        the <b>CONFIG_BPF_LIRC_MODE2</b> configuration option set to
        &quot;<b>y</b>&quot;.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_rc_keydown(void *</b><i>ctx</i><b>, u32</b>
    <i>protocol</i><b>, u64</b> <i>scancode</i><b>, u32</b>
    <i>toggle</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>This helper is used in programs implementing IR decoding, to report a
      successfully decoded key press with <i>scancode</i>, <i>toggle</i> value
      in the given <i>protocol</i>. The scancode will be translated to a keycode
      using the rc keymap, and reported as an input key down event. After a
      period a key up event is generated. This period can be extended by calling
      either <b>bpf_rc_keydown</b>() again with the same values, or calling
      <b>bpf_rc_repeat</b>().
    <p class="Pp">Some protocols include a toggle bit, in case the button was
        released and pressed again between consecutive scancodes.</p>
    <p class="Pp">The <i>ctx</i> should point to the lirc sample as passed into
        the program.</p>
    <p class="Pp">The <i>protocol</i> is the decoded protocol number (see
        <b>enum rc_proto</b> for some predefined values).</p>
    <p class="Pp">This helper is only available is the kernel was compiled with
        the <b>CONFIG_BPF_LIRC_MODE2</b> configuration option set to
        &quot;<b>y</b>&quot;.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u64 bpf_skb_cgroup_id(struct sk_buff
    *</b><i>skb</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Return the cgroup v2 id of the socket associated with the <i>skb</i>. This
      is roughly similar to the <b>bpf_get_cgroup_classid</b>() helper for
      cgroup v1 by providing a tag resp. identifier that can be matched on or
      used for map lookups e.g. to implement policy. The cgroup v2 id of a given
      path in the hierarchy is exposed in user space through the f_handle API in
      order to get to the same 64-bit id.
    <p class="Pp">This helper can be used on TC egress path, but not on ingress,
        and is available only if the kernel was compiled with the
        <b>CONFIG_SOCK_CGROUP_DATA</b> configuration option.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>The id is returned or 0 in case the id could not be retrieved.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u64 bpf_get_current_cgroup_id(void)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>A 64-bit integer containing the current cgroup id based on the cgroup
      within which the current task is running.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>void *bpf_get_local_storage(void *</b><i>map</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Get the pointer to the local storage area. The type and the size of the
      local storage is defined by the <i>map</i> argument. The <i>flags</i>
      meaning is specific for each map type, and has to be 0 for cgroup local
      storage.
    <p class="Pp">Depending on the BPF program type, a local storage area can be
        shared between multiple instances of the BPF program, running
        simultaneously.</p>
    <p class="Pp">A user should care about the synchronization by himself. For
        example, by using the <b>BPF_STX_XADD</b> instruction to alter the
        shared data.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>A pointer to the local storage area.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_sk_select_reuseport(struct sk_reuseport_md
    *</b><i>reuse</i><b>, struct bpf_map *</b><i>map</i><b>, void
    *</b><i>key</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Select a <b>SO_REUSEPORT</b> socket from a
      <b>BPF_MAP_TYPE_REUSEPORT_ARRAY</b> <i>map</i>. It checks the selected
      socket is matching the incoming request in the socket buffer.</dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>u64 bpf_skb_ancestor_cgroup_id(struct sk_buff *</b><i>skb</i><b>,
    int</b> <i>ancestor_level</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Return id of cgroup v2 that is ancestor of cgroup associated with the
      <i>skb</i> at the <i>ancestor_level</i>. The root cgroup is at
      <i>ancestor_level</i> zero and each step down the hierarchy increments the
      level. If <i>ancestor_level</i> == level of cgroup associated with
      <i>skb</i>, then return value will be same as that of
      <b>bpf_skb_cgroup_id</b>().
    <p class="Pp">The helper is useful to implement policies based on cgroups
        that are upper in hierarchy than immediate cgroup associated with
        <i>skb</i>.</p>
    <p class="Pp">The format of returned id and helper limitations are same as
        in <b>bpf_skb_cgroup_id</b>().</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>The id is returned or 0 in case the id could not be retrieved.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>struct bpf_sock *bpf_sk_lookup_tcp(void *</b><i>ctx</i><b>, struct
    bpf_sock_tuple *</b><i>tuple</i><b>, u32</b> <i>tuple_size</i><b>, u64</b>
    <i>netns</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Look for TCP socket matching <i>tuple</i>, optionally in a child network
      namespace <i>netns</i>. The return value must be checked, and if
      non-<b>NULL</b>, released via <b>bpf_sk_release</b>().
    <p class="Pp">The <i>ctx</i> should point to the context of the program,
        such as the skb or socket (depending on the hook in use). This is used
        to determine the base network namespace for the lookup.</p>
    <p class="Pp"><i>tuple_size</i> must be one of:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>sizeof</b>(<i>tuple</i><b>-&gt;ipv4</b>)</b></dt>
  <dd>Look for an IPv4 socket.</dd>
  <dt><b><b>sizeof</b>(<i>tuple</i><b>-&gt;ipv6</b>)</b></dt>
  <dd>Look for an IPv6 socket.</dd>
</dl>
</div>
<br/>
<p class="Pp">If the <i>netns</i> is a negative signed 32-bit integer, then the
    socket lookup table in the netns associated with the <i>ctx</i> will will be
    used. For the TC hooks, this is the netns of the device in the skb. For
    socket hooks, this is the netns of the socket. If <i>netns</i> is any other
    signed 32-bit value greater than or equal to zero then it specifies the ID
    of the netns relative to the netns associated with the <i>ctx</i>.
    <i>netns</i> values beyond the range of 32-bit integers are reserved for
    future use.</p>
<p class="Pp">All values for <i>flags</i> are reserved for future usage, and
    must be left at zero.</p>
<p class="Pp">This helper is available only if the kernel was compiled with
    <b>CONFIG_NET</b> configuration option.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>Pointer to <b>struct bpf_sock</b>, or <b>NULL</b> in case of failure. For
      sockets with reuseport option, the <b>struct bpf_sock</b> result is from
      <i>reuse</i><b>-&gt;socks</b>[] using the hash of the tuple.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>struct bpf_sock *bpf_sk_lookup_udp(void *</b><i>ctx</i><b>, struct
    bpf_sock_tuple *</b><i>tuple</i><b>, u32</b> <i>tuple_size</i><b>, u64</b>
    <i>netns</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Look for UDP socket matching <i>tuple</i>, optionally in a child network
      namespace <i>netns</i>. The return value must be checked, and if
      non-<b>NULL</b>, released via <b>bpf_sk_release</b>().
    <p class="Pp">The <i>ctx</i> should point to the context of the program,
        such as the skb or socket (depending on the hook in use). This is used
        to determine the base network namespace for the lookup.</p>
    <p class="Pp"><i>tuple_size</i> must be one of:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>sizeof</b>(<i>tuple</i><b>-&gt;ipv4</b>)</b></dt>
  <dd>Look for an IPv4 socket.</dd>
  <dt><b><b>sizeof</b>(<i>tuple</i><b>-&gt;ipv6</b>)</b></dt>
  <dd>Look for an IPv6 socket.</dd>
</dl>
</div>
<br/>
<p class="Pp">If the <i>netns</i> is a negative signed 32-bit integer, then the
    socket lookup table in the netns associated with the <i>ctx</i> will will be
    used. For the TC hooks, this is the netns of the device in the skb. For
    socket hooks, this is the netns of the socket. If <i>netns</i> is any other
    signed 32-bit value greater than or equal to zero then it specifies the ID
    of the netns relative to the netns associated with the <i>ctx</i>.
    <i>netns</i> values beyond the range of 32-bit integers are reserved for
    future use.</p>
<p class="Pp">All values for <i>flags</i> are reserved for future usage, and
    must be left at zero.</p>
<p class="Pp">This helper is available only if the kernel was compiled with
    <b>CONFIG_NET</b> configuration option.</p>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>Pointer to <b>struct bpf_sock</b>, or <b>NULL</b> in case of failure. For
      sockets with reuseport option, the <b>struct bpf_sock</b> result is from
      <i>reuse</i><b>-&gt;socks</b>[] using the hash of the tuple.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_sk_release(struct bpf_sock *</b><i>sock</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Release the reference held by <i>sock</i>. <i>sock</i> must be a
      non-<b>NULL</b> pointer that was returned from
    <b>bpf_sk_lookup_xxx</b>().</dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_map_push_elem(struct bpf_map *</b><i>map</i><b>, const void
    *</b><i>value</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Push an element <i>value</i> in <i>map</i>. <i>flags</i> is one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b><b>BPF_EXIST</b></b></dt>
  <dd>If the queue/stack is full, the oldest element is removed to make room for
      this.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_map_pop_elem(struct bpf_map *</b><i>map</i><b>, void
    *</b><i>value</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Pop an element from <i>map</i>.</dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_map_peek_elem(struct bpf_map *</b><i>map</i><b>, void
    *</b><i>value</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Get an element from <i>map</i> without removing it.</dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_msg_push_data(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>start</i><b>, u32</b> <i>len</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>For socket policies, insert <i>len</i> bytes into <i>msg</i> at offset
      <i>start</i>.
    <p class="Pp">If a program of type <b>BPF_PROG_TYPE_SK_MSG</b> is run on a
        <i>msg</i> it may want to insert metadata or options into the
        <i>msg</i>. This can later be read and used by any of the lower layer
        BPF hooks.</p>
    <p class="Pp">This helper may fail if under memory pressure (a malloc fails)
        in these cases BPF programs will get an appropriate error and BPF
        programs will need to handle them.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_msg_pop_data(struct sk_msg_buff *</b><i>msg</i><b>, u32</b>
    <i>start</i><b>, u32</b> <i>pop</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Will remove <i>pop</i> bytes from a <i>msg</i> starting at byte
      <i>start</i>. This may result in <b>ENOMEM</b> errors under certain
      situations if an allocation and copy are required due to a full ring
      buffer. However, the helper will try to avoid doing the allocation if
      possible. Other errors can occur if input parameters are invalid either
      due to <i>start</i> byte not being valid part of <i>msg</i> payload and/or
      <i>pop</i> value being to large.</dd>
  <dt><b>Return</b></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_rc_pointer_rel(void *</b><i>ctx</i><b>, s32</b>
    <i>rel_x</i><b>, s32</b> <i>rel_y</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>This helper is used in programs implementing IR decoding, to report a
      successfully decoded pointer movement.
    <p class="Pp">The <i>ctx</i> should point to the lirc sample as passed into
        the program.</p>
    <p class="Pp">This helper is only available is the kernel was compiled with
        the <b>CONFIG_BPF_LIRC_MODE2</b> configuration option set to
        &quot;<b>y</b>&quot;.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_spin_lock(struct bpf_spin_lock
    *</b><i>lock</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Acquire a spinlock represented by the pointer <i>lock</i>, which is stored
      as part of a value of a map. Taking the lock allows to safely update the
      rest of the fields in that value. The spinlock can (and must) later be
      released with a call to <b>bpf_spin_unlock</b>(<i>lock</i>).
    <p class="Pp">Spinlocks in BPF programs come with a number of restrictions
        and constraints:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><b>bpf_spin_lock</b> objects are only allowed inside maps of types
      <b>BPF_MAP_TYPE_HASH</b> and <b>BPF_MAP_TYPE_ARRAY</b> (this list could be
      extended in the future).</li>
  <li>BTF description of the map is mandatory.</li>
  <li>The BPF program can take ONE lock at a time, since taking two or more
      could cause dead locks.</li>
  <li>Only one <b>struct bpf_spin_lock</b> is allowed per map element.</li>
  <li>When the lock is taken, calls (either BPF to BPF or helpers) are not
      allowed.</li>
  <li>The <b>BPF_LD_ABS</b> and <b>BPF_LD_IND</b> instructions are not allowed
      inside a spinlock-ed region.</li>
  <li>The BPF program MUST call <b>bpf_spin_unlock</b>() to release the lock, on
      all execution paths, before it returns.</li>
  <li>The BPF program can access <b>struct bpf_spin_lock</b> only via the
      <b>bpf_spin_lock</b>() and <b>bpf_spin_unlock</b>() helpers. Loading or
      storing data into the <b>struct</b> <b>bpf_spin_lock</b>
      <i>lock</i><b>;</b> field of a map is not allowed.</li>
  <li>To use the <b>bpf_spin_lock</b>() helper, the BTF description of the map
      value must be a struct and have <b>struct</b> <b>bpf_spin_lock</b>
      <i>anyname</i><b>;</b> field at the top level. Nested lock inside another
      struct is not allowed.</li>
  <li>The <b>struct bpf_spin_lock</b> <i>lock</i> field in a map value must be
      aligned on a multiple of 4 bytes in that value.</li>
  <li>Syscall with command <b>BPF_MAP_LOOKUP_ELEM</b> does not copy the
      <b>bpf_spin_lock</b> field to user space.</li>
  <li>Syscall with command <b>BPF_MAP_UPDATE_ELEM</b>, or update from a BPF
      program, do not update the <b>bpf_spin_lock</b> field.</li>
  <li><b>bpf_spin_lock</b> cannot be on the stack or inside a networking packet
      (it can only be inside of a map values).</li>
  <li><b>bpf_spin_lock</b> is available to root only.</li>
  <li>Tracing programs and socket filter programs cannot use
      <b>bpf_spin_lock</b>() due to insufficient preemption checks (but this may
      change in the future).</li>
  <li><b>bpf_spin_lock</b> is not allowed in inner maps of map-in-map.</li>
</ul>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b>Return</b></dt>
  <dd>0</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_spin_unlock(struct bpf_spin_lock
    *</b><i>lock</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Release the <i>lock</i> previously locked by a call to
      <b>bpf_spin_lock</b>(<i>lock</i>).</dd>
  <dt><b>Return</b></dt>
  <dd>0</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>struct bpf_sock *bpf_sk_fullsock(struct bpf_sock
    *</b><i>sk</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>This helper gets a <b>struct bpf_sock</b> pointer such that all the fields
      in this <b>bpf_sock</b> can be accessed.</dd>
  <dt><b>Return</b></dt>
  <dd>A <b>struct bpf_sock</b> pointer on success, or <b>NULL</b> in case of
      failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>struct bpf_tcp_sock *bpf_tcp_sock(struct bpf_sock
    *</b><i>sk</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>This helper gets a <b>struct bpf_tcp_sock</b> pointer from a <b>struct
      bpf_sock</b> pointer.</dd>
  <dt><b>Return</b></dt>
  <dd>A <b>struct bpf_tcp_sock</b> pointer on success, or <b>NULL</b> in case of
      failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_skb_ecn_set_ce(struct sk_buf
    *</b><i>skb</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Set ECN (Explicit Congestion Notification) field of IP header to <b>CE</b>
      (Congestion Encountered) if current value is <b>ECT</b> (ECN Capable
      Transport). Otherwise, do nothing. Works with IPv6 and IPv4.</dd>
  <dt><b>Return</b></dt>
  <dd>1 if the <b>CE</b> flag is set (either by the current helper call or
      because it was already present), 0 if it is not set.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>struct bpf_sock *bpf_get_listener_sock(struct bpf_sock
    *</b><i>sk</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Return a <b>struct bpf_sock</b> pointer in <b>TCP_LISTEN</b> state.
      <b>bpf_sk_release</b>() is unnecessary and not allowed.</dd>
  <dt><b>Return</b></dt>
  <dd>A <b>struct bpf_sock</b> pointer on success, or <b>NULL</b> in case of
      failure.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>struct bpf_sock *bpf_skc_lookup_tcp(void *</b><i>ctx</i><b>, struct
    bpf_sock_tuple *</b><i>tuple</i><b>, u32</b> <i>tuple_size</i><b>, u64</b>
    <i>netns</i><b>, u64</b> <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Look for TCP socket matching <i>tuple</i>, optionally in a child network
      namespace <i>netns</i>. The return value must be checked, and if
      non-<b>NULL</b>, released via <b>bpf_sk_release</b>().
    <p class="Pp">This function is identical to <b>bpf_sk_lookup_tcp</b>(),
        except that it also returns timewait or request sockets. Use
        <b>bpf_sk_fullsock</b>() or <b>bpf_tcp_sock</b>() to access the full
        structure.</p>
    <p class="Pp">This helper is available only if the kernel was compiled with
        <b>CONFIG_NET</b> configuration option.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>Pointer to <b>struct bpf_sock</b>, or <b>NULL</b> in case of failure. For
      sockets with reuseport option, the <b>struct bpf_sock</b> result is from
      <i>reuse</i><b>-&gt;socks</b>[] using the hash of the tuple.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_tcp_check_syncookie(struct bpf_sock *</b><i>sk</i><b>, void
    *</b><i>iph</i><b>, u32</b> <i>iph_len</i><b>, struct tcphdr
    *</b><i>th</i><b>, u32</b> <i>th_len</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Check whether <i>iph</i> and <i>th</i> contain a valid SYN cookie ACK for
      the listening socket in <i>sk</i>.
    <p class="Pp"><i>iph</i> points to the start of the IPv4 or IPv6 header,
        while <i>iph_len</i> contains <b>sizeof</b>(<b>struct iphdr</b>) or
        <b>sizeof</b>(<b>struct ip6hdr</b>).</p>
    <p class="Pp"><i>th</i> points to the start of the TCP header, while
        <i>th_len</i> contains <b>sizeof</b>(<b>struct tcphdr</b>).</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 if <i>iph</i> and <i>th</i> are a valid SYN cookie ACK, or a negative
      error otherwise.</dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_sysctl_get_name(struct bpf_sysctl *</b><i>ctx</i><b>, char
    *</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Get name of sysctl in /proc/sys/ and copy it into provided by program
      buffer <i>buf</i> of size <i>buf_len</i>.
    <p class="Pp">The buffer is always NUL terminated, unless it's
      zero-sized.</p>
    <p class="Pp">If <i>flags</i> is zero, full name (e.g.
        &quot;net/ipv4/tcp_mem&quot;) is copied. Use
        <b>BPF_F_SYSCTL_BASE_NAME</b> flag to copy base name only (e.g.
        &quot;tcp_mem&quot;).</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>Number of character copied (not including the trailing NUL).
    <p class="Pp"><b>-E2BIG</b> if the buffer wasn't big enough (<i>buf</i> will
        contain truncated name in this case).</p>
  </dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_sysctl_get_current_value(struct bpf_sysctl
    *</b><i>ctx</i><b>, char *</b><i>buf</i><b>, size_t</b>
    <i>buf_len</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Get current value of sysctl as it is presented in /proc/sys (incl.
      newline, etc), and copy it as a string into provided by program buffer
      <i>buf</i> of size <i>buf_len</i>.
    <p class="Pp">The whole value is copied, no matter what file position user
        space issued e.g. sys_read at.</p>
    <p class="Pp">The buffer is always NUL terminated, unless it's
      zero-sized.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>Number of character copied (not including the trailing NUL).
    <p class="Pp"><b>-E2BIG</b> if the buffer wasn't big enough (<i>buf</i> will
        contain truncated name in this case).</p>
    <p class="Pp"><b>-EINVAL</b> if current value was unavailable, e.g. because
        sysctl is uninitialized and read returns -EIO for it.</p>
  </dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_sysctl_get_new_value(struct bpf_sysctl *</b><i>ctx</i><b>,
    char *</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Get new value being written by user space to sysctl (before the actual
      write happens) and copy it as a string into provided by program buffer
      <i>buf</i> of size <i>buf_len</i>.
    <p class="Pp">User space may write new value at file position &gt; 0.</p>
    <p class="Pp">The buffer is always NUL terminated, unless it's
      zero-sized.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>Number of character copied (not including the trailing NUL).
    <p class="Pp"><b>-E2BIG</b> if the buffer wasn't big enough (<i>buf</i> will
        contain truncated name in this case).</p>
    <p class="Pp"><b>-EINVAL</b> if sysctl is being read.</p>
  </dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_sysctl_set_new_value(struct bpf_sysctl *</b><i>ctx</i><b>,
    const char *</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Override new value being written by user space to sysctl with value
      provided by program in buffer <i>buf</i> of size <i>buf_len</i>.
    <p class="Pp"><i>buf</i> should contain a string in same form as provided by
        user space on sysctl write.</p>
    <p class="Pp">User space may write new value at file position &gt; 0. To
        override the whole sysctl value file position should be set to zero.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>0 on success.
    <p class="Pp"><b>-E2BIG</b> if the <i>buf_len</i> is too big.</p>
    <p class="Pp"><b>-EINVAL</b> if sysctl is being read.</p>
  </dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_strtol(const char *</b><i>buf</i><b>, size_t</b>
    <i>buf_len</i><b>, u64</b> <i>flags</i><b>, long
    *</b><i>res</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Convert the initial part of the string from buffer <i>buf</i> of size
      <i>buf_len</i> to a long integer according to the given base and save the
      result in <i>res</i>.
    <p class="Pp">The string may begin with an arbitrary amount of white space
        (as determined by <b>isspace</b>(3)) followed by a single optional
        '<b>-</b>' sign.</p>
    <p class="Pp">Five least significant bits of <i>flags</i> encode base, other
        bits are currently unused.</p>
    <p class="Pp">Base must be either 8, 10, 16 or 0 to detect it automatically
        similar to user space <b>strtol</b>(3).</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>Number of characters consumed on success. Must be positive but no more
      than <i>buf_len</i>.
    <p class="Pp"><b>-EINVAL</b> if no valid digits were found or unsupported
        base was provided.</p>
    <p class="Pp"><b>-ERANGE</b> if resulting value was out of range.</p>
  </dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_strtoul(const char *</b><i>buf</i><b>, size_t</b>
    <i>buf_len</i><b>, u64</b> <i>flags</i><b>, unsigned long
    *</b><i>res</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Convert the initial part of the string from buffer <i>buf</i> of size
      <i>buf_len</i> to an unsigned long integer according to the given base and
      save the result in <i>res</i>.
    <p class="Pp">The string may begin with an arbitrary amount of white space
        (as determined by <b>isspace</b>(3)).</p>
    <p class="Pp">Five least significant bits of <i>flags</i> encode base, other
        bits are currently unused.</p>
    <p class="Pp">Base must be either 8, 10, 16 or 0 to detect it automatically
        similar to user space <b>strtoul</b>(3).</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>Number of characters consumed on success. Must be positive but no more
      than <i>buf_len</i>.
    <p class="Pp"><b>-EINVAL</b> if no valid digits were found or unsupported
        base was provided.</p>
    <p class="Pp"><b>-ERANGE</b> if resulting value was out of range.</p>
  </dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>void *bpf_sk_storage_get(struct bpf_map *</b><i>map</i><b>, struct
    bpf_sock *</b><i>sk</i><b>, void *</b><i>value</i><b>, u64</b>
    <i>flags</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Get a bpf-local-storage from a <i>sk</i>.
    <p class="Pp">Logically, it could be thought of getting the value from a
        <i>map</i> with <i>sk</i> as the <b>key</b>. From this perspective, the
        usage is not much different from <b>bpf_map_lookup_elem</b>(<i>map</i>,
        <b>&amp;</b><i>sk</i>) except this helper enforces the key must be a
        full socket and the map must be a <b>BPF_MAP_TYPE_SK_STORAGE</b>
      also.</p>
    <p class="Pp">Underneath, the value is stored locally at <i>sk</i> instead
        of the <i>map</i>. The <i>map</i> is used as the bpf-local-storage
        &quot;type&quot;. The bpf-local-storage &quot;type&quot; (i.e. the
        <i>map</i>) is searched against all bpf-local-storages residing at
        <i>sk</i>.</p>
    <p class="Pp">An optional <i>flags</i> (<b>BPF_SK_STORAGE_GET_F_CREATE</b>)
        can be used such that a new bpf-local-storage will be created if one
        does not exist. <i>value</i> can be used together with
        <b>BPF_SK_STORAGE_GET_F_CREATE</b> to specify the initial value of a
        bpf-local-storage. If <i>value</i> is <b>NULL</b>, the new
        bpf-local-storage will be zero initialized.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>A bpf-local-storage pointer is returned on success.
    <p class="Pp"><b>NULL</b> if not found or there was an error in adding a new
        bpf-local-storage.</p>
  </dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_sk_storage_delete(struct bpf_map *</b><i>map</i><b>, struct
    bpf_sock *</b><i>sk</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Delete a bpf-local-storage from a <i>sk</i>.</dd>
  <dt><b>Return</b></dt>
  <dd>0 on success.
    <p class="Pp"><b>-ENOENT</b> if the bpf-local-storage cannot be found.</p>
  </dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>int bpf_send_signal(u32</b> <i>sig</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Send signal <i>sig</i> to the current task.</dd>
  <dt><b>Return</b></dt>
  <dd>0 on success or successfully queued.
    <p class="Pp"><b>-EBUSY</b> if work queue under nmi is full.</p>
    <p class="Pp"><b>-EINVAL</b> if <i>sig</i> is invalid.</p>
    <p class="Pp"><b>-EPERM</b> if no permission to send the <i>sig</i>.</p>
    <p class="Pp"><b>-EAGAIN</b> if bpf program can try again.</p>
  </dd>
</dl>
</div>
<br/>
<dl class="Bl-tag">
  <dt><b><b>s64 bpf_tcp_gen_syncookie(struct bpf_sock *</b><i>sk</i><b>, void
    *</b><i>iph</i><b>, u32</b> <i>iph_len</i><b>, struct tcphdr
    *</b><i>th</i><b>, u32</b> <i>th_len</i><b>)</b></b></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>Description</b></dt>
  <dd>Try to issue a SYN cookie for the packet with corresponding IP/TCP
      headers, <i>iph</i> and <i>th</i>, on the listening socket in <i>sk</i>.
    <p class="Pp"><i>iph</i> points to the start of the IPv4 or IPv6 header,
        while <i>iph_len</i> contains <b>sizeof</b>(<b>struct iphdr</b>) or
        <b>sizeof</b>(<b>struct ip6hdr</b>).</p>
    <p class="Pp"><i>th</i> points to the start of the TCP header, while
        <i>th_len</i> contains the length of the TCP header.</p>
  </dd>
  <dt><b>Return</b></dt>
  <dd>On success, lower 32 bits hold the generated SYN cookie in followed by 16
      bits which hold the MSS value for that cookie, and the top 16 bits are
      unused.
    <p class="Pp">On failure, the returned value is one of the following:</p>
    <p class="Pp"><b>-EINVAL</b> SYN cookie cannot be issued due to error</p>
    <p class="Pp"><b>-ENOENT</b> SYN cookie should not be issued (no SYN
      flood)</p>
    <p class="Pp"><b>-EOPNOTSUPP</b> kernel configuration does not enable SYN
        cookies</p>
    <p class="Pp"><b>-EPROTONOSUPPORT</b> IP packet version is not 4 or 6</p>
  </dd>
</dl>
</div>
<br/>
</div>
<br/>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
Example usage for most of the eBPF helpers listed in this manual page are
  available within the Linux kernel sources, at the following locations:
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><i>samples/bpf/</i></li>
  <li><i>tools/testing/selftests/bpf/</i></li>
</ul>
</div>
<br/>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
eBPF programs can have an associated license, passed along with the bytecode
  instructions to the kernel when the programs are loaded. The format for that
  string is identical to the one in use for kernel modules (Dual licenses, such
  as &quot;Dual BSD/GPL&quot;, may be used). Some helper functions are only
  accessible to programs that are compatible with the GNU Privacy License (GPL).
<p class="Pp">In order to use such helpers, the eBPF program must be loaded with
    the correct license string passed (via <b>attr</b>) to the <b>bpf</b>()
    system call, and this generally translates into the C source code of the
    program containing a line similar to the following:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>
char ____license[] __attribute__((section(&quot;license&quot;), used)) = &quot;GPL&quot;;
<b></b>
</pre>
</div>
<br/>
</div>
<br/>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPLEMENTATION"><a class="permalink" href="#IMPLEMENTATION">IMPLEMENTATION</a></h1>
This manual page is an effort to document the existing eBPF helper functions.
  But as of this writing, the BPF sub-system is under heavy development. New
  eBPF program or map types are added, along with new helper functions. Some
  helpers are occasionally made available for additional program types. So in
  spite of the efforts of the community, this page might not be up-to-date. If
  you want to check by yourself what helper functions exist in your kernel, or
  what types of programs they can support, here are some files among the kernel
  tree that you may be interested in:
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><i>include/uapi/linux/bpf.h</i> is the main BPF header. It contains the
      full list of all helper functions, as well as many other BPF definitions
      including most of the flags, structs or constants used by the
    helpers.</li>
  <li><i>net/core/filter.c</i> contains the definition of most network-related
      helper functions, and the list of program types from which they can be
      used.</li>
  <li><i>kernel/trace/bpf_trace.c</i> is the equivalent for most tracing
      program-related helpers.</li>
  <li><i>kernel/bpf/verifier.c</i> contains the functions used to check that
      valid types of eBPF maps are used with a given helper function.</li>
  <li><i>kernel/bpf/</i> directory contains other files in which additional
      helpers are defined (for cgroups, sockmaps, etc.).</li>
</ul>
</div>
<br/>
<p class="Pp">Compatibility between helper functions and program types can
    generally be found in the files where helper functions are defined. Look for
    the <b>struct</b> <b>bpf_func_proto</b> objects and for functions returning
    them: these functions contain a list of helpers that a given program type
    can call. Note that the <b>default:</b> label of the <b>switch ... case</b>
    used to filter helpers can call other functions, themselves allowing access
    to additional helpers. The requirement for GPL license is also in those
    <b>struct bpf_func_proto</b>.</p>
<p class="Pp">Compatibility between helper functions and map types can be found
    in the <b>check_map_func_compatibility</b>() function in file
    <i>kernel/bpf/verifier.c</i>.</p>
<p class="Pp">Helper functions that invalidate the checks on <b>data</b> and
    <b>data_end</b> pointers for network processing are listed in function
    <b>bpf_helper_changes_pkt_data</b>() in file <i>net/core/filter.c</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>bpf</b>(2), <b>cgroups</b>(7), <b>ip</b>(8), <b>perf_event_open</b>(2),
  <b>sendmsg</b>(2), <b>socket</b>(7), <b>tc-bpf</b>(8)
</section>
<section class="Sh">
<h1 class="Sh" id="COLOPHON"><a class="permalink" href="#COLOPHON">COLOPHON</a></h1>
This page is part of release 5.05 of the Linux <i>man-pages</i> project. A
  description of the project, information about reporting bugs, and the latest
  version of this page, can be found at https://www.kernel.org/doc/man-pages/.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-19</td>
    <td class="foot-os">Linux</td>
  </tr>
</table>

	</div>
	<div class=footer>
		<p>Copyright 2020 Scott Court</p>
	</div>
	</div>
</body>
