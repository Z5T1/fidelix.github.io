
<!DOCTYPE HTML>
<head>
	<title>/usr/share/man/man1/perlfork.1</title>		<link rel='stylesheet' href='/mandoc.css' />
	<link rel='stylesheet' href='/style.css' />
</head>
<body>
	<div class=contents>
	<div class=header>
	<h1>The Fidelix Linux Distribution</h1>
	<h2>Simple, Stable, and Secure</h2>
	</div>
<div class=menubar>
	<ul>
		<li><a href=/>News</a></li>
		<li><a href=/about.html>About</a></li>
		<div class=dropdown>
			<li><a href=/download>Download</a></li>
			<ul class=dropdown-content>
				<li><a href=/download/>Latest Downloads</a></li>
				<li><a href=/download/all.html>All Downloads</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Documentation</a></li>
			<ul class=dropdown-content>
				<li><a href=/handbook/>Handbook</a></li>
				<li><a href=/man/>Manual Pages</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Development</a></li>
			<ul class=dropdown-content>
				<li><a href=https://github.com/Z5T1/fidelix>GitHub</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Community</a></li>
			<ul class=dropdown-content>
				<li><a href=https://discord.com/invite/Yz8DeUr>Discord</a></li>
			</ul>
		</div>
	</ul>
</div>


	<div class=body><table class="head">
  <tr>
    <td class="head-ltitle">PERLFORK(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLFORK(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlfork - Perl's fork() emulation
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    NOTE:  As of the 5.8.0 release, fork() emulation has considerably
    matured.  However, there are still a few known bugs and differences
    from real fork() that might affect you.  See the &quot;BUGS&quot; and
    &quot;CAVEATS AND LIMITATIONS&quot; sections below.
</pre>
<p class="Pp">Perl provides a <b>fork()</b> keyword that corresponds to the Unix
    system call of the same name. On most Unix-like platforms where the
    <b>fork()</b> system call is available, Perl's <b>fork()</b> simply calls
    it.</p>
<p class="Pp">On some platforms such as Windows where the <b>fork()</b> system
    call is not available, Perl can be built to emulate <b>fork()</b> at the
    interpreter level. While the emulation is designed to be as compatible as
    possible with the real <b>fork()</b> at the level of the Perl program, there
    are certain important differences that stem from the fact that all the
    pseudo child &quot;processes&quot; created this way live in the same real
    process as far as the operating system is concerned.</p>
<p class="Pp">This document provides a general overview of the capabilities and
    limitations of the <b>fork()</b> emulation. Note that the issues discussed
    here are not applicable to platforms where a real <b>fork()</b> is available
    and Perl has been configured to use it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <b>fork()</b> emulation is implemented at the level of the Perl interpreter.
  What this means in general is that running <b>fork()</b> will actually clone
  the running interpreter and all its state, and run the cloned interpreter in a
  separate thread, beginning execution in the new thread just after the point
  where the <b>fork()</b> was called in the parent. We will refer to the thread
  that implements this child &quot;process&quot; as the pseudo-process.
<p class="Pp">To the Perl program that called <b>fork()</b>, all this is
    designed to be transparent. The parent returns from the <b>fork()</b> with a
    pseudo-process ID that can be subsequently used in any process-manipulation
    functions; the child returns from the <b>fork()</b> with a value of
    <span class="Li">0</span> to signify that it is the child
  pseudo-process.</p>
<section class="Ss">
<h2 class="Ss" id="Behavior_of_other_Perl_features_in_forked_pseudo-processes"><a class="permalink" href="#Behavior_of_other_Perl_features_in_forked_pseudo-processes">Behavior
  of other Perl features in forked pseudo-processes</a></h2>
Most Perl features behave in a natural way within pseudo-processes.
<dl class="Bl-tag">
  <dt>$$ or $PROCESS_ID</dt>
  <dd>This special variable is correctly set to the pseudo-process ID. It can be
      used to identify pseudo-processes within a particular session. Note that
      this value is subject to recycling if any pseudo-processes are launched
      after others have been <b>wait()</b>-ed on.</dd>
  <dt>%ENV</dt>
  <dd>Each pseudo-process maintains its own virtual environment. Modifications
      to <span class="Li">%ENV</span> affect the virtual environment, and are
      only visible within that pseudo-process, and in any processes (or
      pseudo-processes) launched from it.</dd>
  <dt><b>chdir()</b> and all other builtins that accept filenames</dt>
  <dd>Each pseudo-process maintains its own virtual idea of the current
      directory. Modifications to the current directory using <b>chdir()</b> are
      only visible within that pseudo-process, and in any processes (or
      pseudo-processes) launched from it. All file and directory accesses from
      the pseudo-process will correctly map the virtual working directory to the
      real working directory appropriately.</dd>
  <dt><b>wait()</b> and <b>waitpid()</b></dt>
  <dd><b>wait()</b> and <b>waitpid()</b> can be passed a pseudo-process ID
      returned by <b>fork()</b>. These calls will properly wait for the
      termination of the pseudo-process and return its status.</dd>
  <dt><b>kill()</b></dt>
  <dd><span class="Li">&quot;kill('KILL', ...)&quot;</span> can be used to
      terminate a pseudo-process by passing it the ID returned by <b>fork()</b>.
      The outcome of kill on a pseudo-process is unpredictable and it should not
      be used except under dire circumstances, because the operating system may
      not guarantee integrity of the process resources when a running thread is
      terminated. The process which implements the pseudo-processes can be
      blocked and the Perl interpreter hangs. Note that using
      <span class="Li">&quot;kill('KILL', ...)&quot;</span> on a
      pseudo-<b>process()</b> may typically cause memory leaks, because the
      thread that implements the pseudo-process does not get a chance to clean
      up its resources.
    <p class="Pp"><span class="Li">&quot;kill('TERM', ...)&quot;</span> can also
        be used on pseudo-processes, but the signal will not be delivered while
        the pseudo-process is blocked by a system call, e.g. waiting for a
        socket to connect, or trying to read from a socket with no data
        available. Starting in Perl 5.14 the parent process will not wait for
        children to exit once they have been signalled with
        <span class="Li">&quot;kill('TERM', ...)&quot;</span> to avoid deadlock
        during process exit. You will have to explicitly call <b>waitpid()</b>
        to make sure the child has time to clean-up itself, but you are then
        also responsible that the child is not blocking on I/O either.</p>
  </dd>
  <dt><b>exec()</b></dt>
  <dd>Calling <b>exec()</b> within a pseudo-process actually spawns the
      requested executable in a separate process and waits for it to complete
      before exiting with the same exit status as that process. This means that
      the process ID reported within the running executable will be different
      from what the earlier Perl <b>fork()</b> might have returned. Similarly,
      any process manipulation functions applied to the ID returned by
      <b>fork()</b> will affect the waiting pseudo-process that called
      <b>exec()</b>, not the real process it is waiting for after the
      <b>exec()</b>.
    <p class="Pp">When <b>exec()</b> is called inside a pseudo-process then
        DESTROY methods and END blocks will still be called after the external
        process returns.</p>
  </dd>
  <dt><b>exit()</b></dt>
  <dd><b>exit()</b> always exits just the executing pseudo-process, after
      automatically <b>wait()</b>-ing for any outstanding child
      pseudo-processes. Note that this means that the process as a whole will
      not exit unless all running pseudo-processes have exited. See below for
      some limitations with open filehandles.</dd>
  <dt>Open handles to files, directories and network sockets</dt>
  <dd>All open handles are <b>dup()</b>-ed in pseudo-processes, so that closing
      any handles in one process does not affect the others. See below for some
      limitations.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Resource_limits"><a class="permalink" href="#Resource_limits">Resource
  limits</a></h2>
In the eyes of the operating system, pseudo-processes created via the
  <b>fork()</b> emulation are simply threads in the same process. This means
  that any process-level limits imposed by the operating system apply to all
  pseudo-processes taken together. This includes any limits imposed by the
  operating system on the number of open file, directory and socket handles,
  limits on disk space usage, limits on memory size, limits on CPU utilization
  etc.
</section>
<section class="Ss">
<h2 class="Ss" id="Killing_the_parent_process"><a class="permalink" href="#Killing_the_parent_process">Killing
  the parent process</a></h2>
If the parent process is killed (either using Perl's <b>kill()</b> builtin, or
  using some external means) all the pseudo-processes are killed as well, and
  the whole process exits.
</section>
<section class="Ss">
<h2 class="Ss" id="Lifetime_of_the_parent_process_and_pseudo-processes"><a class="permalink" href="#Lifetime_of_the_parent_process_and_pseudo-processes">Lifetime
  of the parent process and pseudo-processes</a></h2>
During the normal course of events, the parent process and every pseudo-process
  started by it will wait for their respective pseudo-children to complete
  before they exit. This means that the parent and every pseudo-child created by
  it that is also a pseudo-parent will only exit after their pseudo-children
  have exited.
<p class="Pp">Starting with Perl 5.14 a parent will not <b>wait()</b>
    automatically for any child that has been signalled with
    <span class="Li">&quot;kill('TERM', ...)&quot;</span> to avoid a deadlock in
    case the child is blocking on I/O and never receives the signal.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS_AND_LIMITATIONS"><a class="permalink" href="#CAVEATS_AND_LIMITATIONS">CAVEATS
  AND LIMITATIONS</a></h1>
<dl class="Bl-tag">
  <dt>BEGIN blocks</dt>
  <dd>The <b>fork()</b> emulation will not work entirely correctly when called
      from within a BEGIN block. The forked copy will run the contents of the
      BEGIN block, but will not continue parsing the source stream after the
      BEGIN block. For example, consider the following code:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    BEGIN {
        fork and exit;          # fork child and exit the parent
        print &quot;inner\n&quot;;
    }
    print &quot;outer\n&quot;;
    </pre>
    <p class="Pp">This will print:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    inner
    </pre>
    <p class="Pp">rather than the expected:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    inner
    outer
    </pre>
    <p class="Pp">This limitation arises from fundamental technical difficulties
        in cloning and restarting the stacks used by the Perl parser in the
        middle of a parse.</p>
  </dd>
  <dt>Open filehandles</dt>
  <dd>Any filehandles open at the time of the <b>fork()</b> will be
      <b>dup()</b>-ed. Thus, the files can be closed independently in the parent
      and child, but beware that the <b>dup()</b>-ed handles will still share
      the same seek pointer. Changing the seek position in the parent will
      change it in the child and vice-versa. One can avoid this by opening files
      that need distinct seek pointers separately in the child.
    <p class="Pp">On some operating systems, notably Solaris and Unixware,
        calling <span class="Li">&quot;exit()&quot;</span> from a child process
        will flush and close open filehandles in the parent, thereby corrupting
        the filehandles. On these systems, calling
        <span class="Li">&quot;_exit()&quot;</span> is suggested instead.
        <span class="Li">&quot;_exit()&quot;</span> is available in Perl through
        the <span class="Li">&quot;POSIX&quot;</span> module. Please consult
        your system's manpages for more information on this.</p>
  </dd>
  <dt>Open directory handles</dt>
  <dd>Perl will completely read from all open directory handles until they reach
      the end of the stream. It will then <b>seekdir()</b> back to the original
      location and all future <b>readdir()</b> requests will be fulfilled from
      the cache buffer. That means that neither the directory handle held by the
      parent process nor the one held by the child process will see any changes
      made to the directory after the <b>fork()</b> call.
    <p class="Pp">Note that <b>rewinddir()</b> has a similar limitation on
        Windows and will not force <b>readdir()</b> to read the directory again
        either. Only a newly opened directory handle will reflect changes to the
        directory.</p>
  </dd>
  <dt>Forking pipe <b>open()</b> not yet implemented</dt>
  <dd>The <span class="Li">&quot;open(FOO, &quot;|-&quot;)&quot;</span> and
      <span class="Li">&quot;open(BAR, &quot;-|&quot;)&quot;</span> constructs
      are not yet implemented. This limitation can be easily worked around in
      new code by creating a pipe explicitly. The following example shows how to
      write to a forked child:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    # simulate open(FOO, &quot;|-&quot;)
    sub pipe_to_fork ($) {
        my $parent = shift;
        pipe my $child, $parent or die;
        my $pid = fork();
        die &quot;fork() failed: $!&quot; unless defined $pid;
        if ($pid) {
            close $child;
        }
        else {
            close $parent;
            open(STDIN, &quot;&lt;&amp;=&quot; . fileno($child)) or die;
        }
        $pid;
    }

    if (pipe_to_fork('FOO')) {
        # parent
        print FOO &quot;pipe_to_fork\n&quot;;
        close FOO;
    }
    else {
        # child
        while (&lt;STDIN&gt;) { print; }
        exit(0);
    }
    </pre>
    <p class="Pp">And this one reads from the child:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    # simulate open(FOO, &quot;-|&quot;)
    sub pipe_from_fork ($) {
        my $parent = shift;
        pipe $parent, my $child or die;
        my $pid = fork();
        die &quot;fork() failed: $!&quot; unless defined $pid;
        if ($pid) {
            close $child;
        }
        else {
            close $parent;
            open(STDOUT, &quot;&gt;&amp;=&quot; . fileno($child)) or die;
        }
        $pid;
    }

    if (pipe_from_fork('BAR')) {
        # parent
        while (&lt;BAR&gt;) { print; }
        close BAR;
    }
    else {
        # child
        print &quot;pipe_from_fork\n&quot;;
        exit(0);
    }
    </pre>
    <p class="Pp">Forking pipe <b>open()</b> constructs will be supported in
        future.</p>
  </dd>
  <dt>Global state maintained by XSUBs</dt>
  <dd>External subroutines (XSUBs) that maintain their own global state may not
      work correctly. Such XSUBs will either need to maintain locks to protect
      simultaneous access to global data from different pseudo-processes, or
      maintain all their state on the Perl symbol table, which is copied
      naturally when <b>fork()</b> is called. A callback mechanism that provides
      extensions an opportunity to clone their state will be provided in the
      near future.</dd>
  <dt>Interpreter embedded in larger application</dt>
  <dd>The <b>fork()</b> emulation may not behave as expected when it is executed
      in an application which embeds a Perl interpreter and calls Perl APIs that
      can evaluate bits of Perl code. This stems from the fact that the
      emulation only has knowledge about the Perl interpreter's own data
      structures and knows nothing about the containing application's state. For
      example, any state carried on the application's own call stack is out of
      reach.</dd>
  <dt>Thread-safety of extensions</dt>
  <dd>Since the <b>fork()</b> emulation runs code in multiple threads,
      extensions calling into non-thread-safe libraries may not work reliably
      when calling <b>fork()</b>. As Perl's threading support gradually becomes
      more widely adopted even on platforms with a native <b>fork()</b>, such
      extensions are expected to be fixed for thread-safety.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="PORTABILITY_CAVEATS"><a class="permalink" href="#PORTABILITY_CAVEATS">PORTABILITY
  CAVEATS</a></h1>
In portable Perl code, <span class="Li">&quot;kill(9, $child)&quot;</span> must
  not be used on forked processes. Killing a forked process is unsafe and has
  unpredictable results. See &quot;<b>kill()</b>&quot;, above.
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<ul class="Bl-bullet">
  <li>Having pseudo-process IDs be negative integers breaks down for the integer
      <span class="Li">&quot;-1&quot;</span> because the <b>wait()</b> and
      <b>waitpid()</b> functions treat this number as being special. The tacit
      assumption in the current implementation is that the system never
      allocates a thread ID of <span class="Li">1</span> for user threads. A
      better representation for pseudo-process IDs will be implemented in
      future.</li>
  <li>In certain cases, the OS-level handles created by the <b>pipe()</b>,
      <b>socket()</b>, and <b>accept()</b> operators are apparently not
      duplicated accurately in pseudo-processes. This only happens in some
      situations, but where it does happen, it may result in deadlocks between
      the read and write ends of pipe handles, or inability to send or receive
      data across socket handles.</li>
  <li>This document may be incomplete in some respects.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Support for concurrent interpreters and the <b>fork()</b> emulation was
  implemented by ActiveState, with funding from Microsoft Corporation.
<p class="Pp">This document is authored and maintained by Gurusamy Sarathy
    &lt;gsar@activestate.com&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
&quot;fork&quot; in perlfunc, perlipc
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>

	</div>
	<div class=footer>
		<p>Copyright 2020 Scott Court</p>
	</div>
	</div>
</body>
