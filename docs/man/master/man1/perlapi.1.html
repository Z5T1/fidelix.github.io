
<!DOCTYPE HTML>
<head>
	<title>/usr/share/man/man1/perlapi.1</title>		<link rel='stylesheet' href='/mandoc.css' />
	<link rel='stylesheet' href='/style.css' />
</head>
<body>
	<div class=contents>
	<div class=header>
	<h1>The Fidelix Linux Distribution</h1>
	<h2>Simple, Stable, and Secure</h2>
	</div>
<div class=menubar>
	<ul>
		<li><a href=/>News</a></li>
		<li><a href=/about.html>About</a></li>
		<li><a href=https://github.com/Z5T1/fidelix/releases>Download</a></li>
		<div class=dropdown>
			<li><a href=#>Documentation</a></li>
			<ul class=dropdown-content>
				<li><a href=/handbook/>Handbook</a></li>
				<li><a href=/man/>Manual Pages</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Development</a></li>
			<ul class=dropdown-content>
				<li><a href=https://github.com/Z5T1/fidelix>GitHub</a></li>
			</ul>
		</div>
	</ul>
</div>


	<div class=body><table class="head">
  <tr>
    <td class="head-ltitle">PERLAPI(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLAPI(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlapi - autogenerated documentation for the perl public API
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This file contains the documentation of the perl public API generated by
  <i>embed.pl</i>, specifically a listing of functions, macros, flags, and
  variables that may be used by extension writers. At the end is a list of
  functions which have yet to be documented. The interfaces of those are subject
  to change without notice. Anything not listed here is not part of the public
  API, and should not be used by extension writers at all. For these reasons,
  blindly using functions listed in proto.h is to be avoided when writing
  extensions.
<p class="Pp">In Perl, unlike C, a string of characters may generally contain
    embedded <span class="Li">&quot;NUL&quot;</span> characters. Sometimes in
    the documentation a Perl string is referred to as a &quot;buffer&quot; to
    distinguish it from a C string, but sometimes they are both just referred to
    as strings.</p>
<p class="Pp">Note that all Perl API global variables must be referenced with
    the <span class="Li">&quot;PL_&quot;</span> prefix. Again, those not listed
    here are not to be used by extension writers, and can be changed or removed
    without notice; same with macros. Some macros are provided for compatibility
    with the older, unadorned names, but this support may be disabled in a
    future release.</p>
<p class="Pp">Perl was originally written to handle US-ASCII only (that is
    characters whose ordinal numbers are in the range 0 - 127). And
    documentation and comments may still use the term ASCII, when sometimes in
    fact the entire range from 0 - 255 is meant.</p>
<p class="Pp">The non-ASCII characters below 256 can have various meanings,
    depending on various things. (See, most notably, perllocale.) But usually
    the whole range can be referred to as ISO-8859-1. Often, the term
    &quot;Latin-1&quot; (or &quot;Latin1&quot;) is used as an equivalent for
    ISO-8859-1. But some people treat &quot;Latin1&quot; as referring just to
    the characters in the range 128 through 255, or somethimes from 160 through
    255. This documentation uses &quot;Latin1&quot; and &quot;Latin-1&quot; to
    refer to all 256 characters.</p>
<p class="Pp">Note that Perl can be compiled and run under either ASCII or
    EBCDIC (See perlebcdic). Most of the documentation (and even comments in the
    code) ignore the EBCDIC possibility. For almost all purposes the differences
    are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC
    is used to encode Unicode strings, and so whenever this documentation refers
    to <span class="Li">&quot;utf8&quot;</span> (and variants of that name,
    including in function names), it also (essentially transparently) means
    <span class="Li">&quot;UTF-EBCDIC&quot;</span>. But the ordinals of
    characters differ between ASCII, EBCDIC, and the UTF- encodings, and a
    string encoded in UTF-EBCDIC may occupy a different number of bytes than in
    UTF-8.</p>
<p class="Pp">The listing below is alphabetical, case insensitive.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Array_Manipulation_Functions"><a class="permalink" href="#Array_Manipulation_Functions">Array
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>av_clear</dt>
  <dd>Frees the all the elements of an array, leaving it empty. The XS
      equivalent of <span class="Li">&quot;@array = ()&quot;</span>. See also
      &quot;av_undef&quot;.
    <p class="Pp">Note that it is possible that the actions of a destructor
        called directly or indirectly by freeing an element of the array could
        cause the reference count of the array itself to be reduced (e.g. by
        deleting an entry in the symbol table). So it is a possibility that the
        AV could have been freed (or even reallocated) on return from the call
        unless you hold a reference to it.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_clear(AV *av)
    </pre>
  </dd>
  <dt>av_create_and_push</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Push an SV onto the end of the array, creating the array if
        necessary. A small internal helper function to remove a commonly
        duplicated idiom.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_create_and_push(AV **const avp,
                                   SV *const val)
    </pre>
  </dd>
  <dt>av_create_and_unshift_one</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Unshifts an SV onto the beginning of the array, creating the
        array if necessary. A small internal helper function to remove a
        commonly duplicated idiom.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    av_create_and_unshift_one(AV **const avp,
                                          SV *const val)
    </pre>
  </dd>
  <dt>av_delete</dt>
  <dd>Deletes the element indexed by <span class="Li">&quot;key&quot;</span>
      from the array, makes the element mortal, and returns it. If
      <span class="Li">&quot;flags&quot;</span> equals
      <span class="Li">&quot;G_DISCARD&quot;</span>, the element is freed and
      NULL is returned. NULL is also returned if
      <span class="Li">&quot;key&quot;</span> is out of range.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;splice(@myarray,&#x00A0;$key,&#x00A0;1,&#x00A0;undef)&quot;</span>
        (with the <span class="Li">&quot;splice&quot;</span> in void context if
        <span class="Li">&quot;G_DISCARD&quot;</span> is present).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     av_delete(AV *av, SSize_t key, I32 flags)
    </pre>
  </dd>
  <dt>av_exists</dt>
  <dd>Returns true if the element indexed by
      <span class="Li">&quot;key&quot;</span> has been initialized.
    <p class="Pp">This relies on the fact that uninitialized array elements are
        set to <span class="Li">&quot;NULL&quot;</span>.</p>
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;exists($myarray[$key])&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    av_exists(AV *av, SSize_t key)
    </pre>
  </dd>
  <dt>av_extend</dt>
  <dd>Pre-extend an array. The <span class="Li">&quot;key&quot;</span> is the
      index to which the array should be extended.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_extend(AV *av, SSize_t key)
    </pre>
  </dd>
  <dt>av_fetch</dt>
  <dd>Returns the SV at the specified index in the array. The
      <span class="Li">&quot;key&quot;</span> is the index. If lval is true, you
      are guaranteed to get a real SV back (in case it wasn't real before),
      which you can then modify. Check that the return value is non-null before
      dereferencing it to a <span class="Li">&quot;SV*&quot;</span>.
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied arrays.</p>
    <p class="Pp">The rough perl equivalent is
        <span class="Li">$myarray[$key]</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    av_fetch(AV *av, SSize_t key, I32 lval)
    </pre>
  </dd>
  <dt>AvFILL</dt>
  <dd>Same as <span class="Li">&quot;av_top_index()&quot;</span> or
      <span class="Li">&quot;av_tindex()&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     AvFILL(AV* av)
    </pre>
  </dd>
  <dt>av_fill</dt>
  <dd>Set the highest index in the array to the given number, equivalent to
      Perl's <span class="Li">&quot;$#array&#x00A0;=&#x00A0;$fill;&quot;</span>.
    <p class="Pp">The number of elements in the array will be
        <span class="Li">&quot;fill&#x00A0;+&#x00A0;1&quot;</span> after
        <span class="Li">&quot;av_fill()&quot;</span> returns. If the array was
        previously shorter, then the additional elements appended are set to
        NULL. If the array was longer, then the excess elements are freed.
        <span class="Li">&quot;av_fill(av,&#x00A0;-1)&quot;</span> is the same
        as <span class="Li">&quot;av_clear(av)&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_fill(AV *av, SSize_t fill)
    </pre>
  </dd>
  <dt>av_len</dt>
  <dd>Same as &quot;av_top_index&quot;. Note that, unlike what the name implies,
      it returns the highest index in the array, so to get the size of the array
      you need to use
      <span class="Li">&quot;av_len(av)&#x00A0;+&#x00A0;1&quot;</span>. This is
      unlike &quot;sv_len&quot;, which returns what you would expect.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t av_len(AV *av)
    </pre>
  </dd>
  <dt>av_make</dt>
  <dd>Creates a new AV and populates it with a list of SVs. The SVs are copied
      into the array, so they may be freed after the call to
      <span class="Li">&quot;av_make&quot;</span>. The new AV will have a
      reference count of 1.
    <p class="Pp">Perl equivalent: <span class="Li">&quot;my @new_array =
        ($scalar1, $scalar2, $scalar3...);&quot;</span></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        AV*     av_make(SSize_t size, SV **strp)
    </pre>
  </dd>
  <dt>av_pop</dt>
  <dd>Removes one SV from the end of the array, reducing its size by one and
      returning the SV (transferring control of one reference count) to the
      caller. Returns <span class="Li">&amp;PL_sv_undef</span> if the array is
      empty.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;pop(@myarray);&quot;</span></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     av_pop(AV *av)
    </pre>
  </dd>
  <dt>av_push</dt>
  <dd>Pushes an SV (transferring control of one reference count) onto the end of
      the array. The array will grow automatically to accommodate the addition.
    <p class="Pp">Perl equivalent: <span class="Li">&quot;push @myarray,
        $val;&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_push(AV *av, SV *val)
    </pre>
  </dd>
  <dt>av_shift</dt>
  <dd>Removes one SV from the start of the array, reducing its size by one and
      returning the SV (transferring control of one reference count) to the
      caller. Returns <span class="Li">&amp;PL_sv_undef</span> if the array is
      empty.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;shift(@myarray);&quot;</span></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     av_shift(AV *av)
    </pre>
  </dd>
  <dt>av_store</dt>
  <dd>Stores an SV in an array. The array index is specified as
      <span class="Li">&quot;key&quot;</span>. The return value will be
      <span class="Li">&quot;NULL&quot;</span> if the operation failed or if the
      value did not need to be actually stored within the array (as in the case
      of tied arrays). Otherwise, it can be dereferenced to get the
      <span class="Li">&quot;SV*&quot;</span> that was stored there (=
      <span class="Li">&quot;val&quot;</span>)).
    <p class="Pp">Note that the caller is responsible for suitably incrementing
        the reference count of <span class="Li">&quot;val&quot;</span> before
        the call, and decrementing it if the function returned
        <span class="Li">&quot;NULL&quot;</span>.</p>
    <p class="Pp">Approximate Perl equivalent:
        <span class="Li">&quot;splice(@myarray, $key, 1, $val)&quot;</span>.</p>
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied arrays.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    av_store(AV *av, SSize_t key, SV *val)
    </pre>
  </dd>
  <dt>av_tindex</dt>
  <dd>Same as <span class="Li">&quot;av_top_index()&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     av_tindex(AV* av)
    </pre>
  </dd>
  <dt>av_top_index</dt>
  <dd>Returns the highest index in the array. The number of elements in the
      array is
      <span class="Li">&quot;av_top_index(av)&#x00A0;+&#x00A0;1&quot;</span>.
      Returns -1 if the array is empty.
    <p class="Pp">The Perl equivalent for this is
        <span class="Li">$#myarray</span>.</p>
    <p class="Pp">(A slightly shorter form is
        <span class="Li">&quot;av_tindex&quot;</span>.)</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t av_top_index(AV *av)
    </pre>
  </dd>
  <dt>av_undef</dt>
  <dd>Undefines the array. The XS equivalent of
      <span class="Li">&quot;undef(@array)&quot;</span>.
    <p class="Pp">As well as freeing all the elements of the array (like
        <span class="Li">&quot;av_clear()&quot;</span>), this also frees the
        memory used by the av to store its list of scalars.</p>
    <p class="Pp">See &quot;av_clear&quot; for a note about the array possibly
        being invalid on return.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_undef(AV *av)
    </pre>
  </dd>
  <dt>av_unshift</dt>
  <dd>Unshift the given number of <span class="Li">&quot;undef&quot;</span>
      values onto the beginning of the array. The array will grow automatically
      to accommodate the addition.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;unshift&#x00A0;@myarray,&#x00A0;((undef)&#x00A0;x&#x00A0;$num);&quot;</span></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    av_unshift(AV *av, SSize_t num)
    </pre>
  </dd>
  <dt>get_av</dt>
  <dd>Returns the AV of the specified Perl global or package array with the
      given name (so it won't work on lexical variables).
      <span class="Li">&quot;flags&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchpv&quot;</span>. If
      <span class="Li">&quot;GV_ADD&quot;</span> is set and the Perl variable
      does not exist then it will be created. If
      <span class="Li">&quot;flags&quot;</span> is zero and the variable does
      not exist then NULL is returned.
    <p class="Pp">Perl equivalent:
        <span class="Li">&quot;@{&quot;$name&quot;}&quot;</span>.</p>
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        AV*     get_av(const char *name, I32 flags)
    </pre>
  </dd>
  <dt>newAV</dt>
  <dd>Creates a new AV. The reference count is set to 1.
    <p class="Pp">Perl equivalent: <span class="Li">&quot;my
        @array;&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        AV*     newAV()
    </pre>
  </dd>
  <dt>sortsv</dt>
  <dd>In-place sort an array of SV pointers with the given comparison routine.
    <p class="Pp">Currently this always uses mergesort. See
        <span class="Li">&quot;sortsv_flags&quot;</span> for a more flexible
        routine.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sortsv(SV** array, size_t num_elts,
                       SVCOMPARE_t cmp)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Callback_Functions"><a class="permalink" href="#Callback_Functions">Callback
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>call_argv</dt>
  <dd>Performs a callback to the specified named and package-scoped Perl
      subroutine with <span class="Li">&quot;argv&quot;</span> (a
      <span class="Li">&quot;NULL&quot;</span>-terminated array of strings) as
      arguments. See perlcall.
    <p class="Pp">Approximate Perl equivalent:
        <span class="Li">&quot;&amp;{&quot;$sub_name&quot;}(@$argv)&quot;</span>.</p>
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     call_argv(const char* sub_name, I32 flags,
                          char** argv)
    </pre>
  </dd>
  <dt>call_method</dt>
  <dd>Performs a callback to the specified Perl method. The blessed object must
      be on the stack. See perlcall.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     call_method(const char* methname, I32 flags)
    </pre>
  </dd>
  <dt>call_pv</dt>
  <dd>Performs a callback to the specified Perl sub. See perlcall.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     call_pv(const char* sub_name, I32 flags)
    </pre>
  </dd>
  <dt>call_sv</dt>
  <dd>Performs a callback to the Perl sub specified by the SV.
    <p class="Pp">If neither the <span class="Li">&quot;G_METHOD&quot;</span>
        nor <span class="Li">&quot;G_METHOD_NAMED&quot;</span> flag is supplied,
        the SV may be any of a CV, a GV, a reference to a CV, a reference to a
        GV or <span class="Li">&quot;SvPV(sv)&quot;</span> will be used as the
        name of the sub to call.</p>
    <p class="Pp">If the <span class="Li">&quot;G_METHOD&quot;</span> flag is
        supplied, the SV may be a reference to a CV or
        <span class="Li">&quot;SvPV(sv)&quot;</span> will be used as the name of
        the method to call.</p>
    <p class="Pp">If the <span class="Li">&quot;G_METHOD_NAMED&quot;</span> flag
        is supplied, <span class="Li">&quot;SvPV(sv)&quot;</span> will be used
        as the name of the method to call.</p>
    <p class="Pp">Some other values are treated specially for internal use and
        should not be depended on.</p>
    <p class="Pp">See perlcall.</p>
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     call_sv(SV* sv, volatile I32 flags)
    </pre>
  </dd>
  <dt>ENTER</dt>
  <dd>Opening bracket on a callback. See
      <span class="Li">&quot;LEAVE&quot;</span> and perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                ENTER;
    </pre>
  </dd>
  <dt>ENTER_with_name(name)</dt>
  <dd>Same as <span class="Li">&quot;ENTER&quot;</span>, but when debugging is
      enabled it also associates the given literal string with the new scope.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                ENTER_with_name(name);
    </pre>
  </dd>
  <dt>eval_pv</dt>
  <dd>Tells Perl to <span class="Li">&quot;eval&quot;</span> the given string in
      scalar context and return an SV* result.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     eval_pv(const char* p, I32 croak_on_error)
    </pre>
  </dd>
  <dt>eval_sv</dt>
  <dd>Tells Perl to <span class="Li">&quot;eval&quot;</span> the string in the
      SV. It supports the same flags as
      <span class="Li">&quot;call_sv&quot;</span>, with the obvious exception of
      <span class="Li">&quot;G_EVAL&quot;</span>. See perlcall.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     eval_sv(SV* sv, I32 flags)
    </pre>
  </dd>
  <dt>FREETMPS</dt>
  <dd>Closing bracket for temporaries on a callback. See
      <span class="Li">&quot;SAVETMPS&quot;</span> and perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                FREETMPS;
    </pre>
  </dd>
  <dt>LEAVE</dt>
  <dd>Closing bracket on a callback. See
      <span class="Li">&quot;ENTER&quot;</span> and perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                LEAVE;
    </pre>
  </dd>
  <dt>LEAVE_with_name(name)</dt>
  <dd>Same as <span class="Li">&quot;LEAVE&quot;</span>, but when debugging is
      enabled it first checks that the scope has the given name.
      <span class="Li">&quot;name&quot;</span> must be a literal string.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                LEAVE_with_name(name);
    </pre>
  </dd>
  <dt>SAVETMPS</dt>
  <dd>Opening bracket for temporaries on a callback. See
      <span class="Li">&quot;FREETMPS&quot;</span> and perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                SAVETMPS;
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Character_case_changing"><a class="permalink" href="#Character_case_changing">Character
  case changing</a></h1>
Perl uses &quot;full&quot; Unicode case mappings. This means that converting a
  single character to another case may result in a sequence of more than one
  character. For example, the uppercase of
  <span class="Li">&quot;ss&quot;</span> (LATIN SMALL LETTER SHARP S) is the two
  character sequence <span class="Li">&quot;SS&quot;</span>. This presents some
  complications The lowercase of all characters in the range 0..255 is a single
  character, and thus <span class="Li">&quot;toLOWER_L1&quot;</span> is
  furnished. But, <span class="Li">&quot;toUPPER_L1&quot;</span> can't exist, as
  it couldn't return a valid result for all legal inputs. Instead
  <span class="Li">&quot;toUPPER_uvchr&quot;</span> has an API that does allow
  every possible legal result to be returned.) Likewise no other function that
  is crippled by not being able to give the correct results for the full range
  of possible inputs has been implemented here.
<dl class="Bl-tag">
  <dt>toFOLD</dt>
  <dd>Converts the specified character to foldcase. If the input is anything but
      an ASCII uppercase character, that input character itself is returned.
      Variant <span class="Li">&quot;toFOLD_A&quot;</span> is equivalent. (There
      is no equivalent <span class="Li">&quot;to_FOLD_L1&quot;</span> for the
      full Latin1 range, as the full generality of &quot;toFOLD_uvchr&quot; is
      needed there.)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8      toFOLD(U8 ch)
    </pre>
  </dd>
  <dt>toFOLD_utf8</dt>
  <dd>This is like <span class="Li">&quot;toFOLD_utf8_safe&quot;</span>, but
      doesn't have the <span class="Li">&quot;e&quot;</span> parameter The
      function therefore can't check if it is reading beyond the end of the
      string. Starting in Perl v5.30, it will take the
      <span class="Li">&quot;e&quot;</span> parameter, becoming a synonym for
      <span class="Li">&quot;toFOLD_utf8_safe&quot;</span>. At that time every
      program that uses it will have to be changed to successfully compile. In
      the meantime, the first runtime call to
      <span class="Li">&quot;toFOLD_utf8&quot;</span> from each call point in
      the program will raise a deprecation warning, enabled by default. You can
      convert your program now to use
      <span class="Li">&quot;toFOLD_utf8_safe&quot;</span>, and avoid the
      warnings, and get an extra measure of protection, or you can wait until
      v5.30, when you'll be forced to add the
      <span class="Li">&quot;e&quot;</span> parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      toFOLD_utf8(U8* p, U8* s, STRLEN* lenp)
    </pre>
  </dd>
  <dt>toFOLD_utf8_safe</dt>
  <dd>Converts the first UTF-8 encoded character in the sequence starting at
      <span class="Li">&quot;p&quot;</span> and extending no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> to its foldcase
      version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. Note that the buffer pointed to
      by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      foldcase version may be longer than the original character.
    <p class="Pp">The first code point of the foldcased version is returned (but
        note, as explained at the top of this section, that there may be
      more).</p>
    <p class="Pp">The suffix <span class="Li">&quot;_safe&quot;</span> in the
        function's name indicates that it will not attempt to read beyond
        <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span>, provided that
        the constraint
        <span class="Li">&quot;s&#x00A0;&lt;&#x00A0;e&quot;</span> is true (this
        is asserted for in <span class="Li">&quot;-DDEBUGGING&quot;</span>
        builds). If the UTF-8 for the input character is malformed in some way,
        the program may croak, or the function may return the REPLACEMENT
        CHARACTER, at the discretion of the implementation, and subject to
        change in future releases.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      toFOLD_utf8_safe(U8* p, U8* e, U8* s,
                                 STRLEN* lenp)
    </pre>
  </dd>
  <dt>toFOLD_uvchr</dt>
  <dd>Converts the code point <span class="Li">&quot;cp&quot;</span> to its
      foldcase version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. The code point is interpreted as
      native if less than 256; otherwise as Unicode. Note that the buffer
      pointed to by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      foldcase version may be longer than the original character.
    <p class="Pp">The first code point of the foldcased version is returned (but
        note, as explained at the top of this section, that there may be
      more).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      toFOLD_uvchr(UV cp, U8* s, STRLEN* lenp)
    </pre>
  </dd>
  <dt>toLOWER</dt>
  <dd>Converts the specified character to lowercase. If the input is anything
      but an ASCII uppercase character, that input character itself is returned.
      Variant <span class="Li">&quot;toLOWER_A&quot;</span> is equivalent.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8      toLOWER(U8 ch)
    </pre>
  </dd>
  <dt>toLOWER_L1</dt>
  <dd>Converts the specified Latin1 character to lowercase. The results are
      undefined if the input doesn't fit in a byte.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8      toLOWER_L1(U8 ch)
    </pre>
  </dd>
  <dt>toLOWER_LC</dt>
  <dd>Converts the specified character to lowercase using the current locale's
      rules, if possible; otherwise returns the input character itself.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8      toLOWER_LC(U8 ch)
    </pre>
  </dd>
  <dt>toLOWER_utf8</dt>
  <dd>This is like <span class="Li">&quot;toLOWER_utf8_safe&quot;</span>, but
      doesn't have the <span class="Li">&quot;e&quot;</span> parameter The
      function therefore can't check if it is reading beyond the end of the
      string. Starting in Perl v5.30, it will take the
      <span class="Li">&quot;e&quot;</span> parameter, becoming a synonym for
      <span class="Li">&quot;toLOWER_utf8_safe&quot;</span>. At that time every
      program that uses it will have to be changed to successfully compile. In
      the meantime, the first runtime call to
      <span class="Li">&quot;toLOWER_utf8&quot;</span> from each call point in
      the program will raise a deprecation warning, enabled by default. You can
      convert your program now to use
      <span class="Li">&quot;toLOWER_utf8_safe&quot;</span>, and avoid the
      warnings, and get an extra measure of protection, or you can wait until
      v5.30, when you'll be forced to add the
      <span class="Li">&quot;e&quot;</span> parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      toLOWER_utf8(U8* p, U8* s, STRLEN* lenp)
    </pre>
  </dd>
  <dt>toLOWER_utf8_safe</dt>
  <dd>Converts the first UTF-8 encoded character in the sequence starting at
      <span class="Li">&quot;p&quot;</span> and extending no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> to its lowercase
      version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. Note that the buffer pointed to
      by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      lowercase version may be longer than the original character.
    <p class="Pp">The first code point of the lowercased version is returned
        (but note, as explained at the top of this section, that there may be
        more).</p>
    <p class="Pp">The suffix <span class="Li">&quot;_safe&quot;</span> in the
        function's name indicates that it will not attempt to read beyond
        <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span>, provided that
        the constraint
        <span class="Li">&quot;s&#x00A0;&lt;&#x00A0;e&quot;</span> is true (this
        is asserted for in <span class="Li">&quot;-DDEBUGGING&quot;</span>
        builds). If the UTF-8 for the input character is malformed in some way,
        the program may croak, or the function may return the REPLACEMENT
        CHARACTER, at the discretion of the implementation, and subject to
        change in future releases.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      toLOWER_utf8_safe(U8* p, U8* e, U8* s,
                                  STRLEN* lenp)
    </pre>
  </dd>
  <dt>toLOWER_uvchr</dt>
  <dd>Converts the code point <span class="Li">&quot;cp&quot;</span> to its
      lowercase version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. The code point is interpreted as
      native if less than 256; otherwise as Unicode. Note that the buffer
      pointed to by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      lowercase version may be longer than the original character.
    <p class="Pp">The first code point of the lowercased version is returned
        (but note, as explained at the top of this section, that there may be
        more).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      toLOWER_uvchr(UV cp, U8* s, STRLEN* lenp)
    </pre>
  </dd>
  <dt>toTITLE</dt>
  <dd>Converts the specified character to titlecase. If the input is anything
      but an ASCII lowercase character, that input character itself is returned.
      Variant <span class="Li">&quot;toTITLE_A&quot;</span> is equivalent.
      (There is no <span class="Li">&quot;toTITLE_L1&quot;</span> for the full
      Latin1 range, as the full generality of &quot;toTITLE_uvchr&quot; is
      needed there. Titlecase is not a concept used in locale handling, so there
      is no functionality for that.)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8      toTITLE(U8 ch)
    </pre>
  </dd>
  <dt>toTITLE_utf8</dt>
  <dd>This is like <span class="Li">&quot;toLOWER_utf8_safe&quot;</span>, but
      doesn't have the <span class="Li">&quot;e&quot;</span> parameter The
      function therefore can't check if it is reading beyond the end of the
      string. Starting in Perl v5.30, it will take the
      <span class="Li">&quot;e&quot;</span> parameter, becoming a synonym for
      <span class="Li">&quot;toTITLE_utf8_safe&quot;</span>. At that time every
      program that uses it will have to be changed to successfully compile. In
      the meantime, the first runtime call to
      <span class="Li">&quot;toTITLE_utf8&quot;</span> from each call point in
      the program will raise a deprecation warning, enabled by default. You can
      convert your program now to use
      <span class="Li">&quot;toTITLE_utf8_safe&quot;</span>, and avoid the
      warnings, and get an extra measure of protection, or you can wait until
      v5.30, when you'll be forced to add the
      <span class="Li">&quot;e&quot;</span> parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      toTITLE_utf8(U8* p, U8* s, STRLEN* lenp)
    </pre>
  </dd>
  <dt>toTITLE_utf8_safe</dt>
  <dd>Converts the first UTF-8 encoded character in the sequence starting at
      <span class="Li">&quot;p&quot;</span> and extending no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> to its titlecase
      version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. Note that the buffer pointed to
      by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      titlecase version may be longer than the original character.
    <p class="Pp">The first code point of the titlecased version is returned
        (but note, as explained at the top of this section, that there may be
        more).</p>
    <p class="Pp">The suffix <span class="Li">&quot;_safe&quot;</span> in the
        function's name indicates that it will not attempt to read beyond
        <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span>, provided that
        the constraint
        <span class="Li">&quot;s&#x00A0;&lt;&#x00A0;e&quot;</span> is true (this
        is asserted for in <span class="Li">&quot;-DDEBUGGING&quot;</span>
        builds). If the UTF-8 for the input character is malformed in some way,
        the program may croak, or the function may return the REPLACEMENT
        CHARACTER, at the discretion of the implementation, and subject to
        change in future releases.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      toTITLE_utf8_safe(U8* p, U8* e, U8* s,
                                  STRLEN* lenp)
    </pre>
  </dd>
  <dt>toTITLE_uvchr</dt>
  <dd>Converts the code point <span class="Li">&quot;cp&quot;</span> to its
      titlecase version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. The code point is interpreted as
      native if less than 256; otherwise as Unicode. Note that the buffer
      pointed to by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      titlecase version may be longer than the original character.
    <p class="Pp">The first code point of the titlecased version is returned
        (but note, as explained at the top of this section, that there may be
        more).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      toTITLE_uvchr(UV cp, U8* s, STRLEN* lenp)
    </pre>
  </dd>
  <dt>toUPPER</dt>
  <dd>Converts the specified character to uppercase. If the input is anything
      but an ASCII lowercase character, that input character itself is returned.
      Variant <span class="Li">&quot;toUPPER_A&quot;</span> is equivalent.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8      toUPPER(U8 ch)
    </pre>
  </dd>
  <dt>toUPPER_utf8</dt>
  <dd>This is like <span class="Li">&quot;toUPPER_utf8_safe&quot;</span>, but
      doesn't have the <span class="Li">&quot;e&quot;</span> parameter The
      function therefore can't check if it is reading beyond the end of the
      string. Starting in Perl v5.30, it will take the
      <span class="Li">&quot;e&quot;</span> parameter, becoming a synonym for
      <span class="Li">&quot;toUPPER_utf8_safe&quot;</span>. At that time every
      program that uses it will have to be changed to successfully compile. In
      the meantime, the first runtime call to
      <span class="Li">&quot;toUPPER_utf8&quot;</span> from each call point in
      the program will raise a deprecation warning, enabled by default. You can
      convert your program now to use
      <span class="Li">&quot;toUPPER_utf8_safe&quot;</span>, and avoid the
      warnings, and get an extra measure of protection, or you can wait until
      v5.30, when you'll be forced to add the
      <span class="Li">&quot;e&quot;</span> parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      toUPPER_utf8(U8* p, U8* s, STRLEN* lenp)
    </pre>
  </dd>
  <dt>toUPPER_utf8_safe</dt>
  <dd>Converts the first UTF-8 encoded character in the sequence starting at
      <span class="Li">&quot;p&quot;</span> and extending no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> to its uppercase
      version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. Note that the buffer pointed to
      by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      uppercase version may be longer than the original character.
    <p class="Pp">The first code point of the uppercased version is returned
        (but note, as explained at the top of this section, that there may be
        more).</p>
    <p class="Pp">The suffix <span class="Li">&quot;_safe&quot;</span> in the
        function's name indicates that it will not attempt to read beyond
        <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span>, provided that
        the constraint
        <span class="Li">&quot;s&#x00A0;&lt;&#x00A0;e&quot;</span> is true (this
        is asserted for in <span class="Li">&quot;-DDEBUGGING&quot;</span>
        builds). If the UTF-8 for the input character is malformed in some way,
        the program may croak, or the function may return the REPLACEMENT
        CHARACTER, at the discretion of the implementation, and subject to
        change in future releases.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      toUPPER_utf8_safe(U8* p, U8* e, U8* s,
                                  STRLEN* lenp)
    </pre>
  </dd>
  <dt>toUPPER_uvchr</dt>
  <dd>Converts the code point <span class="Li">&quot;cp&quot;</span> to its
      uppercase version, and stores that in UTF-8 in
      <span class="Li">&quot;s&quot;</span>, and its length in bytes in
      <span class="Li">&quot;lenp&quot;</span>. The code point is interpreted as
      native if less than 256; otherwise as Unicode. Note that the buffer
      pointed to by <span class="Li">&quot;s&quot;</span> needs to be at least
      <span class="Li">&quot;UTF8_MAXBYTES_CASE+1&quot;</span> bytes since the
      uppercase version may be longer than the original character.
    <p class="Pp">The first code point of the uppercased version is returned
        (but note, as explained at the top of this section, that there may be
        more.)</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      toUPPER_uvchr(UV cp, U8* s, STRLEN* lenp)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Character_classification"><a class="permalink" href="#Character_classification">Character
  classification</a></h1>
This section is about functions (really macros) that classify characters into
  types, such as punctuation versus alphabetic, etc. Most of these are analogous
  to regular expression character classes. (See &quot;POSIX Character
  Classes&quot; in perlrecharclass.) There are several variants for each class.
  (Not all macros have all variants; each item below lists the ones valid for
  it.) None are affected by <span class="Li">&quot;use bytes&quot;</span>, and
  only the ones with <span class="Li">&quot;LC&quot;</span> in the name are
  affected by the current locale.
<p class="Pp">The base function, e.g.,
    <span class="Li">&quot;isALPHA()&quot;</span>, takes an octet (either a
    <span class="Li">&quot;char&quot;</span> or a
    <span class="Li">&quot;U8&quot;</span>) as input and returns a boolean as to
    whether or not the character represented by that octet is (or on non-ASCII
    platforms, corresponds to) an ASCII character in the named class based on
    platform, Unicode, and Perl rules. If the input is a number that doesn't fit
    in an octet, FALSE is returned.</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_A&quot;</span>
    (e.g., <span class="Li">&quot;isALPHA_A()&quot;</span>) is identical to the
    base function with no suffix <span class="Li">&quot;_A&quot;</span>. This
    variant is used to emphasize by its name that only ASCII-range characters
    can return TRUE.</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_L1&quot;</span>
    imposes the Latin-1 (or EBCDIC equivalent) character set onto the platform.
    That is, the code points that are ASCII are unaffected, since ASCII is a
    subset of Latin-1. But the non-ASCII code points are treated as if they are
    Latin-1 characters. For example,
    <span class="Li">&quot;isWORDCHAR_L1()&quot;</span> will return true when
    called with the code point 0xDF, which is a word character in both ASCII and
    EBCDIC (though it represents different characters in each).</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_uvchr&quot;</span>
    is like the
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_L1&quot;</span>
    variant, but accepts any UV code point as input. If the code point is larger
    than 255, Unicode rules are used to determine if it is in the character
    class. For example,
    <span class="Li">&quot;isWORDCHAR_uvchr(0x100)&quot;</span> returns TRUE,
    since 0x100 is LATIN CAPITAL LETTER A WITH MACRON in Unicode, and is a word
    character.</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_utf8_safe&quot;</span>
    is like
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_uvchr&quot;</span>,
    but is used for UTF-8 encoded strings. Each call classifies one character,
    even if the string contains many. This variant takes two parameters. The
    first, <span class="Li">&quot;p&quot;</span>, is a pointer to the first byte
    of the character to be classified. (Recall that it may take more than one
    byte to represent a character in UTF-8 strings.) The second parameter,
    <span class="Li">&quot;e&quot;</span>, points to anywhere in the string
    beyond the first character, up to one byte past the end of the entire
    string. The suffix <span class="Li">&quot;_safe&quot;</span> in the
    function's name indicates that it will not attempt to read beyond
    <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span>, provided that the
    constraint <span class="Li">&quot;s&#x00A0;&lt;&#x00A0;e&quot;</span> is
    true (this is asserted for in
    <span class="Li">&quot;-DDEBUGGING&quot;</span> builds). If the UTF-8 for
    the input character is malformed in some way, the program may croak, or the
    function may return FALSE, at the discretion of the implementation, and
    subject to change in future releases.</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_utf8&quot;</span>
    is like
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_utf8_safe&quot;</span>,
    but takes just a single parameter, <span class="Li">&quot;p&quot;</span>,
    which has the same meaning as the corresponding parameter does in
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_utf8_safe&quot;</span>.
    The function therefore can't check if it is reading beyond the end of the
    string. Starting in Perl v5.30, it will take a second parameter, becoming a
    synonym for
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_utf8_safe&quot;</span>.
    At that time every program that uses it will have to be changed to
    successfully compile. In the meantime, the first runtime call to
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_utf8&quot;</span>
    from each call point in the program will raise a deprecation warning,
    enabled by default. You can convert your program now to use
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_utf8_safe&quot;</span>,
    and avoid the warnings, and get an extra measure of protection, or you can
    wait until v5.30, when you'll be forced to add the
    <span class="Li">&quot;e&quot;</span> parameter.</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_LC&quot;</span>
    is like the
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_A&quot;</span>
    and
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_L1&quot;</span>
    variants, but the result is based on the current locale, which is what
    <span class="Li">&quot;LC&quot;</span> in the name stands for. If Perl can
    determine that the current locale is a UTF-8 locale, it uses the published
    Unicode rules; otherwise, it uses the C library function that gives the
    named classification. For example,
    <span class="Li">&quot;isDIGIT_LC()&quot;</span> when not in a UTF-8 locale
    returns the result of calling <span class="Li">&quot;isdigit()&quot;</span>.
    FALSE is always returned if the input won't fit into an octet. On some
    platforms where the C library function is known to be defective, Perl
    changes its result to follow the POSIX standard's rules.</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_LC_uvchr&quot;</span>
    is like
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_LC&quot;</span>,
    but is defined on any UV. It returns the same as
    <span class="Li">&quot;is</span> <i>FOO</i><span class="Li">_LC&quot;</span>
    for input code points less than 256, and returns the hard-coded,
    not-affected-by-locale, Unicode results for larger ones.</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_LC_utf8_safe&quot;</span>
    is like
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_LC_uvchr&quot;</span>,
    but is used for UTF-8 encoded strings. Each call classifies one character,
    even if the string contains many. This variant takes two parameters. The
    first, <span class="Li">&quot;p&quot;</span>, is a pointer to the first byte
    of the character to be classified. (Recall that it may take more than one
    byte to represent a character in UTF-8 strings.) The second parameter,
    <span class="Li">&quot;e&quot;</span>, points to anywhere in the string
    beyond the first character, up to one byte past the end of the entire
    string. The suffix <span class="Li">&quot;_safe&quot;</span> in the
    function's name indicates that it will not attempt to read beyond
    <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span>, provided that the
    constraint <span class="Li">&quot;s&#x00A0;&lt;&#x00A0;e&quot;</span> is
    true (this is asserted for in
    <span class="Li">&quot;-DDEBUGGING&quot;</span> builds). If the UTF-8 for
    the input character is malformed in some way, the program may croak, or the
    function may return FALSE, at the discretion of the implementation, and
    subject to change in future releases.</p>
<p class="Pp">Variant
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_LC_utf8&quot;</span>
    is like
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_LC_utf8_safe&quot;</span>,
    but takes just a single parameter, <span class="Li">&quot;p&quot;</span>,
    which has the same meaning as the corresponding parameter does in
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_LC_utf8_safe&quot;</span>.
    The function therefore can't check if it is reading beyond the end of the
    string. Starting in Perl v5.30, it will take a second parameter, becoming a
    synonym for
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_LC_utf8_safe&quot;</span>.
    At that time every program that uses it will have to be changed to
    successfully compile. In the meantime, the first runtime call to
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_LC_utf8&quot;</span>
    from each call point in the program will raise a deprecation warning,
    enabled by default. You can convert your program now to use
    <span class="Li">&quot;is</span><i>FOO</i><span class="Li">_LC_utf8_safe&quot;</span>,
    and avoid the warnings, and get an extra measure of protection, or you can
    wait until v5.30, when you'll be forced to add the
    <span class="Li">&quot;e&quot;</span> parameter.</p>
<dl class="Bl-tag">
  <dt>isALPHA</dt>
  <dd>Returns a boolean indicating whether the specified character is an
      alphabetic character, analogous to
      <span class="Li">&quot;m/[[:alpha:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isALPHA_A&quot;</span>,
      <span class="Li">&quot;isALPHA_L1&quot;</span>,
      <span class="Li">&quot;isALPHA_uvchr&quot;</span>,
      <span class="Li">&quot;isALPHA_utf8_safe&quot;</span>,
      <span class="Li">&quot;isALPHA_LC&quot;</span>,
      <span class="Li">&quot;isALPHA_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isALPHA_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isALPHA(char ch)
    </pre>
  </dd>
  <dt>isALPHANUMERIC</dt>
  <dd>Returns a boolean indicating whether the specified character is a either
      an alphabetic character or decimal digit, analogous to
      <span class="Li">&quot;m/[[:alnum:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isALPHANUMERIC_A&quot;</span>,
      <span class="Li">&quot;isALPHANUMERIC_L1&quot;</span>,
      <span class="Li">&quot;isALPHANUMERIC_uvchr&quot;</span>,
      <span class="Li">&quot;isALPHANUMERIC_utf8_safe&quot;</span>,
      <span class="Li">&quot;isALPHANUMERIC_LC&quot;</span>,
      <span class="Li">&quot;isALPHANUMERIC_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isALPHANUMERIC_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isALPHANUMERIC(char ch)
    </pre>
  </dd>
  <dt>isASCII</dt>
  <dd>Returns a boolean indicating whether the specified character is one of the
      128 characters in the ASCII character set, analogous to
      <span class="Li">&quot;m/[[:ascii:]]/&quot;</span>. On non-ASCII
      platforms, it returns TRUE iff this character corresponds to an ASCII
      character. Variants <span class="Li">&quot;isASCII_A()&quot;</span> and
      <span class="Li">&quot;isASCII_L1()&quot;</span> are identical to
      <span class="Li">&quot;isASCII()&quot;</span>. See the top of this section
      for an explanation of variants
      <span class="Li">&quot;isASCII_uvchr&quot;</span>,
      <span class="Li">&quot;isASCII_utf8_safe&quot;</span>,
      <span class="Li">&quot;isASCII_LC&quot;</span>,
      <span class="Li">&quot;isASCII_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isASCII_LC_utf8_safe&quot;</span>. Note, however,
      that some platforms do not have the C library routine
      <span class="Li">&quot;isascii()&quot;</span>. In these cases, the
      variants whose names contain <span class="Li">&quot;LC&quot;</span> are
      the same as the corresponding ones without.
    <p class="Pp">Also note, that because all ASCII characters are UTF-8
        invariant (meaning they have the exact same representation (always a
        single byte) whether encoded in UTF-8 or not),
        <span class="Li">&quot;isASCII&quot;</span> will give the correct
        results when called with any byte in any string encoded or not in UTF-8.
        And similarly <span class="Li">&quot;isASCII_utf8_safe&quot;</span> will
        work properly on any string encoded or not in UTF-8.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isASCII(char ch)
    </pre>
  </dd>
  <dt>isBLANK</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      character considered to be a blank, analogous to
      <span class="Li">&quot;m/[[:blank:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isBLANK_A&quot;</span>,
      <span class="Li">&quot;isBLANK_L1&quot;</span>,
      <span class="Li">&quot;isBLANK_uvchr&quot;</span>,
      <span class="Li">&quot;isBLANK_utf8_safe&quot;</span>,
      <span class="Li">&quot;isBLANK_LC&quot;</span>,
      <span class="Li">&quot;isBLANK_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isBLANK_LC_utf8_safe&quot;</span>. Note, however,
      that some platforms do not have the C library routine
      <span class="Li">&quot;isblank()&quot;</span>. In these cases, the
      variants whose names contain <span class="Li">&quot;LC&quot;</span> are
      the same as the corresponding ones without.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isBLANK(char ch)
    </pre>
  </dd>
  <dt>isCNTRL</dt>
  <dd>Returns a boolean indicating whether the specified character is a control
      character, analogous to
      <span class="Li">&quot;m/[[:cntrl:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isCNTRL_A&quot;</span>,
      <span class="Li">&quot;isCNTRL_L1&quot;</span>,
      <span class="Li">&quot;isCNTRL_uvchr&quot;</span>,
      <span class="Li">&quot;isCNTRL_utf8_safe&quot;</span>,
      <span class="Li">&quot;isCNTRL_LC&quot;</span>,
      <span class="Li">&quot;isCNTRL_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isCNTRL_LC_utf8_safe&quot;</span> On EBCDIC
      platforms, you almost always want to use the
      <span class="Li">&quot;isCNTRL_L1&quot;</span> variant.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isCNTRL(char ch)
    </pre>
  </dd>
  <dt>isDIGIT</dt>
  <dd>Returns a boolean indicating whether the specified character is a digit,
      analogous to <span class="Li">&quot;m/[[:digit:]]/&quot;</span>. Variants
      <span class="Li">&quot;isDIGIT_A&quot;</span> and
      <span class="Li">&quot;isDIGIT_L1&quot;</span> are identical to
      <span class="Li">&quot;isDIGIT&quot;</span>. See the top of this section
      for an explanation of variants
      <span class="Li">&quot;isDIGIT_uvchr&quot;</span>,
      <span class="Li">&quot;isDIGIT_utf8_safe&quot;</span>,
      <span class="Li">&quot;isDIGIT_LC&quot;</span>,
      <span class="Li">&quot;isDIGIT_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isDIGIT_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isDIGIT(char ch)
    </pre>
  </dd>
  <dt>isGRAPH</dt>
  <dd>Returns a boolean indicating whether the specified character is a graphic
      character, analogous to
      <span class="Li">&quot;m/[[:graph:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isGRAPH_A&quot;</span>,
      <span class="Li">&quot;isGRAPH_L1&quot;</span>,
      <span class="Li">&quot;isGRAPH_uvchr&quot;</span>,
      <span class="Li">&quot;isGRAPH_utf8_safe&quot;</span>,
      <span class="Li">&quot;isGRAPH_LC&quot;</span>,
      <span class="Li">&quot;isGRAPH_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isGRAPH_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isGRAPH(char ch)
    </pre>
  </dd>
  <dt>isIDCONT</dt>
  <dd>Returns a boolean indicating whether the specified character can be the
      second or succeeding character of an identifier. This is very close to,
      but not quite the same as the official Unicode property
      <span class="Li">&quot;XID_Continue&quot;</span>. The difference is that
      this returns true only if the input character also matches
      &quot;isWORDCHAR&quot;. See the top of this section for an explanation of
      variants <span class="Li">&quot;isIDCONT_A&quot;</span>,
      <span class="Li">&quot;isIDCONT_L1&quot;</span>,
      <span class="Li">&quot;isIDCONT_uvchr&quot;</span>,
      <span class="Li">&quot;isIDCONT_utf8_safe&quot;</span>,
      <span class="Li">&quot;isIDCONT_LC&quot;</span>,
      <span class="Li">&quot;isIDCONT_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isIDCONT_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isIDCONT(char ch)
    </pre>
  </dd>
  <dt>isIDFIRST</dt>
  <dd>Returns a boolean indicating whether the specified character can be the
      first character of an identifier. This is very close to, but not quite the
      same as the official Unicode property
      <span class="Li">&quot;XID_Start&quot;</span>. The difference is that this
      returns true only if the input character also matches
      &quot;isWORDCHAR&quot;. See the top of this section for an explanation of
      variants <span class="Li">&quot;isIDFIRST_A&quot;</span>,
      <span class="Li">&quot;isIDFIRST_L1&quot;</span>,
      <span class="Li">&quot;isIDFIRST_uvchr&quot;</span>,
      <span class="Li">&quot;isIDFIRST_utf8_safe&quot;</span>,
      <span class="Li">&quot;isIDFIRST_LC&quot;</span>,
      <span class="Li">&quot;isIDFIRST_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isIDFIRST_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isIDFIRST(char ch)
    </pre>
  </dd>
  <dt>isLOWER</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      lowercase character, analogous to
      <span class="Li">&quot;m/[[:lower:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isLOWER_A&quot;</span>,
      <span class="Li">&quot;isLOWER_L1&quot;</span>,
      <span class="Li">&quot;isLOWER_uvchr&quot;</span>,
      <span class="Li">&quot;isLOWER_utf8_safe&quot;</span>,
      <span class="Li">&quot;isLOWER_LC&quot;</span>,
      <span class="Li">&quot;isLOWER_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isLOWER_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isLOWER(char ch)
    </pre>
  </dd>
  <dt>isOCTAL</dt>
  <dd>Returns a boolean indicating whether the specified character is an octal
      digit, [0-7]. The only two variants are
      <span class="Li">&quot;isOCTAL_A&quot;</span> and
      <span class="Li">&quot;isOCTAL_L1&quot;</span>; each is identical to
      <span class="Li">&quot;isOCTAL&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isOCTAL(char ch)
    </pre>
  </dd>
  <dt>isPRINT</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      printable character, analogous to
      <span class="Li">&quot;m/[[:print:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isPRINT_A&quot;</span>,
      <span class="Li">&quot;isPRINT_L1&quot;</span>,
      <span class="Li">&quot;isPRINT_uvchr&quot;</span>,
      <span class="Li">&quot;isPRINT_utf8_safe&quot;</span>,
      <span class="Li">&quot;isPRINT_LC&quot;</span>,
      <span class="Li">&quot;isPRINT_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isPRINT_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isPRINT(char ch)
    </pre>
  </dd>
  <dt>isPSXSPC</dt>
  <dd>(short for Posix Space) Starting in 5.18, this is identical in all its
      forms to the corresponding <span class="Li">&quot;isSPACE()&quot;</span>
      macros. The locale forms of this macro are identical to their
      corresponding <span class="Li">&quot;isSPACE()&quot;</span> forms in all
      Perl releases. In releases prior to 5.18, the non-locale forms differ from
      their <span class="Li">&quot;isSPACE()&quot;</span> forms only in that the
      <span class="Li">&quot;isSPACE()&quot;</span> forms don't match a Vertical
      Tab, and the <span class="Li">&quot;isPSXSPC()&quot;</span> forms do.
      Otherwise they are identical. Thus this macro is analogous to what
      <span class="Li">&quot;m/[[:space:]]/&quot;</span> matches in a regular
      expression. See the top of this section for an explanation of variants
      <span class="Li">&quot;isPSXSPC_A&quot;</span>,
      <span class="Li">&quot;isPSXSPC_L1&quot;</span>,
      <span class="Li">&quot;isPSXSPC_uvchr&quot;</span>,
      <span class="Li">&quot;isPSXSPC_utf8_safe&quot;</span>,
      <span class="Li">&quot;isPSXSPC_LC&quot;</span>,
      <span class="Li">&quot;isPSXSPC_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isPSXSPC_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isPSXSPC(char ch)
    </pre>
  </dd>
  <dt>isPUNCT</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      punctuation character, analogous to
      <span class="Li">&quot;m/[[:punct:]]/&quot;</span>. Note that the
      definition of what is punctuation isn't as straightforward as one might
      desire. See &quot;POSIX Character Classes&quot; in perlrecharclass for
      details. See the top of this section for an explanation of variants
      <span class="Li">&quot;isPUNCT_A&quot;</span>,
      <span class="Li">&quot;isPUNCT_L1&quot;</span>,
      <span class="Li">&quot;isPUNCT_uvchr&quot;</span>,
      <span class="Li">&quot;isPUNCT_utf8_safe&quot;</span>,
      <span class="Li">&quot;isPUNCT_LC&quot;</span>,
      <span class="Li">&quot;isPUNCT_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isPUNCT_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isPUNCT(char ch)
    </pre>
  </dd>
  <dt>isSPACE</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      whitespace character. This is analogous to what
      <span class="Li">&quot;m/\s/&quot;</span> matches in a regular expression.
      Starting in Perl 5.18 this also matches what
      <span class="Li">&quot;m/[[:space:]]/&quot;</span> does. Prior to 5.18,
      only the locale forms of this macro (the ones with
      <span class="Li">&quot;LC&quot;</span> in their names) matched precisely
      what <span class="Li">&quot;m/[[:space:]]/&quot;</span> does. In those
      releases, the only difference, in the non-locale variants, was that
      <span class="Li">&quot;isSPACE()&quot;</span> did not match a vertical
      tab. (See &quot;isPSXSPC&quot; for a macro that matches a vertical tab in
      all releases.) See the top of this section for an explanation of variants
      <span class="Li">&quot;isSPACE_A&quot;</span>,
      <span class="Li">&quot;isSPACE_L1&quot;</span>,
      <span class="Li">&quot;isSPACE_uvchr&quot;</span>,
      <span class="Li">&quot;isSPACE_utf8_safe&quot;</span>,
      <span class="Li">&quot;isSPACE_LC&quot;</span>,
      <span class="Li">&quot;isSPACE_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isSPACE_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isSPACE(char ch)
    </pre>
  </dd>
  <dt>isUPPER</dt>
  <dd>Returns a boolean indicating whether the specified character is an
      uppercase character, analogous to
      <span class="Li">&quot;m/[[:upper:]]/&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isUPPER_A&quot;</span>,
      <span class="Li">&quot;isUPPER_L1&quot;</span>,
      <span class="Li">&quot;isUPPER_uvchr&quot;</span>,
      <span class="Li">&quot;isUPPER_utf8_safe&quot;</span>,
      <span class="Li">&quot;isUPPER_LC&quot;</span>,
      <span class="Li">&quot;isUPPER_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isUPPER_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isUPPER(char ch)
    </pre>
  </dd>
  <dt>isWORDCHAR</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      character that is a word character, analogous to what
      <span class="Li">&quot;m/\w/&quot;</span> and
      <span class="Li">&quot;m/[[:word:]]/&quot;</span> match in a regular
      expression. A word character is an alphabetic character, a decimal digit,
      a connecting punctuation character (such as an underscore), or a
      &quot;mark&quot; character that attaches to one of those (like some sort
      of accent). <span class="Li">&quot;isALNUM()&quot;</span> is a synonym
      provided for backward compatibility, even though a word character includes
      more than the standard C language meaning of alphanumeric. See the top of
      this section for an explanation of variants
      <span class="Li">&quot;isWORDCHAR_A&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_L1&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_uvchr&quot;</span>, and
      <span class="Li">&quot;isWORDCHAR_utf8_safe&quot;</span>.
      <span class="Li">&quot;isWORDCHAR_LC&quot;</span>,
      <span class="Li">&quot;isWORDCHAR_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isWORDCHAR_LC_utf8_safe&quot;</span> are also as
      described there, but additionally include the platform's native
      underscore.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isWORDCHAR(char ch)
    </pre>
  </dd>
  <dt>isXDIGIT</dt>
  <dd>Returns a boolean indicating whether the specified character is a
      hexadecimal digit. In the ASCII range these are
      <span class="Li">&quot;[0-9A-Fa-f]&quot;</span>. Variants
      <span class="Li">&quot;isXDIGIT_A()&quot;</span> and
      <span class="Li">&quot;isXDIGIT_L1()&quot;</span> are identical to
      <span class="Li">&quot;isXDIGIT()&quot;</span>. See the top of this
      section for an explanation of variants
      <span class="Li">&quot;isXDIGIT_uvchr&quot;</span>,
      <span class="Li">&quot;isXDIGIT_utf8_safe&quot;</span>,
      <span class="Li">&quot;isXDIGIT_LC&quot;</span>,
      <span class="Li">&quot;isXDIGIT_LC_uvchr&quot;</span>, and
      <span class="Li">&quot;isXDIGIT_LC_utf8_safe&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isXDIGIT(char ch)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Cloning_an_interpreter"><a class="permalink" href="#Cloning_an_interpreter">Cloning
  an interpreter</a></h1>
<dl class="Bl-tag">
  <dt>perl_clone</dt>
  <dd>Create and return a new interpreter by cloning the current one.
    <p class="Pp"><span class="Li">&quot;perl_clone&quot;</span> takes these
        flags as parameters:</p>
    <p class="Pp"><span class="Li">&quot;CLONEf_COPY_STACKS&quot;</span> - is
        used to, well, copy the stacks also, without it we only clone the data
        and zero the stacks, with it we copy the stacks and the new perl
        interpreter is ready to run at the exact same point as the previous one.
        The pseudo-fork code uses
        <span class="Li">&quot;COPY_STACKS&quot;</span> while the
        threads-&gt;create doesn't.</p>
    <p class="Pp"><span class="Li">&quot;CLONEf_KEEP_PTR_TABLE&quot;</span> -
        <span class="Li">&quot;perl_clone&quot;</span> keeps a ptr_table with
        the pointer of the old variable as a key and the new variable as a
        value, this allows it to check if something has been cloned and not
        clone it again but rather just use the value and increase the refcount.
        If <span class="Li">&quot;KEEP_PTR_TABLE&quot;</span> is not set then
        <span class="Li">&quot;perl_clone&quot;</span> will kill the ptr_table
        using the function <span class="Li">&quot;ptr_table_free(PL_ptr_table);
        PL_ptr_table = NULL;&quot;</span>, reason to keep it around is if you
        want to dup some of your own variable who are outside the graph perl
        scans, an example of this code is in <i>threads.xs</i> create.</p>
    <p class="Pp"><span class="Li">&quot;CLONEf_CLONE_HOST&quot;</span> - This
        is a win32 thing, it is ignored on unix, it tells perls win32host code
        (which is c++) to clone itself, this is needed on win32 if you want to
        run two threads at the same time, if you just want to do some stuff in a
        separate perl interpreter and then throw it away and return to the
        original one, you don't need to do anything.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PerlInterpreter* perl_clone(
                             PerlInterpreter *proto_perl,
                             UV flags
                         )
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Compile-time_scope_hooks"><a class="permalink" href="#Compile-time_scope_hooks">Compile-time
  scope hooks</a></h1>
<dl class="Bl-tag">
  <dt>BhkDISABLE</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Temporarily disable an entry in this BHK structure, by
        clearing the appropriate flag. <span class="Li">&quot;which&quot;</span>
        is a preprocessor token indicating which entry to disable.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    BhkDISABLE(BHK *hk, which)
    </pre>
  </dd>
  <dt>BhkENABLE</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Re-enable an entry in this BHK structure, by setting the
        appropriate flag. <span class="Li">&quot;which&quot;</span> is a
        preprocessor token indicating which entry to enable. This will assert
        (under -DDEBUGGING) if the entry doesn't contain a valid pointer.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    BhkENABLE(BHK *hk, which)
    </pre>
  </dd>
  <dt>BhkENTRY_set</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Set an entry in the BHK structure, and set the flags to
        indicate it is valid. <span class="Li">&quot;which&quot;</span> is a
        preprocessing token indicating which entry to set. The type of
        <span class="Li">&quot;ptr&quot;</span> depends on the entry.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    BhkENTRY_set(BHK *hk, which, void *ptr)
    </pre>
  </dd>
  <dt>blockhook_register</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Register a set of hooks to be called when the Perl lexical
        scope changes at compile time. See &quot;Compile-time scope hooks&quot;
        in perlguts.</p>
    <p class="Pp">NOTE: this function must be explicitly called as
        Perl_blockhook_register with an aTHX_ parameter.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Perl_blockhook_register(pTHX_ BHK *hk)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COP_Hint_Hashes"><a class="permalink" href="#COP_Hint_Hashes">COP
  Hint Hashes</a></h1>
<dl class="Bl-tag">
  <dt>cophh_2hv</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Generates and returns a standard Perl hash representing the
        full set of key/value pairs in the cop hints hash
        <span class="Li">&quot;cophh&quot;</span>.
        <span class="Li">&quot;flags&quot;</span> is currently unused and must
        be zero.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    cophh_2hv(const COPHH *cophh, U32 flags)
    </pre>
  </dd>
  <dt>cophh_copy</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Make and return a complete copy of the cop hints hash
        <span class="Li">&quot;cophh&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_copy(COPHH *cophh)
    </pre>
  </dd>
  <dt>cophh_delete_pv</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Like &quot;cophh_delete_pvn&quot;, but takes a nul-terminated
        string instead of a string/length pair.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_delete_pv(const COPHH *cophh,
                                const char *key, U32 hash,
                                U32 flags)
    </pre>
  </dd>
  <dt>cophh_delete_pvn</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Delete a key and its associated value from the cop hints hash
        <span class="Li">&quot;cophh&quot;</span>, and returns the modified
        hash. The returned hash pointer is in general not the same as the hash
        pointer that was passed in. The input hash is consumed by the function,
        and the pointer to it must not be subsequently used. Use
        &quot;cophh_copy&quot; if you need both hashes.</p>
    <p class="Pp">The key is specified by
        <span class="Li">&quot;keypv&quot;</span> and
        <span class="Li">&quot;keylen&quot;</span>. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span> bit set, the key
        octets are interpreted as UTF-8, otherwise they are interpreted as
        Latin-1. <span class="Li">&quot;hash&quot;</span> is a precomputed hash
        of the key string, or zero if it has not been precomputed.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_delete_pvn(COPHH *cophh,
                                 const char *keypv,
                                 STRLEN keylen, U32 hash,
                                 U32 flags)
    </pre>
  </dd>
  <dt>cophh_delete_pvs</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Like &quot;cophh_delete_pvn&quot;, but takes a literal string
        instead of a string/length pair, and no precomputed hash.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_delete_pvs(const COPHH *cophh,
                                 &quot;literal string&quot; key,
                                 U32 flags)
    </pre>
  </dd>
  <dt>cophh_delete_sv</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Like &quot;cophh_delete_pvn&quot;, but takes a Perl scalar
        instead of a string/length pair.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_delete_sv(const COPHH *cophh, SV *key,
                                U32 hash, U32 flags)
    </pre>
  </dd>
  <dt>cophh_fetch_pv</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Like &quot;cophh_fetch_pvn&quot;, but takes a nul-terminated
        string instead of a string/length pair.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cophh_fetch_pv(const COPHH *cophh,
                               const char *key, U32 hash,
                               U32 flags)
    </pre>
  </dd>
  <dt>cophh_fetch_pvn</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Look up the entry in the cop hints hash
        <span class="Li">&quot;cophh&quot;</span> with the key specified by
        <span class="Li">&quot;keypv&quot;</span> and
        <span class="Li">&quot;keylen&quot;</span>. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span> bit set, the key
        octets are interpreted as UTF-8, otherwise they are interpreted as
        Latin-1. <span class="Li">&quot;hash&quot;</span> is a precomputed hash
        of the key string, or zero if it has not been precomputed. Returns a
        mortal scalar copy of the value associated with the key, or
        <span class="Li">&amp;PL_sv_placeholder</span> if there is no value
        associated with the key.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cophh_fetch_pvn(const COPHH *cophh,
                                const char *keypv,
                                STRLEN keylen, U32 hash,
                                U32 flags)
    </pre>
  </dd>
  <dt>cophh_fetch_pvs</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Like &quot;cophh_fetch_pvn&quot;, but takes a literal string
        instead of a string/length pair, and no precomputed hash.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cophh_fetch_pvs(const COPHH *cophh,
                                &quot;literal string&quot; key, U32 flags)
    </pre>
  </dd>
  <dt>cophh_fetch_sv</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Like &quot;cophh_fetch_pvn&quot;, but takes a Perl scalar
        instead of a string/length pair.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cophh_fetch_sv(const COPHH *cophh, SV *key,
                               U32 hash, U32 flags)
    </pre>
  </dd>
  <dt>cophh_free</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Discard the cop hints hash
        <span class="Li">&quot;cophh&quot;</span>, freeing all resources
        associated with it.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cophh_free(COPHH *cophh)
    </pre>
  </dd>
  <dt>cophh_new_empty</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Generate and return a fresh cop hints hash containing no
        entries.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_new_empty()
    </pre>
  </dd>
  <dt>cophh_store_pv</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Like &quot;cophh_store_pvn&quot;, but takes a nul-terminated
        string instead of a string/length pair.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_store_pv(const COPHH *cophh,
                               const char *key, U32 hash,
                               SV *value, U32 flags)
    </pre>
  </dd>
  <dt>cophh_store_pvn</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Stores a value, associated with a key, in the cop hints hash
        <span class="Li">&quot;cophh&quot;</span>, and returns the modified
        hash. The returned hash pointer is in general not the same as the hash
        pointer that was passed in. The input hash is consumed by the function,
        and the pointer to it must not be subsequently used. Use
        &quot;cophh_copy&quot; if you need both hashes.</p>
    <p class="Pp">The key is specified by
        <span class="Li">&quot;keypv&quot;</span> and
        <span class="Li">&quot;keylen&quot;</span>. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span> bit set, the key
        octets are interpreted as UTF-8, otherwise they are interpreted as
        Latin-1. <span class="Li">&quot;hash&quot;</span> is a precomputed hash
        of the key string, or zero if it has not been precomputed.</p>
    <p class="Pp"><span class="Li">&quot;value&quot;</span> is the scalar value
        to store for this key. <span class="Li">&quot;value&quot;</span> is
        copied by this function, which thus does not take ownership of any
        reference to it, and later changes to the scalar will not be reflected
        in the value visible in the cop hints hash. Complex types of scalar will
        not be stored with referential integrity, but will be coerced to
        strings.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_store_pvn(COPHH *cophh, const char *keypv,
                                STRLEN keylen, U32 hash,
                                SV *value, U32 flags)
    </pre>
  </dd>
  <dt>cophh_store_pvs</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Like &quot;cophh_store_pvn&quot;, but takes a literal string
        instead of a string/length pair, and no precomputed hash.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_store_pvs(const COPHH *cophh,
                                &quot;literal string&quot; key, SV *value,
                                U32 flags)
    </pre>
  </dd>
  <dt>cophh_store_sv</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Like &quot;cophh_store_pvn&quot;, but takes a Perl scalar
        instead of a string/length pair.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        COPHH * cophh_store_sv(const COPHH *cophh, SV *key,
                               U32 hash, SV *value, U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COP_Hint_Reading"><a class="permalink" href="#COP_Hint_Reading">COP
  Hint Reading</a></h1>
<dl class="Bl-tag">
  <dt>cop_hints_2hv</dt>
  <dd>Generates and returns a standard Perl hash representing the full set of
      hint entries in the cop <span class="Li">&quot;cop&quot;</span>.
      <span class="Li">&quot;flags&quot;</span> is currently unused and must be
      zero.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    cop_hints_2hv(const COP *cop, U32 flags)
    </pre>
  </dd>
  <dt>cop_hints_fetch_pv</dt>
  <dd>Like &quot;cop_hints_fetch_pvn&quot;, but takes a nul-terminated string
      instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cop_hints_fetch_pv(const COP *cop,
                                   const char *key, U32 hash,
                                   U32 flags)
    </pre>
  </dd>
  <dt>cop_hints_fetch_pvn</dt>
  <dd>Look up the hint entry in the cop <span class="Li">&quot;cop&quot;</span>
      with the key specified by <span class="Li">&quot;keypv&quot;</span> and
      <span class="Li">&quot;keylen&quot;</span>. If
      <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;COPHH_KEY_UTF8&quot;</span> bit set, the key octets
      are interpreted as UTF-8, otherwise they are interpreted as Latin-1.
      <span class="Li">&quot;hash&quot;</span> is a precomputed hash of the key
      string, or zero if it has not been precomputed. Returns a mortal scalar
      copy of the value associated with the key, or
      <span class="Li">&amp;PL_sv_placeholder</span> if there is no value
      associated with the key.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cop_hints_fetch_pvn(const COP *cop,
                                    const char *keypv,
                                    STRLEN keylen, U32 hash,
                                    U32 flags)
    </pre>
  </dd>
  <dt>cop_hints_fetch_pvs</dt>
  <dd>Like &quot;cop_hints_fetch_pvn&quot;, but takes a literal string instead
      of a string/length pair, and no precomputed hash.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cop_hints_fetch_pvs(const COP *cop,
                                    &quot;literal string&quot; key,
                                    U32 flags)
    </pre>
  </dd>
  <dt>cop_hints_fetch_sv</dt>
  <dd>Like &quot;cop_hints_fetch_pvn&quot;, but takes a Perl scalar instead of a
      string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cop_hints_fetch_sv(const COP *cop, SV *key,
                                   U32 hash, U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Custom_Operators"><a class="permalink" href="#Custom_Operators">Custom
  Operators</a></h1>
<dl class="Bl-tag">
  <dt>custom_op_register</dt>
  <dd>Register a custom op. See &quot;Custom Operators&quot; in perlguts.
    <p class="Pp">NOTE: this function must be explicitly called as
        Perl_custom_op_register with an aTHX_ parameter.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Perl_custom_op_register(pTHX_ 
                                        Perl_ppaddr_t ppaddr,
                                        const XOP *xop)
    </pre>
  </dd>
  <dt>custom_op_xop</dt>
  <dd>Return the XOP structure for a given custom op. This macro should be
      considered internal to <span class="Li">&quot;OP_NAME&quot;</span> and the
      other access macros: use them instead. This macro does call a function.
      Prior to 5.19.6, this was implemented as a function.
    <p class="Pp">NOTE: this function must be explicitly called as
        Perl_custom_op_xop with an aTHX_ parameter.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const XOP * Perl_custom_op_xop(pTHX_ const OP *o)
    </pre>
  </dd>
  <dt>XopDISABLE</dt>
  <dd>Temporarily disable a member of the XOP, by clearing the appropriate flag.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XopDISABLE(XOP *xop, which)
    </pre>
  </dd>
  <dt>XopENABLE</dt>
  <dd>Reenable a member of the XOP which has been disabled.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XopENABLE(XOP *xop, which)
    </pre>
  </dd>
  <dt>XopENTRY</dt>
  <dd>Return a member of the XOP structure.
      <span class="Li">&quot;which&quot;</span> is a cpp token indicating which
      entry to return. If the member is not set this will return a default
      value. The return type depends on
      <span class="Li">&quot;which&quot;</span>. This macro evaluates its
      arguments more than once. If you are using
      <span class="Li">&quot;Perl_custom_op_xop&quot;</span> to retreive a
      <span class="Li">&quot;XOP *&quot;</span> from a <span class="Li">&quot;OP
      *&quot;</span>, use the more efficient &quot;XopENTRYCUSTOM&quot; instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XopENTRY(XOP *xop, which)
    </pre>
  </dd>
  <dt>XopENTRYCUSTOM</dt>
  <dd>Exactly like
      <span class="Li">&quot;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o),
      which)&quot;</span> but more efficient. The
      <span class="Li">&quot;which&quot;</span> parameter is identical to
      &quot;XopENTRY&quot;.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XopENTRYCUSTOM(const OP *o, which)
    </pre>
  </dd>
  <dt>XopENTRY_set</dt>
  <dd>Set a member of the XOP structure.
      <span class="Li">&quot;which&quot;</span> is a cpp token indicating which
      entry to set. See &quot;Custom Operators&quot; in perlguts for details
      about the available members and how they are used. This macro evaluates
      its argument more than once.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XopENTRY_set(XOP *xop, which, value)
    </pre>
  </dd>
  <dt>XopFLAGS</dt>
  <dd>Return the XOP's flags.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     XopFLAGS(XOP *xop)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CV_Manipulation_Functions"><a class="permalink" href="#CV_Manipulation_Functions">CV
  Manipulation Functions</a></h1>
This section documents functions to manipulate CVs which are code-values, or
  subroutines. For more information, see perlguts.
<dl class="Bl-tag">
  <dt>caller_cx</dt>
  <dd>The XSUB-writer's equivalent of <b>caller()</b>. The returned
      <span class="Li">&quot;PERL_CONTEXT&quot;</span> structure can be
      interrogated to find all the information returned to Perl by
      <span class="Li">&quot;caller&quot;</span>. Note that XSUBs don't get a
      stack frame, so <span class="Li">&quot;caller_cx(0, NULL)&quot;</span>
      will return information for the immediately-surrounding Perl code.
    <p class="Pp">This function skips over the automatic calls to
        <span class="Li">&amp;DB::sub</span> made on the behalf of the debugger.
        If the stack frame requested was a sub called by
        <span class="Li">&quot;DB::sub&quot;</span>, the return value will be
        the frame for the call to <span class="Li">&quot;DB::sub&quot;</span>,
        since that has the correct line number/etc. for the call site. If
        <i>dbcxp</i> is non-<span class="Li">&quot;NULL&quot;</span>, it will be
        set to a pointer to the frame for the sub call itself.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const PERL_CONTEXT * caller_cx(
                                 I32 level,
                                 const PERL_CONTEXT **dbcxp
                             )
    </pre>
  </dd>
  <dt>CvSTASH</dt>
  <dd>Returns the stash of the CV. A stash is the symbol table hash, containing
      the package-scoped variables in the package where the subroutine was
      defined. For more information, see perlguts.
    <p class="Pp">This also has a special use with XS AUTOLOAD subs. See
        &quot;Autoloading with XSUBs&quot; in perlguts.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     CvSTASH(CV* cv)
    </pre>
  </dd>
  <dt>find_runcv</dt>
  <dd>Locate the CV corresponding to the currently executing sub or eval. If
      <span class="Li">&quot;db_seqp&quot;</span> is non_null, skip CVs that are
      in the DB package and populate <span class="Li">*db_seqp</span> with the
      cop sequence number at the point that the DB:: code was entered. (This
      allows debuggers to eval in the scope of the breakpoint rather than in the
      scope of the debugger itself.)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV*     find_runcv(U32 *db_seqp)
    </pre>
  </dd>
  <dt>get_cv</dt>
  <dd>Uses <span class="Li">&quot;strlen&quot;</span> to get the length of
      <span class="Li">&quot;name&quot;</span>, then calls
      <span class="Li">&quot;get_cvn_flags&quot;</span>.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV*     get_cv(const char* name, I32 flags)
    </pre>
  </dd>
  <dt>get_cvn_flags</dt>
  <dd>Returns the CV of the specified Perl subroutine.
      <span class="Li">&quot;flags&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchpvn_flags&quot;</span>. If
      <span class="Li">&quot;GV_ADD&quot;</span> is set and the Perl subroutine
      does not exist then it will be declared (which has the same effect as
      saying <span class="Li">&quot;sub name;&quot;</span>). If
      <span class="Li">&quot;GV_ADD&quot;</span> is not set and the subroutine
      does not exist then NULL is returned.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV*     get_cvn_flags(const char* name, STRLEN len,
                              I32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="_xsubpp__variables_and_internal_functions"><a class="permalink" href="#_xsubpp__variables_and_internal_functions">&quot;xsubpp&quot;
  variables and internal functions</a></h1>
<dl class="Bl-tag">
  <dt>ax</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      indicate the stack base offset, used by the
      <span class="Li">&quot;ST&quot;</span>,
      <span class="Li">&quot;XSprePUSH&quot;</span> and
      <span class="Li">&quot;XSRETURN&quot;</span> macros. The
      <span class="Li">&quot;dMARK&quot;</span> macro must be called prior to
      setup the <span class="Li">&quot;MARK&quot;</span> variable.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     ax
    </pre>
  </dd>
  <dt>CLASS</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      indicate the class name for a C++ XS constructor. This is always a
      <span class="Li">&quot;char*&quot;</span>. See
      <span class="Li">&quot;THIS&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   CLASS
    </pre>
  </dd>
  <dt>dAX</dt>
  <dd>Sets up the <span class="Li">&quot;ax&quot;</span> variable. This is
      usually handled automatically by
      <span class="Li">&quot;xsubpp&quot;</span> by calling
      <span class="Li">&quot;dXSARGS&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dAX;
    </pre>
  </dd>
  <dt>dAXMARK</dt>
  <dd>Sets up the <span class="Li">&quot;ax&quot;</span> variable and stack
      marker variable <span class="Li">&quot;mark&quot;</span>. This is usually
      handled automatically by <span class="Li">&quot;xsubpp&quot;</span> by
      calling <span class="Li">&quot;dXSARGS&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dAXMARK;
    </pre>
  </dd>
  <dt>dITEMS</dt>
  <dd>Sets up the <span class="Li">&quot;items&quot;</span> variable. This is
      usually handled automatically by
      <span class="Li">&quot;xsubpp&quot;</span> by calling
      <span class="Li">&quot;dXSARGS&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dITEMS;
    </pre>
  </dd>
  <dt>dUNDERBAR</dt>
  <dd>Sets up any variable needed by the
      <span class="Li">&quot;UNDERBAR&quot;</span> macro. It used to define
      <span class="Li">&quot;padoff_du&quot;</span>, but it is currently a noop.
      However, it is strongly advised to still use it for ensuring past and
      future compatibility.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dUNDERBAR;
    </pre>
  </dd>
  <dt>dXSARGS</dt>
  <dd>Sets up stack and mark pointers for an XSUB, calling
      <span class="Li">&quot;dSP&quot;</span> and
      <span class="Li">&quot;dMARK&quot;</span>. Sets up the
      <span class="Li">&quot;ax&quot;</span> and
      <span class="Li">&quot;items&quot;</span> variables by calling
      <span class="Li">&quot;dAX&quot;</span> and
      <span class="Li">&quot;dITEMS&quot;</span>. This is usually handled
      automatically by <span class="Li">&quot;xsubpp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dXSARGS;
    </pre>
  </dd>
  <dt>dXSI32</dt>
  <dd>Sets up the <span class="Li">&quot;ix&quot;</span> variable for an XSUB
      which has aliases. This is usually handled automatically by
      <span class="Li">&quot;xsubpp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dXSI32;
    </pre>
  </dd>
  <dt>items</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      indicate the number of items on the stack. See &quot;Variable-length
      Parameter Lists&quot; in perlxs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     items
    </pre>
  </dd>
  <dt>ix</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      indicate which of an XSUB's aliases was used to invoke it. See &quot;The
      ALIAS: Keyword&quot; in perlxs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     ix
    </pre>
  </dd>
  <dt>RETVAL</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      hold the return value for an XSUB. This is always the proper type for the
      XSUB. See &quot;The RETVAL Variable&quot; in perlxs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        (whatever)      RETVAL
    </pre>
  </dd>
  <dt>ST</dt>
  <dd>Used to access elements on the XSUB's stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     ST(int ix)
    </pre>
  </dd>
  <dt>THIS</dt>
  <dd>Variable which is setup by <span class="Li">&quot;xsubpp&quot;</span> to
      designate the object in a C++ XSUB. This is always the proper type for the
      C++ object. See <span class="Li">&quot;CLASS&quot;</span> and &quot;Using
      XS With C++&quot; in perlxs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        (whatever)      THIS
    </pre>
  </dd>
  <dt>UNDERBAR</dt>
  <dd>The SV* corresponding to the <span class="Li">$_</span> variable. Works
      even if there is a lexical <span class="Li">$_</span> in scope.</dd>
  <dt>XS</dt>
  <dd>Macro to declare an XSUB and its C parameter list. This is handled by
      <span class="Li">&quot;xsubpp&quot;</span>. It is the same as using the
      more explicit <span class="Li">&quot;XS_EXTERNAL&quot;</span> macro.</dd>
  <dt>XS_EXTERNAL</dt>
  <dd>Macro to declare an XSUB and its C parameter list explicitly exporting the
      symbols.</dd>
  <dt>XS_INTERNAL</dt>
  <dd>Macro to declare an XSUB and its C parameter list without exporting the
      symbols. This is handled by <span class="Li">&quot;xsubpp&quot;</span> and
      generally preferable over exporting the XSUB symbols unnecessarily.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Debugging_Utilities"><a class="permalink" href="#Debugging_Utilities">Debugging
  Utilities</a></h1>
<dl class="Bl-tag">
  <dt>dump_all</dt>
  <dd>Dumps the entire optree of the current program starting at
      <span class="Li">&quot;PL_main_root&quot;</span> to
      <span class="Li">&quot;STDERR&quot;</span>. Also dumps the optrees for all
      visible subroutines in <span class="Li">&quot;PL_defstash&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    dump_all()
    </pre>
  </dd>
  <dt>dump_packsubs</dt>
  <dd>Dumps the optrees for all visible subroutines in
      <span class="Li">&quot;stash&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    dump_packsubs(const HV* stash)
    </pre>
  </dd>
  <dt>op_class</dt>
  <dd>Given an op, determine what type of struct it has been allocated as.
      Returns one of the OPclass enums, such as OPclass_LISTOP.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OPclass op_class(const OP *o)
    </pre>
  </dd>
  <dt>op_dump</dt>
  <dd>Dumps the optree starting at OP <span class="Li">&quot;o&quot;</span> to
      <span class="Li">&quot;STDERR&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    op_dump(const OP *o)
    </pre>
  </dd>
  <dt>sv_dump</dt>
  <dd>Dumps the contents of an SV to the
      <span class="Li">&quot;STDERR&quot;</span> filehandle.
    <p class="Pp">For an example of its output, see Devel::Peek.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_dump(SV* sv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Display_and_Dump_functions"><a class="permalink" href="#Display_and_Dump_functions">Display
  and Dump functions</a></h1>
<dl class="Bl-tag">
  <dt>pv_display</dt>
  <dd>Similar to
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  pv_escape(dsv,pv,cur,pvlim,PERL_PV_ESCAPE_QUOTE);
    </pre>
    <p class="Pp">except that an additional &quot;\0&quot; will be appended to
        the string when len &gt; cur and pv[cur] is &quot;\0&quot;.</p>
    <p class="Pp">Note that the final string may be up to 7 chars longer than
        pvlim.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   pv_display(SV *dsv, const char *pv, STRLEN cur,
                           STRLEN len, STRLEN pvlim)
    </pre>
  </dd>
  <dt>pv_escape</dt>
  <dd>Escapes at most the first <span class="Li">&quot;count&quot;</span> chars
      of <span class="Li">&quot;pv&quot;</span> and puts the results into
      <span class="Li">&quot;dsv&quot;</span> such that the size of the escaped
      string will not exceed <span class="Li">&quot;max&quot;</span> chars and
      will not contain any incomplete escape sequences. The number of bytes
      escaped will be returned in the <span class="Li">&quot;STRLEN
      *escaped&quot;</span> parameter if it is not null. When the
      <span class="Li">&quot;dsv&quot;</span> parameter is null no escaping
      actually occurs, but the number of bytes that would be escaped were it not
      null will be calculated.
    <p class="Pp">If flags contains
        <span class="Li">&quot;PERL_PV_ESCAPE_QUOTE&quot;</span> then any double
        quotes in the string will also be escaped.</p>
    <p class="Pp">Normally the SV will be cleared before the escaped string is
        prepared, but when
        <span class="Li">&quot;PERL_PV_ESCAPE_NOCLEAR&quot;</span> is set this
        will not occur.</p>
    <p class="Pp">If <span class="Li">&quot;PERL_PV_ESCAPE_UNI&quot;</span> is
        set then the input string is treated as UTF-8 if
        <span class="Li">&quot;PERL_PV_ESCAPE_UNI_DETECT&quot;</span> is set
        then the input string is scanned using
        <span class="Li">&quot;is_utf8_string()&quot;</span> to determine if it
        is UTF-8.</p>
    <p class="Pp">If <span class="Li">&quot;PERL_PV_ESCAPE_ALL&quot;</span> is
        set then all input chars will be output using
        <span class="Li">&quot;\x01F1&quot;</span> style escapes, otherwise if
        <span class="Li">&quot;PERL_PV_ESCAPE_NONASCII&quot;</span> is set, only
        non-ASCII chars will be escaped using this style; otherwise, only chars
        above 255 will be so escaped; other non printable chars will use octal
        or common escaped patterns like <span class="Li">&quot;\n&quot;</span>.
        Otherwise, if
        <span class="Li">&quot;PERL_PV_ESCAPE_NOBACKSLASH&quot;</span> then all
        chars below 255 will be treated as printable and will be output as
        literals.</p>
    <p class="Pp">If
        <span class="Li">&quot;PERL_PV_ESCAPE_FIRSTCHAR&quot;</span> is set then
        only the first char of the string will be escaped, regardless of max. If
        the output is to be in hex, then it will be returned as a plain hex
        sequence. Thus the output will either be a single char, an octal escape
        sequence, a special escape like <span class="Li">&quot;\n&quot;</span>
        or a hex value.</p>
    <p class="Pp">If <span class="Li">&quot;PERL_PV_ESCAPE_RE&quot;</span> is
        set then the escape char used will be a
        <span class="Li">&quot;%&quot;</span> and not a
        <span class="Li">&quot;\\&quot;</span>. This is because regexes very
        often contain backslashed sequences, whereas
        <span class="Li">&quot;%&quot;</span> is not a particularly common
        character in patterns.</p>
    <p class="Pp">Returns a pointer to the escaped text as held by
        <span class="Li">&quot;dsv&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   pv_escape(SV *dsv, char const * const str,
                          const STRLEN count, const STRLEN max,
                          STRLEN * const escaped,
                          const U32 flags)
    </pre>
  </dd>
  <dt>pv_pretty</dt>
  <dd>Converts a string into something presentable, handling escaping via
      <span class="Li">&quot;pv_escape()&quot;</span> and supporting quoting and
      ellipses.
    <p class="Pp">If the
        <span class="Li">&quot;PERL_PV_PRETTY_QUOTE&quot;</span> flag is set
        then the result will be double quoted with any double quotes in the
        string escaped. Otherwise if the
        <span class="Li">&quot;PERL_PV_PRETTY_LTGT&quot;</span> flag is set then
        the result be wrapped in angle brackets.</p>
    <p class="Pp">If the
        <span class="Li">&quot;PERL_PV_PRETTY_ELLIPSES&quot;</span> flag is set
        and not all characters in string were output then an ellipsis
        <span class="Li">&quot;...&quot;</span> will be appended to the string.
        Note that this happens AFTER it has been quoted.</p>
    <p class="Pp">If <span class="Li">&quot;start_color&quot;</span> is non-null
        then it will be inserted after the opening quote (if there is one) but
        before the escaped text. If
        <span class="Li">&quot;end_color&quot;</span> is non-null then it will
        be inserted after the escaped text but before any quotes or
      ellipses.</p>
    <p class="Pp">Returns a pointer to the prettified text as held by
        <span class="Li">&quot;dsv&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   pv_pretty(SV *dsv, char const * const str,
                          const STRLEN count, const STRLEN max,
                          char const * const start_color,
                          char const * const end_color,
                          const U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Embedding_Functions"><a class="permalink" href="#Embedding_Functions">Embedding
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>cv_clone</dt>
  <dd>Clone a CV, making a lexical closure.
      <span class="Li">&quot;proto&quot;</span> supplies the prototype of the
      function: its code, pad structure, and other attributes. The prototype is
      combined with a capture of outer lexicals to which the code refers, which
      are taken from the currently-executing instance of the immediately
      surrounding code.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV *    cv_clone(CV *proto)
    </pre>
  </dd>
  <dt>cv_name</dt>
  <dd>Returns an SV containing the name of the CV, mainly for use in error
      reporting. The CV may actually be a GV instead, in which case the returned
      SV holds the GV's name. Anything other than a GV or CV is treated as a
      string already holding the sub name, but this could change in the future.
    <p class="Pp">An SV may be passed as a second argument. If so, the name will
        be assigned to it and it will be returned. Otherwise the returned SV
        will be a new mortal.</p>
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;CV_NAME_NOTQUAL&quot;</span> bit set, then the
        package name will not be included. If the first argument is neither a CV
        nor a GV, this flag is ignored (subject to change).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    cv_name(CV *cv, SV *sv, U32 flags)
    </pre>
  </dd>
  <dt>cv_undef</dt>
  <dd>Clear out all the active components of a CV. This can happen either by an
      explicit <span class="Li">&quot;undef &amp;foo&quot;</span>, or by the
      reference count going to zero. In the former case, we keep the
      <span class="Li">&quot;CvOUTSIDE&quot;</span> pointer, so that any
      anonymous children can still follow the full lexical scope chain.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cv_undef(CV* cv)
    </pre>
  </dd>
  <dt>find_rundefsv</dt>
  <dd>Returns the global variable <span class="Li">$_</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    find_rundefsv()
    </pre>
  </dd>
  <dt>find_rundefsvoffset</dt>
  <dd>DEPRECATED! It is planned to remove this function from a future release of
      Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Until the lexical <span class="Li">$_</span> feature was
        removed, this function would find the position of the lexical
        <span class="Li">$_</span> in the pad of the currently-executing
        function and return the offset in the current pad, or
        <span class="Li">&quot;NOT_IN_PAD&quot;</span>.</p>
    <p class="Pp">Now it always returns
        <span class="Li">&quot;NOT_IN_PAD&quot;</span>.</p>
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET find_rundefsvoffset()
    </pre>
  </dd>
  <dt>intro_my</dt>
  <dd>&quot;Introduce&quot; <span class="Li">&quot;my&quot;</span> variables to
      visible status. This is called during parsing at the end of each statement
      to make lexical variables visible to subsequent statements.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     intro_my()
    </pre>
  </dd>
  <dt>load_module</dt>
  <dd>Loads the module whose name is pointed to by the string part of
      <span class="Li">&quot;name&quot;</span>. Note that the actual module
      name, not its filename, should be given. Eg, &quot;Foo::Bar&quot; instead
      of &quot;Foo/Bar.pm&quot;. ver, if specified and not NULL, provides
      version semantics similar to <span class="Li">&quot;use Foo::Bar
      VERSION&quot;</span>. The optional trailing arguments can be used to
      specify arguments to the module's
      <span class="Li">&quot;import()&quot;</span> method, similar to
      <span class="Li">&quot;use Foo::Bar VERSION LIST&quot;</span>; their
      precise handling depends on the flags. The flags argument is a
      bitwise-ORed collection of any of
      <span class="Li">&quot;PERL_LOADMOD_DENY&quot;</span>,
      <span class="Li">&quot;PERL_LOADMOD_NOIMPORT&quot;</span>, or
      <span class="Li">&quot;PERL_LOADMOD_IMPORT_OPS&quot;</span> (or 0 for no
      flags).
    <p class="Pp">If <span class="Li">&quot;PERL_LOADMOD_NOIMPORT&quot;</span>
        is set, the module is loaded as if with an empty import list, as in
        <span class="Li">&quot;use Foo::Bar ()&quot;</span>; this is the only
        circumstance in which the trailing optional arguments may be omitted
        entirely. Otherwise, if
        <span class="Li">&quot;PERL_LOADMOD_IMPORT_OPS&quot;</span> is set, the
        trailing arguments must consist of exactly one
        <span class="Li">&quot;OP*&quot;</span>, containing the op tree that
        produces the relevant import arguments. Otherwise, the trailing
        arguments must all be <span class="Li">&quot;SV*&quot;</span> values
        that will be used as import arguments; and the list must be terminated
        with <span class="Li">&quot;(SV*)</span>
        <span class="Li">NULL&quot;</span>. If neither
        <span class="Li">&quot;PERL_LOADMOD_NOIMPORT&quot;</span> nor
        <span class="Li">&quot;PERL_LOADMOD_IMPORT_OPS&quot;</span> is set, the
        trailing <span class="Li">&quot;NULL&quot;</span> pointer is needed even
        if no import arguments are desired. The reference count for each
        specified <span class="Li">&quot;SV*&quot;</span> argument is
        decremented. In addition, the <span class="Li">&quot;name&quot;</span>
        argument is modified.</p>
    <p class="Pp">If <span class="Li">&quot;PERL_LOADMOD_DENY&quot;</span> is
        set, the module is loaded as if with
        <span class="Li">&quot;no&quot;</span> rather than
        <span class="Li">&quot;use&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    load_module(U32 flags, SV* name, SV* ver, ...)
    </pre>
  </dd>
  <dt>newPADNAMELIST</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Creates a new pad name list.
        <span class="Li">&quot;max&quot;</span> is the highest index for which
        space is allocated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADNAMELIST * newPADNAMELIST(size_t max)
    </pre>
  </dd>
  <dt>newPADNAMEouter</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Constructs and returns a new pad name. Only use this function
        for names that refer to outer lexicals. (See also
        &quot;newPADNAMEpvn&quot;.) <span class="Li">&quot;outer&quot;</span> is
        the outer pad name that this one mirrors. The returned pad name has the
        <span class="Li">&quot;PADNAMEt_OUTER&quot;</span> flag already set.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADNAME * newPADNAMEouter(PADNAME *outer)
    </pre>
  </dd>
  <dt>newPADNAMEpvn</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Constructs and returns a new pad name.
        <span class="Li">&quot;s&quot;</span> must be a UTF-8 string. Do not use
        this for pad names that point to outer lexicals. See
        <span class="Li">&quot;newPADNAMEouter&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADNAME * newPADNAMEpvn(const char *s, STRLEN len)
    </pre>
  </dd>
  <dt>nothreadhook</dt>
  <dd>Stub that provides thread hook for perl_destruct when there are no
      threads.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     nothreadhook()
    </pre>
  </dd>
  <dt>pad_add_anon</dt>
  <dd>Allocates a place in the currently-compiling pad (via
      &quot;pad_alloc&quot;) for an anonymous function that is lexically scoped
      inside the currently-compiling function. The function
      <span class="Li">&quot;func&quot;</span> is linked into the pad, and its
      <span class="Li">&quot;CvOUTSIDE&quot;</span> link to the outer scope is
      weakened to avoid a reference loop.
    <p class="Pp">One reference count is stolen, so you may need to do
        <span class="Li">&quot;SvREFCNT_inc(func)&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;optype&quot;</span> should be an opcode
        indicating the type of operation that the pad entry is to support. This
        doesn't affect operational semantics, but is used for debugging.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_add_anon(CV *func, I32 optype)
    </pre>
  </dd>
  <dt>pad_add_name_pv</dt>
  <dd>Exactly like &quot;pad_add_name_pvn&quot;, but takes a nul-terminated
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_add_name_pv(const char *name, U32 flags,
                                  HV *typestash, HV *ourstash)
    </pre>
  </dd>
  <dt>pad_add_name_pvn</dt>
  <dd>Allocates a place in the currently-compiling pad for a named lexical
      variable. Stores the name and other metadata in the name part of the pad,
      and makes preparations to manage the variable's lexical scoping. Returns
      the offset of the allocated pad slot.
    <p class="Pp"><span class="Li">&quot;namepv&quot;</span>/<span class="Li">&quot;namelen&quot;</span>
        specify the variable's name, including leading sigil. If
        <span class="Li">&quot;typestash&quot;</span> is non-null, the name is
        for a typed lexical, and this identifies the type. If
        <span class="Li">&quot;ourstash&quot;</span> is non-null, it's a lexical
        reference to a package variable, and this identifies the package. The
        following flags can be OR'ed together:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 padadd_OUR          redundantly specifies if it's a package var
 padadd_STATE        variable will retain value persistently
 padadd_NO_DUP_CHECK skip check for lexical shadowing

        PADOFFSET pad_add_name_pvn(const char *namepv,
                                   STRLEN namelen, U32 flags,
                                   HV *typestash, HV *ourstash)
    </pre>
  </dd>
  <dt>pad_add_name_sv</dt>
  <dd>Exactly like &quot;pad_add_name_pvn&quot;, but takes the name string in
      the form of an SV instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_add_name_sv(SV *name, U32 flags,
                                  HV *typestash, HV *ourstash)
    </pre>
  </dd>
  <dt>pad_alloc</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Allocates a place in the currently-compiling pad, returning
        the offset of the allocated pad slot. No name is initially attached to
        the pad slot. <span class="Li">&quot;tmptype&quot;</span> is a set of
        flags indicating the kind of pad entry required, which will be set in
        the value SV for the allocated pad entry:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    SVs_PADMY    named lexical variable (&quot;my&quot;, &quot;our&quot;, &quot;state&quot;)
    SVs_PADTMP   unnamed temporary store
    SVf_READONLY constant shared between recursion levels
    </pre>
    <p class="Pp"><span class="Li">&quot;SVf_READONLY&quot;</span> has been
        supported here only since perl 5.20. To work with earlier versions as
        well, use <span class="Li">&quot;SVf_READONLY|SVs_PADTMP&quot;</span>.
        <span class="Li">&quot;SVf_READONLY&quot;</span> does not cause the SV
        in the pad slot to be marked read-only, but simply tells
        <span class="Li">&quot;pad_alloc&quot;</span> that it <i>will</i> be
        made read-only (by the caller), or at least should be treated as
      such.</p>
    <p class="Pp"><span class="Li">&quot;optype&quot;</span> should be an opcode
        indicating the type of operation that the pad entry is to support. This
        doesn't affect operational semantics, but is used for debugging.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_alloc(I32 optype, U32 tmptype)
    </pre>
  </dd>
  <dt>pad_findmy_pv</dt>
  <dd>Exactly like &quot;pad_findmy_pvn&quot;, but takes a nul-terminated string
      instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_findmy_pv(const char *name, U32 flags)
    </pre>
  </dd>
  <dt>pad_findmy_pvn</dt>
  <dd>Given the name of a lexical variable, find its position in the
      currently-compiling pad.
      <span class="Li">&quot;namepv&quot;</span>/<span class="Li">&quot;namelen&quot;</span>
      specify the variable's name, including leading sigil.
      <span class="Li">&quot;flags&quot;</span> is reserved and must be zero. If
      it is not in the current pad but appears in the pad of any lexically
      enclosing scope, then a pseudo-entry for it is added in the current pad.
      Returns the offset in the current pad, or
      <span class="Li">&quot;NOT_IN_PAD&quot;</span> if no such lexical is in
      scope.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_findmy_pvn(const char *namepv,
                                 STRLEN namelen, U32 flags)
    </pre>
  </dd>
  <dt>pad_findmy_sv</dt>
  <dd>Exactly like &quot;pad_findmy_pvn&quot;, but takes the name string in the
      form of an SV instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_findmy_sv(SV *name, U32 flags)
    </pre>
  </dd>
  <dt>padnamelist_fetch</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Fetches the pad name from the given index.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADNAME * padnamelist_fetch(PADNAMELIST *pnl,
                                    SSize_t key)
    </pre>
  </dd>
  <dt>padnamelist_store</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Stores the pad name (which may be null) at the given index,
        freeing any existing pad name in that slot.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADNAME ** padnamelist_store(PADNAMELIST *pnl,
                                     SSize_t key, PADNAME *val)
    </pre>
  </dd>
  <dt>pad_setsv</dt>
  <dd>Set the value at offset <span class="Li">&quot;po&quot;</span> in the
      current (compiling or executing) pad. Use the macro
      <span class="Li">&quot;PAD_SETSV()&quot;</span> rather than calling this
      function directly.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pad_setsv(PADOFFSET po, SV *sv)
    </pre>
  </dd>
  <dt>pad_sv</dt>
  <dd>Get the value at offset <span class="Li">&quot;po&quot;</span> in the
      current (compiling or executing) pad. Use macro
      <span class="Li">&quot;PAD_SV&quot;</span> instead of calling this
      function directly.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    pad_sv(PADOFFSET po)
    </pre>
  </dd>
  <dt>pad_tidy</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Tidy up a pad at the end of compilation of the code to which
        it belongs. Jobs performed here are: remove most stuff from the pads of
        anonsub prototypes; give it a <span class="Li">@_</span>; mark
        temporaries as such. <span class="Li">&quot;type&quot;</span> indicates
        the kind of subroutine:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    padtidy_SUB        ordinary subroutine
    padtidy_SUBCLONE   prototype for lexical closure
    padtidy_FORMAT     format

        void    pad_tidy(padtidy_type type)
    </pre>
  </dd>
  <dt>perl_alloc</dt>
  <dd>Allocates a new Perl interpreter. See perlembed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PerlInterpreter* perl_alloc()
    </pre>
  </dd>
  <dt>perl_construct</dt>
  <dd>Initializes a new Perl interpreter. See perlembed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    perl_construct(PerlInterpreter *my_perl)
    </pre>
  </dd>
  <dt>perl_destruct</dt>
  <dd>Shuts down a Perl interpreter. See perlembed for a tutorial.
    <p class="Pp"><span class="Li">&quot;my_perl&quot;</span> points to the Perl
        interpreter. It must have been previously created through the use of
        &quot;perl_alloc&quot; and &quot;perl_construct&quot;. It may have been
        initialised through &quot;perl_parse&quot;, and may have been used
        through &quot;perl_run&quot; and other means. This function should be
        called for any Perl interpreter that has been constructed with
        &quot;perl_construct&quot;, even if subsequent operations on it failed,
        for example if &quot;perl_parse&quot; returned a non-zero value.</p>
    <p class="Pp">If the interpreter's
        <span class="Li">&quot;PL_exit_flags&quot;</span> word has the
        <span class="Li">&quot;PERL_EXIT_DESTRUCT_END&quot;</span> flag set,
        then this function will execute code in
        <span class="Li">&quot;END&quot;</span> blocks before performing the
        rest of destruction. If it is desired to make any use of the interpreter
        between &quot;perl_parse&quot; and &quot;perl_destruct&quot; other than
        just calling &quot;perl_run&quot;, then this flag should be set early
        on. This matters if &quot;perl_run&quot; will not be called, or if
        anything else will be done in addition to calling
      &quot;perl_run&quot;.</p>
    <p class="Pp">Returns a value be a suitable value to pass to the C library
        function <span class="Li">&quot;exit&quot;</span> (or to return from
        <span class="Li">&quot;main&quot;</span>), to serve as an exit code
        indicating the nature of the way the interpreter terminated. This takes
        into account any failure of &quot;perl_parse&quot; and any early exit
        from &quot;perl_run&quot;. The exit code is of the type required by the
        host operating system, so because of differing exit code conventions it
        is not portable to interpret specific numeric values as having specific
        meanings.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     perl_destruct(PerlInterpreter *my_perl)
    </pre>
  </dd>
  <dt>perl_free</dt>
  <dd>Releases a Perl interpreter. See perlembed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    perl_free(PerlInterpreter *my_perl)
    </pre>
  </dd>
  <dt>perl_parse</dt>
  <dd>Tells a Perl interpreter to parse a Perl script. This performs most of the
      initialisation of a Perl interpreter. See perlembed for a tutorial.
    <p class="Pp"><span class="Li">&quot;my_perl&quot;</span> points to the Perl
        interpreter that is to parse the script. It must have been previously
        created through the use of &quot;perl_alloc&quot; and
        &quot;perl_construct&quot;. <span class="Li">&quot;xsinit&quot;</span>
        points to a callback function that will be called to set up the ability
        for this Perl interpreter to load XS extensions, or may be null to
        perform no such setup.</p>
    <p class="Pp"><span class="Li">&quot;argc&quot;</span> and
        <span class="Li">&quot;argv&quot;</span> supply a set of command-line
        arguments to the Perl interpreter, as would normally be passed to the
        <span class="Li">&quot;main&quot;</span> function of a C program.
        <span class="Li">&quot;argv[argc]&quot;</span> must be null. These
        arguments are where the script to parse is specified, either by naming a
        script file or by providing a script in a
        <span class="Li">&quot;-e&quot;</span> option. If
        <span class="Li">$0</span> will be written to in the Perl interpreter,
        then the argument strings must be in writable memory, and so mustn't
        just be string constants.</p>
    <p class="Pp"><span class="Li">&quot;env&quot;</span> specifies a set of
        environment variables that will be used by this Perl interpreter. If
        non-null, it must point to a null-terminated array of environment
        strings. If null, the Perl interpreter will use the environment supplied
        by the <span class="Li">&quot;environ&quot;</span> global variable.</p>
    <p class="Pp">This function initialises the interpreter, and parses and
        compiles the script specified by the command-line arguments. This
        includes executing code in <span class="Li">&quot;BEGIN&quot;</span>,
        <span class="Li">&quot;UNITCHECK&quot;</span>, and
        <span class="Li">&quot;CHECK&quot;</span> blocks. It does not execute
        <span class="Li">&quot;INIT&quot;</span> blocks or the main program.</p>
    <p class="Pp">Returns an integer of slightly tricky interpretation. The
        correct use of the return value is as a truth value indicating whether
        there was a failure in initialisation. If zero is returned, this
        indicates that initialisation was successful, and it is safe to proceed
        to call &quot;perl_run&quot; and make other use of it. If a non-zero
        value is returned, this indicates some problem that means the
        interpreter wants to terminate. The interpreter should not be just
        abandoned upon such failure; the caller should proceed to shut the
        interpreter down cleanly with &quot;perl_destruct&quot; and free it with
        &quot;perl_free&quot;.</p>
    <p class="Pp">For historical reasons, the non-zero return value also
        attempts to be a suitable value to pass to the C library function
        <span class="Li">&quot;exit&quot;</span> (or to return from
        <span class="Li">&quot;main&quot;</span>), to serve as an exit code
        indicating the nature of the way initialisation terminated. However,
        this isn't portable, due to differing exit code conventions. A
        historical bug is preserved for the time being: if the Perl built-in
        <span class="Li">&quot;exit&quot;</span> is called during this
        function's execution, with a type of exit entailing a zero exit code
        under the host operating system's conventions, then this function
        returns zero rather than a non-zero value. This bug, [perl #2754], leads
        to <span class="Li">&quot;perl_run&quot;</span> being called (and
        therefore <span class="Li">&quot;INIT&quot;</span> blocks and the main
        program running) despite a call to
        <span class="Li">&quot;exit&quot;</span>. It has been preserved because
        a popular module-installing module has come to rely on it and needs time
        to be fixed. This issue is [perl #132577], and the original bug is due
        to be fixed in Perl 5.30.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     perl_parse(PerlInterpreter *my_perl,
                           XSINIT_t xsinit, int argc,
                           char **argv, char **env)
    </pre>
  </dd>
  <dt>perl_run</dt>
  <dd>Tells a Perl interpreter to run its main program. See perlembed for a
      tutorial.
    <p class="Pp"><span class="Li">&quot;my_perl&quot;</span> points to the Perl
        interpreter. It must have been previously created through the use of
        &quot;perl_alloc&quot; and &quot;perl_construct&quot;, and initialised
        through &quot;perl_parse&quot;. This function should not be called if
        &quot;perl_parse&quot; returned a non-zero value, indicating a failure
        in initialisation or compilation.</p>
    <p class="Pp">This function executes code in
        <span class="Li">&quot;INIT&quot;</span> blocks, and then executes the
        main program. The code to be executed is that established by the prior
        call to &quot;perl_parse&quot;. If the interpreter's
        <span class="Li">&quot;PL_exit_flags&quot;</span> word does not have the
        <span class="Li">&quot;PERL_EXIT_DESTRUCT_END&quot;</span> flag set,
        then this function will also execute code in
        <span class="Li">&quot;END&quot;</span> blocks. If it is desired to make
        any further use of the interpreter after calling this function, then
        <span class="Li">&quot;END&quot;</span> blocks should be postponed to
        &quot;perl_destruct&quot; time by setting that flag.</p>
    <p class="Pp">Returns an integer of slightly tricky interpretation. The
        correct use of the return value is as a truth value indicating whether
        the program terminated non-locally. If zero is returned, this indicates
        that the program ran to completion, and it is safe to make other use of
        the interpreter (provided that the
        <span class="Li">&quot;PERL_EXIT_DESTRUCT_END&quot;</span> flag was set
        as described above). If a non-zero value is returned, this indicates
        that the interpreter wants to terminate early. The interpreter should
        not be just abandoned because of this desire to terminate; the caller
        should proceed to shut the interpreter down cleanly with
        &quot;perl_destruct&quot; and free it with &quot;perl_free&quot;.</p>
    <p class="Pp">For historical reasons, the non-zero return value also
        attempts to be a suitable value to pass to the C library function
        <span class="Li">&quot;exit&quot;</span> (or to return from
        <span class="Li">&quot;main&quot;</span>), to serve as an exit code
        indicating the nature of the way the program terminated. However, this
        isn't portable, due to differing exit code conventions. An attempt is
        made to return an exit code of the type required by the host operating
        system, but because it is constrained to be non-zero, it is not
        necessarily possible to indicate every type of exit. It is only reliable
        on Unix, where a zero exit code can be augmented with a set bit that
        will be ignored. In any case, this function is not the correct place to
        acquire an exit code: one should get that from
        &quot;perl_destruct&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     perl_run(PerlInterpreter *my_perl)
    </pre>
  </dd>
  <dt>require_pv</dt>
  <dd>Tells Perl to <span class="Li">&quot;require&quot;</span> the file named
      by the string argument. It is analogous to the Perl code
      <span class="Li">&quot;eval &quot;require '$file'&quot;&quot;</span>. It's
      even implemented that way; consider using load_module instead.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    require_pv(const char* pv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Exception_Handling_(simple)_Macros"><a class="permalink" href="#Exception_Handling_(simple)_Macros">Exception
  Handling (simple) Macros</a></h1>
<dl class="Bl-tag">
  <dt>dXCPT</dt>
  <dd>Set up necessary local variables for exception handling. See
      &quot;Exception Handling&quot; in perlguts.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dXCPT;
    </pre>
  </dd>
  <dt>XCPT_CATCH</dt>
  <dd>Introduces a catch block. See &quot;Exception Handling&quot; in
    perlguts.</dd>
  <dt>XCPT_RETHROW</dt>
  <dd>Rethrows a previously caught exception. See &quot;Exception Handling&quot;
      in perlguts.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XCPT_RETHROW;
    </pre>
  </dd>
  <dt>XCPT_TRY_END</dt>
  <dd>Ends a try block. See &quot;Exception Handling&quot; in perlguts.</dd>
  <dt>XCPT_TRY_START</dt>
  <dd>Starts a try block. See &quot;Exception Handling&quot; in perlguts.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_pp_sort.c"><a class="permalink" href="#Functions_in_file_pp_sort.c">Functions
  in file pp_sort.c</a></h1>
<dl class="Bl-tag">
  <dt>sortsv_flags</dt>
  <dd>In-place sort an array of SV pointers with the given comparison routine,
      with various SORTf_* flag options.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sortsv_flags(SV** array, size_t num_elts,
                             SVCOMPARE_t cmp, U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_scope.c"><a class="permalink" href="#Functions_in_file_scope.c">Functions
  in file scope.c</a></h1>
<dl class="Bl-tag">
  <dt>save_gp</dt>
  <dd>Saves the current GP of gv on the save stack to be restored on scope exit.
    <p class="Pp">If empty is true, replace the GP with a new GP.</p>
    <p class="Pp">If empty is false, mark gv with GVf_INTRO so the next
        reference assigned is localized, which is how <span class="Li">&quot;
        local *foo = $someref; &quot;</span> works.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    save_gp(GV* gv, I32 empty)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_vutil.c"><a class="permalink" href="#Functions_in_file_vutil.c">Functions
  in file vutil.c</a></h1>
<dl class="Bl-tag">
  <dt>new_version</dt>
  <dd>Returns a new version object based on the passed in SV:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    SV *sv = new_version(SV *ver);
    </pre>
    <p class="Pp">Does not alter the passed in ver SV. See
        &quot;upg_version&quot; if you want to upgrade the SV.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     new_version(SV *ver)
    </pre>
  </dd>
  <dt>prescan_version</dt>
  <dd>Validate that a given string can be parsed as a version object, but
      doesn't actually perform the parsing. Can use either strict or lax
      validation rules. Can optionally set a number of hint variables to save
      the parsing code some time when tokenizing.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char* prescan_version(const char *s, bool strict,
                                    const char** errstr,
                                    bool *sqv,
                                    int *ssaw_decimal,
                                    int *swidth, bool *salpha)
    </pre>
  </dd>
  <dt>scan_version</dt>
  <dd>Returns a pointer to the next character after the parsed version string,
      as well as upgrading the passed in SV to an RV.
    <p class="Pp">Function must be called with an already existing SV like</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    sv = newSV(0);
    s = scan_version(s, SV *sv, bool qv);
    </pre>
    <p class="Pp">Performs some preprocessing to the string to ensure that it
        has the correct characteristics of a version. Flags the object if it
        contains an underscore (which denotes this is an alpha version). The
        boolean qv denotes that the version should be interpreted as if it had
        multiple decimals, even if it doesn't.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char* scan_version(const char *s, SV *rv, bool qv)
    </pre>
  </dd>
  <dt>upg_version</dt>
  <dd>In-place upgrade of the supplied SV to a version object.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    SV *sv = upg_version(SV *sv, bool qv);
    </pre>
    <p class="Pp">Returns a pointer to the upgraded SV. Set the boolean qv if
        you want to force this SV to be interpreted as an &quot;extended&quot;
        version.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     upg_version(SV *ver, bool qv)
    </pre>
  </dd>
  <dt>vcmp</dt>
  <dd>Version object aware cmp. Both operands must already have been converted
      into version objects.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     vcmp(SV *lhv, SV *rhv)
    </pre>
  </dd>
  <dt>vnormal</dt>
  <dd>Accepts a version object and returns the normalized string representation.
      Call like:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    sv = vnormal(rv);
    </pre>
    <p class="Pp">NOTE: you can pass either the object directly or the SV
        contained within the RV.</p>
    <p class="Pp">The SV returned has a refcount of 1.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     vnormal(SV *vs)
    </pre>
  </dd>
  <dt>vnumify</dt>
  <dd>Accepts a version object and returns the normalized floating point
      representation. Call like:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    sv = vnumify(rv);
    </pre>
    <p class="Pp">NOTE: you can pass either the object directly or the SV
        contained within the RV.</p>
    <p class="Pp">The SV returned has a refcount of 1.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     vnumify(SV *vs)
    </pre>
  </dd>
  <dt>vstringify</dt>
  <dd>In order to maintain maximum compatibility with earlier versions of Perl,
      this function will return either the floating point notation or the
      multiple dotted notation, depending on whether the original version
      contained 1 or more dots, respectively.
    <p class="Pp">The SV returned has a refcount of 1.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     vstringify(SV *vs)
    </pre>
  </dd>
  <dt>vverify</dt>
  <dd>Validates that the SV contains valid internal structure for a version
      object. It may be passed either the version object (RV) or the hash itself
      (HV). If the structure is valid, it returns the HV. If the structure is
      invalid, it returns NULL.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    SV *hv = vverify(sv);
    </pre>
    <p class="Pp">Note that it only confirms the bare minimum structure (so as
        not to get confused by derived classes which may contain additional hash
        entries):</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>The SV is an HV or a reference to an HV</li>
  <li>The hash contains a &quot;version&quot; key</li>
  <li>The &quot;version&quot; key has a reference to an AV as its value</li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp"><span class="Li"></span></p>
<pre>
        SV*     vverify(SV *vs)
</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="_Gimme__Values"><a class="permalink" href="#_Gimme__Values">&quot;Gimme&quot;
  Values</a></h1>
<dl class="Bl-tag">
  <dt>G_ARRAY</dt>
  <dd>Used to indicate list context. See
      <span class="Li">&quot;GIMME_V&quot;</span>,
      <span class="Li">&quot;GIMME&quot;</span> and perlcall.</dd>
  <dt>G_DISCARD</dt>
  <dd>Indicates that arguments returned from a callback should be discarded. See
      perlcall.</dd>
  <dt>G_EVAL</dt>
  <dd>Used to force a Perl <span class="Li">&quot;eval&quot;</span> wrapper
      around a callback. See perlcall.</dd>
  <dt>GIMME</dt>
  <dd>A backward-compatible version of
      <span class="Li">&quot;GIMME_V&quot;</span> which can only return
      <span class="Li">&quot;G_SCALAR&quot;</span> or
      <span class="Li">&quot;G_ARRAY&quot;</span>; in a void context, it returns
      <span class="Li">&quot;G_SCALAR&quot;</span>. Deprecated. Use
      <span class="Li">&quot;GIMME_V&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     GIMME
    </pre>
  </dd>
  <dt>GIMME_V</dt>
  <dd>The XSUB-writer's equivalent to Perl's
      <span class="Li">&quot;wantarray&quot;</span>. Returns
      <span class="Li">&quot;G_VOID&quot;</span>,
      <span class="Li">&quot;G_SCALAR&quot;</span> or
      <span class="Li">&quot;G_ARRAY&quot;</span> for void, scalar or list
      context, respectively. See perlcall for a usage example.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     GIMME_V
    </pre>
  </dd>
  <dt>G_NOARGS</dt>
  <dd>Indicates that no arguments are being sent to a callback. See
    perlcall.</dd>
  <dt>G_SCALAR</dt>
  <dd>Used to indicate scalar context. See
      <span class="Li">&quot;GIMME_V&quot;</span>,
      <span class="Li">&quot;GIMME&quot;</span>, and perlcall.</dd>
  <dt>G_VOID</dt>
  <dd>Used to indicate void context. See
      <span class="Li">&quot;GIMME_V&quot;</span> and perlcall.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Global_Variables"><a class="permalink" href="#Global_Variables">Global
  Variables</a></h1>
These variables are global to an entire process. They are shared between all
  interpreters and all threads in a process. Any variables not documented here
  may be changed or removed without notice, so don't use them! If you feel you
  really do need to use an unlisted variable, first send email to
  perl5-porters@perl.org &lt;mailto:perl5-porters@perl.org&gt;. It may be that
  someone there will point out a way to accomplish what you need without using
  an internal variable. But if not, you should get a go-ahead to document and
  then use the variable.
<dl class="Bl-tag">
  <dt>PL_check</dt>
  <dd>Array, indexed by opcode, of functions that will be called for the
      &quot;check&quot; phase of optree building during compilation of Perl
      code. For most (but not all) types of op, once the op has been initially
      built and populated with child ops it will be filtered through the check
      function referenced by the appropriate element of this array. The new op
      is passed in as the sole argument to the check function, and the check
      function returns the completed op. The check function may (as the name
      suggests) check the op for validity and signal errors. It may also
      initialise or modify parts of the ops, or perform more radical surgery
      such as adding or removing child ops, or even throw the op away and return
      a different op in its place.
    <p class="Pp">This array of function pointers is a convenient place to hook
        into the compilation process. An XS module can put its own custom check
        function in place of any of the standard ones, to influence the
        compilation of a particular type of op. However, a custom check function
        must never fully replace a standard check function (or even a custom
        check function from another module). A module modifying checking must
        instead <b>wrap</b> the preexisting check function. A custom check
        function must be selective about when to apply its custom behaviour. In
        the usual case where it decides not to do anything special with an op,
        it must chain the preexisting op function. Check functions are thus
        linked in a chain, with the core's base checker at the end.</p>
    <p class="Pp">For thread safety, modules should not write directly to this
        array. Instead, use the function &quot;wrap_op_checker&quot;.</p>
  </dd>
  <dt>PL_keyword_plugin</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Function pointer, pointing at a function used to handle
        extended keywords. The function should be declared as</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int keyword_plugin_function(pTHX_
                char *keyword_ptr, STRLEN keyword_len,
                OP **op_ptr)
    </pre>
    <p class="Pp">The function is called from the tokeniser, whenever a possible
        keyword is seen. <span class="Li">&quot;keyword_ptr&quot;</span> points
        at the word in the parser's input buffer, and
        <span class="Li">&quot;keyword_len&quot;</span> gives its length; it is
        not null-terminated. The function is expected to examine the word, and
        possibly other state such as %^H, to decide whether it wants to handle
        it as an extended keyword. If it does not, the function should return
        <span class="Li">&quot;KEYWORD_PLUGIN_DECLINE&quot;</span>, and the
        normal parser process will continue.</p>
    <p class="Pp">If the function wants to handle the keyword, it first must
        parse anything following the keyword that is part of the syntax
        introduced by the keyword. See &quot;Lexer interface&quot; for
      details.</p>
    <p class="Pp">When a keyword is being handled, the plugin function must
        build a tree of <span class="Li">&quot;OP&quot;</span> structures,
        representing the code that was parsed. The root of the tree must be
        stored in <span class="Li">*op_ptr</span>. The function then returns a
        constant indicating the syntactic role of the construct that it has
        parsed: <span class="Li">&quot;KEYWORD_PLUGIN_STMT&quot;</span> if it is
        a complete statement, or
        <span class="Li">&quot;KEYWORD_PLUGIN_EXPR&quot;</span> if it is an
        expression. Note that a statement construct cannot be used inside an
        expression (except via <span class="Li">&quot;do BLOCK&quot;</span> and
        similar), and an expression is not a complete statement (it requires at
        least a terminating semicolon).</p>
    <p class="Pp">When a keyword is handled, the plugin function may also have
        (compile-time) side effects. It may modify
        <span class="Li">&quot;%^H&quot;</span>, define functions, and so on.
        Typically, if side effects are the main purpose of a handler, it does
        not wish to generate any ops to be included in the normal compilation.
        In this case it is still required to supply an op tree, but it suffices
        to generate a single null op.</p>
    <p class="Pp">That's how the <span class="Li">*PL_keyword_plugin</span>
        function needs to behave overall. Conventionally, however, one does not
        completely replace the existing handler function. Instead, take a copy
        of <span class="Li">&quot;PL_keyword_plugin&quot;</span> before
        assigning your own function pointer to it. Your handler function should
        look for keywords that it is interested in and handle those. Where it is
        not interested, it should call the saved plugin function, passing on the
        arguments it received. Thus
        <span class="Li">&quot;PL_keyword_plugin&quot;</span> actually points at
        a chain of handler functions, all of which have an opportunity to handle
        keywords, and only the last function in the chain (built into the Perl
        core) will normally return
        <span class="Li">&quot;KEYWORD_PLUGIN_DECLINE&quot;</span>.</p>
    <p class="Pp">For thread safety, modules should not set this variable
        directly. Instead, use the function &quot;wrap_keyword_plugin&quot;.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="GV_Functions"><a class="permalink" href="#GV_Functions">GV
  Functions</a></h1>
A GV is a structure which corresponds to to a Perl typeglob, ie *foo. It is a
  structure that holds a pointer to a scalar, an array, a hash etc,
  corresponding to <span class="Li">$foo</span>, <span class="Li">@foo</span>,
  <span class="Li">%foo</span>.
<p class="Pp">GVs are usually found as values in stashes (symbol table hashes)
    where Perl stores its global variables.</p>
<dl class="Bl-tag">
  <dt>GvAV</dt>
  <dd>Return the AV from the GV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        AV*     GvAV(GV* gv)
    </pre>
  </dd>
  <dt>gv_const_sv</dt>
  <dd>If <span class="Li">&quot;gv&quot;</span> is a typeglob whose subroutine
      entry is a constant sub eligible for inlining, or
      <span class="Li">&quot;gv&quot;</span> is a placeholder reference that
      would be promoted to such a typeglob, then returns the value returned by
      the sub. Otherwise, returns <span class="Li">&quot;NULL&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     gv_const_sv(GV* gv)
    </pre>
  </dd>
  <dt>GvCV</dt>
  <dd>Return the CV from the GV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV*     GvCV(GV* gv)
    </pre>
  </dd>
  <dt>gv_fetchmeth</dt>
  <dd>Like &quot;gv_fetchmeth_pvn&quot;, but lacks a flags parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth(HV* stash, const char* name,
                             STRLEN len, I32 level)
    </pre>
  </dd>
  <dt>gv_fetchmethod_autoload</dt>
  <dd>Returns the glob which contains the subroutine to call to invoke the
      method on the <span class="Li">&quot;stash&quot;</span>. In fact in the
      presence of autoloading this may be the glob for &quot;AUTOLOAD&quot;. In
      this case the corresponding variable <span class="Li">$AUTOLOAD</span> is
      already setup.
    <p class="Pp">The third parameter of
        <span class="Li">&quot;gv_fetchmethod_autoload&quot;</span> determines
        whether AUTOLOAD lookup is performed if the given method is not present:
        non-zero means yes, look for AUTOLOAD; zero means no, don't look for
        AUTOLOAD. Calling <span class="Li">&quot;gv_fetchmethod&quot;</span> is
        equivalent to calling
        <span class="Li">&quot;gv_fetchmethod_autoload&quot;</span> with a
        non-zero <span class="Li">&quot;autoload&quot;</span> parameter.</p>
    <p class="Pp">These functions grant
        <span class="Li">&quot;SUPER&quot;</span> token as a prefix of the
        method name. Note that if you want to keep the returned glob for a long
        time, you need to check for it being &quot;AUTOLOAD&quot;, since at the
        later time the call may load a different subroutine due to
        <span class="Li">$AUTOLOAD</span> changing its value. Use the glob
        created as a side effect to do this.</p>
    <p class="Pp">These functions have the same side-effects as
        <span class="Li">&quot;gv_fetchmeth&quot;</span> with
        <span class="Li">&quot;level==0&quot;</span>. The warning against
        passing the GV returned by
        <span class="Li">&quot;gv_fetchmeth&quot;</span> to
        <span class="Li">&quot;call_sv&quot;</span> applies equally to these
        functions.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmethod_autoload(HV* stash,
                                        const char* name,
                                        I32 autoload)
    </pre>
  </dd>
  <dt>gv_fetchmeth_autoload</dt>
  <dd>This is the old form of &quot;gv_fetchmeth_pvn_autoload&quot;, which has
      no flags parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_autoload(HV* stash,
                                      const char* name,
                                      STRLEN len, I32 level)
    </pre>
  </dd>
  <dt>gv_fetchmeth_pv</dt>
  <dd>Exactly like &quot;gv_fetchmeth_pvn&quot;, but takes a nul-terminated
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_pv(HV* stash, const char* name,
                                I32 level, U32 flags)
    </pre>
  </dd>
  <dt>gv_fetchmeth_pvn</dt>
  <dd>Returns the glob with the given <span class="Li">&quot;name&quot;</span>
      and a defined subroutine or <span class="Li">&quot;NULL&quot;</span>. The
      glob lives in the given <span class="Li">&quot;stash&quot;</span>, or in
      the stashes accessible via <span class="Li">@ISA</span> and
      <span class="Li">&quot;UNIVERSAL::&quot;</span>.
    <p class="Pp">The argument <span class="Li">&quot;level&quot;</span> should
        be either 0 or -1. If <span class="Li">&quot;level==0&quot;</span>, as a
        side-effect creates a glob with the given
        <span class="Li">&quot;name&quot;</span> in the given
        <span class="Li">&quot;stash&quot;</span> which in the case of success
        contains an alias for the subroutine, and sets up caching info for this
        glob.</p>
    <p class="Pp">The only significant values for
        <span class="Li">&quot;flags&quot;</span> are
        <span class="Li">&quot;GV_SUPER&quot;</span> and
        <span class="Li">&quot;SVf_UTF8&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;GV_SUPER&quot;</span> indicates that we
        want to look up the method in the superclasses of the
        <span class="Li">&quot;stash&quot;</span>.</p>
    <p class="Pp">The GV returned from
        <span class="Li">&quot;gv_fetchmeth&quot;</span> may be a method cache
        entry, which is not visible to Perl code. So when calling
        <span class="Li">&quot;call_sv&quot;</span>, you should not use the GV
        directly; instead, you should use the method's CV, which can be obtained
        from the GV with the <span class="Li">&quot;GvCV&quot;</span> macro.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_pvn(HV* stash, const char* name,
                                 STRLEN len, I32 level,
                                 U32 flags)
    </pre>
  </dd>
  <dt>gv_fetchmeth_pvn_autoload</dt>
  <dd>Same as <span class="Li">&quot;gv_fetchmeth_pvn()&quot;</span>, but looks
      for autoloaded subroutines too. Returns a glob for the subroutine.
    <p class="Pp">For an autoloaded subroutine without a GV, will create a GV
        even if <span class="Li">&quot;level &lt; 0&quot;</span>. For an
        autoloaded subroutine without a stub,
        <span class="Li">&quot;GvCV()&quot;</span> of the result may be
      zero.</p>
    <p class="Pp">Currently, the only significant value for
        <span class="Li">&quot;flags&quot;</span> is
        <span class="Li">&quot;SVf_UTF8&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_pvn_autoload(HV* stash,
                                          const char* name,
                                          STRLEN len, I32 level,
                                          U32 flags)
    </pre>
  </dd>
  <dt>gv_fetchmeth_pv_autoload</dt>
  <dd>Exactly like &quot;gv_fetchmeth_pvn_autoload&quot;, but takes a
      nul-terminated string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_pv_autoload(HV* stash,
                                         const char* name,
                                         I32 level, U32 flags)
    </pre>
  </dd>
  <dt>gv_fetchmeth_sv</dt>
  <dd>Exactly like &quot;gv_fetchmeth_pvn&quot;, but takes the name string in
      the form of an SV instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_sv(HV* stash, SV* namesv,
                                I32 level, U32 flags)
    </pre>
  </dd>
  <dt>gv_fetchmeth_sv_autoload</dt>
  <dd>Exactly like &quot;gv_fetchmeth_pvn_autoload&quot;, but takes the name
      string in the form of an SV instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmeth_sv_autoload(HV* stash, SV* namesv,
                                         I32 level, U32 flags)
    </pre>
  </dd>
  <dt>GvHV</dt>
  <dd>Return the HV from the GV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     GvHV(GV* gv)
    </pre>
  </dd>
  <dt>gv_init</dt>
  <dd>The old form of <span class="Li">&quot;gv_init_pvn()&quot;</span>. It does
      not work with UTF-8 strings, as it has no flags parameter. If the
      <span class="Li">&quot;multi&quot;</span> parameter is set, the
      <span class="Li">&quot;GV_ADDMULTI&quot;</span> flag will be passed to
      <span class="Li">&quot;gv_init_pvn()&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    gv_init(GV* gv, HV* stash, const char* name,
                        STRLEN len, int multi)
    </pre>
  </dd>
  <dt>gv_init_pv</dt>
  <dd>Same as <span class="Li">&quot;gv_init_pvn()&quot;</span>, but takes a
      nul-terminated string for the name instead of separate char * and length
      parameters.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    gv_init_pv(GV* gv, HV* stash, const char* name,
                           U32 flags)
    </pre>
  </dd>
  <dt>gv_init_pvn</dt>
  <dd>Converts a scalar into a typeglob. This is an incoercible typeglob;
      assigning a reference to it will assign to one of its slots, instead of
      overwriting it as happens with typeglobs created by
      <span class="Li">&quot;SvSetSV&quot;</span>. Converting any scalar that is
      <span class="Li">&quot;SvOK()&quot;</span> may produce unpredictable
      results and is reserved for perl's internal use.
    <p class="Pp"><span class="Li">&quot;gv&quot;</span> is the scalar to be
        converted.</p>
    <p class="Pp"><span class="Li">&quot;stash&quot;</span> is the parent
        stash/package, if any.</p>
    <p class="Pp"><span class="Li">&quot;name&quot;</span> and
        <span class="Li">&quot;len&quot;</span> give the name. The name must be
        unqualified; that is, it must not include the package name. If
        <span class="Li">&quot;gv&quot;</span> is a stash element, it is the
        caller's responsibility to ensure that the name passed to this function
        matches the name of the element. If it does not match, perl's internal
        bookkeeping will get out of sync.</p>
    <p class="Pp"><span class="Li">&quot;flags&quot;</span> can be set to
        <span class="Li">&quot;SVf_UTF8&quot;</span> if
        <span class="Li">&quot;name&quot;</span> is a UTF-8 string, or the
        return value of SvUTF8(sv). It can also take the
        <span class="Li">&quot;GV_ADDMULTI&quot;</span> flag, which means to
        pretend that the GV has been seen before (i.e., suppress &quot;Used
        once&quot; warnings).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    gv_init_pvn(GV* gv, HV* stash, const char* name,
                            STRLEN len, U32 flags)
    </pre>
  </dd>
  <dt>gv_init_sv</dt>
  <dd>Same as <span class="Li">&quot;gv_init_pvn()&quot;</span>, but takes an SV
      * for the name instead of separate char * and length parameters.
      <span class="Li">&quot;flags&quot;</span> is currently unused.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    gv_init_sv(GV* gv, HV* stash, SV* namesv,
                           U32 flags)
    </pre>
  </dd>
  <dt>gv_stashpv</dt>
  <dd>Returns a pointer to the stash for a specified package. Uses
      <span class="Li">&quot;strlen&quot;</span> to determine the length of
      <span class="Li">&quot;name&quot;</span>, then calls
      <span class="Li">&quot;gv_stashpvn()&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     gv_stashpv(const char* name, I32 flags)
    </pre>
  </dd>
  <dt>gv_stashpvn</dt>
  <dd>Returns a pointer to the stash for a specified package. The
      <span class="Li">&quot;namelen&quot;</span> parameter indicates the length
      of the <span class="Li">&quot;name&quot;</span>, in bytes.
      <span class="Li">&quot;flags&quot;</span> is passed to
      <span class="Li">&quot;gv_fetchpvn_flags()&quot;</span>, so if set to
      <span class="Li">&quot;GV_ADD&quot;</span> then the package will be
      created if it does not already exist. If the package does not exist and
      <span class="Li">&quot;flags&quot;</span> is 0 (or any other setting that
      does not create packages) then <span class="Li">&quot;NULL&quot;</span> is
      returned.
    <p class="Pp">Flags may be one of:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    GV_ADD
    SVf_UTF8
    GV_NOADD_NOINIT
    GV_NOINIT
    GV_NOEXPAND
    GV_ADDMG
    </pre>
    <p class="Pp">The most important of which are probably
        <span class="Li">&quot;GV_ADD&quot;</span> and
        <span class="Li">&quot;SVf_UTF8&quot;</span>.</p>
    <p class="Pp">Note, use of <span class="Li">&quot;gv_stashsv&quot;</span>
        instead of <span class="Li">&quot;gv_stashpvn&quot;</span> where
        possible is strongly recommended for performance reasons.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     gv_stashpvn(const char* name, U32 namelen,
                            I32 flags)
    </pre>
  </dd>
  <dt>gv_stashpvs</dt>
  <dd>Like <span class="Li">&quot;gv_stashpvn&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     gv_stashpvs(&quot;literal string&quot; name, I32 create)
    </pre>
  </dd>
  <dt>gv_stashsv</dt>
  <dd>Returns a pointer to the stash for a specified package. See
      <span class="Li">&quot;gv_stashpvn&quot;</span>.
    <p class="Pp">Note this interface is strongly preferred over
        <span class="Li">&quot;gv_stashpvn&quot;</span> for performance
      reasons.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     gv_stashsv(SV* sv, I32 flags)
    </pre>
  </dd>
  <dt>GvSV</dt>
  <dd>Return the SV from the GV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     GvSV(GV* gv)
    </pre>
  </dd>
  <dt>setdefout</dt>
  <dd>Sets <span class="Li">&quot;PL_defoutgv&quot;</span>, the default file
      handle for output, to the passed in typeglob. As
      <span class="Li">&quot;PL_defoutgv&quot;</span> &quot;owns&quot; a
      reference on its typeglob, the reference count of the passed in typeglob
      is increased by one, and the reference count of the typeglob that
      <span class="Li">&quot;PL_defoutgv&quot;</span> points to is decreased by
      one.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    setdefout(GV* gv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Handy_Values"><a class="permalink" href="#Handy_Values">Handy
  Values</a></h1>
<dl class="Bl-tag">
  <dt>Nullav</dt>
  <dd>Null AV pointer.
    <p class="Pp">(deprecated - use <span class="Li">&quot;(AV
        *)NULL&quot;</span> instead)</p>
  </dd>
  <dt>Nullch</dt>
  <dd>Null character pointer. (No longer available when
      <span class="Li">&quot;PERL_CORE&quot;</span> is defined.)</dd>
  <dt>Nullcv</dt>
  <dd>Null CV pointer.
    <p class="Pp">(deprecated - use <span class="Li">&quot;(CV
        *)NULL&quot;</span> instead)</p>
  </dd>
  <dt>Nullhv</dt>
  <dd>Null HV pointer.
    <p class="Pp">(deprecated - use <span class="Li">&quot;(HV
        *)NULL&quot;</span> instead)</p>
  </dd>
  <dt>Nullsv</dt>
  <dd>Null SV pointer. (No longer available when
      <span class="Li">&quot;PERL_CORE&quot;</span> is defined.)</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Hash_Manipulation_Functions"><a class="permalink" href="#Hash_Manipulation_Functions">Hash
  Manipulation Functions</a></h1>
A HV structure represents a Perl hash. It consists mainly of an array of
  pointers, each of which points to a linked list of HE structures. The array is
  indexed by the hash function of the key, so each linked list represents all
  the hash entries with the same hash value. Each HE contains a pointer to the
  actual value, plus a pointer to a HEK structure which holds the key and hash
  value.
<dl class="Bl-tag">
  <dt>cop_fetch_label</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Returns the label attached to a cop. The flags pointer may be
        set to <span class="Li">&quot;SVf_UTF8&quot;</span> or 0.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char * cop_fetch_label(COP *const cop,
                                     STRLEN *len, U32 *flags)
    </pre>
  </dd>
  <dt>cop_store_label</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Save a label into a
        <span class="Li">&quot;cop_hints_hash&quot;</span>. You need to set
        flags to <span class="Li">&quot;SVf_UTF8&quot;</span> for a UTF-8
      label.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cop_store_label(COP *const cop,
                                const char *label, STRLEN len,
                                U32 flags)
    </pre>
  </dd>
  <dt>get_hv</dt>
  <dd>Returns the HV of the specified Perl hash.
      <span class="Li">&quot;flags&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchpv&quot;</span>. If
      <span class="Li">&quot;GV_ADD&quot;</span> is set and the Perl variable
      does not exist then it will be created. If
      <span class="Li">&quot;flags&quot;</span> is zero and the variable does
      not exist then <span class="Li">&quot;NULL&quot;</span> is returned.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     get_hv(const char *name, I32 flags)
    </pre>
  </dd>
  <dt>HEf_SVKEY</dt>
  <dd>This flag, used in the length slot of hash entries and magic structures,
      specifies the structure contains an
      <span class="Li">&quot;SV*&quot;</span> pointer where a
      <span class="Li">&quot;char*&quot;</span> pointer is to be expected. (For
      information only--not to be used).</dd>
  <dt>HeHASH</dt>
  <dd>Returns the computed hash stored in the hash entry.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     HeHASH(HE* he)
    </pre>
  </dd>
  <dt>HeKEY</dt>
  <dd>Returns the actual pointer stored in the key slot of the hash entry. The
      pointer may be either <span class="Li">&quot;char*&quot;</span> or
      <span class="Li">&quot;SV*&quot;</span>, depending on the value of
      <span class="Li">&quot;HeKLEN()&quot;</span>. Can be assigned to. The
      <span class="Li">&quot;HePV()&quot;</span> or
      <span class="Li">&quot;HeSVKEY()&quot;</span> macros are usually
      preferable for finding the value of a key.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void*   HeKEY(HE* he)
    </pre>
  </dd>
  <dt>HeKLEN</dt>
  <dd>If this is negative, and amounts to
      <span class="Li">&quot;HEf_SVKEY&quot;</span>, it indicates the entry
      holds an <span class="Li">&quot;SV*&quot;</span> key. Otherwise, holds the
      actual length of the key. Can be assigned to. The
      <span class="Li">&quot;HePV()&quot;</span> macro is usually preferable for
      finding key lengths.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  HeKLEN(HE* he)
    </pre>
  </dd>
  <dt>HePV</dt>
  <dd>Returns the key slot of the hash entry as a
      <span class="Li">&quot;char*&quot;</span> value, doing any necessary
      dereferencing of possibly <span class="Li">&quot;SV*&quot;</span> keys.
      The length of the string is placed in
      <span class="Li">&quot;len&quot;</span> (this is a macro, so do <i>not</i>
      use <span class="Li">&amp;len</span>). If you do not care about what the
      length of the key is, you may use the global variable
      <span class="Li">&quot;PL_na&quot;</span>, though this is rather less
      efficient than using a local variable. Remember though, that hash keys in
      perl are free to contain embedded nulls, so using
      <span class="Li">&quot;strlen()&quot;</span> or similar is not a good way
      to find the length of hash keys. This is very similar to the
      <span class="Li">&quot;SvPV()&quot;</span> macro described elsewhere in
      this document. See also <span class="Li">&quot;HeUTF8&quot;</span>.
    <p class="Pp">If you are using <span class="Li">&quot;HePV&quot;</span> to
        get values to pass to <span class="Li">&quot;newSVpvn()&quot;</span> to
        create a new SV, you should consider using
        <span class="Li">&quot;newSVhek(HeKEY_hek(he))&quot;</span> as it is
        more efficient.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   HePV(HE* he, STRLEN len)
    </pre>
  </dd>
  <dt>HeSVKEY</dt>
  <dd>Returns the key as an <span class="Li">&quot;SV*&quot;</span>, or
      <span class="Li">&quot;NULL&quot;</span> if the hash entry does not
      contain an <span class="Li">&quot;SV*&quot;</span> key.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     HeSVKEY(HE* he)
    </pre>
  </dd>
  <dt>HeSVKEY_force</dt>
  <dd>Returns the key as an <span class="Li">&quot;SV*&quot;</span>. Will create
      and return a temporary mortal <span class="Li">&quot;SV*&quot;</span> if
      the hash entry contains only a <span class="Li">&quot;char*&quot;</span>
      key.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     HeSVKEY_force(HE* he)
    </pre>
  </dd>
  <dt>HeSVKEY_set</dt>
  <dd>Sets the key to a given <span class="Li">&quot;SV*&quot;</span>, taking
      care to set the appropriate flags to indicate the presence of an
      <span class="Li">&quot;SV*&quot;</span> key, and returns the same
      <span class="Li">&quot;SV*&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     HeSVKEY_set(HE* he, SV* sv)
    </pre>
  </dd>
  <dt>HeUTF8</dt>
  <dd>Returns whether the <span class="Li">&quot;char *&quot;</span> value
      returned by <span class="Li">&quot;HePV&quot;</span> is encoded in UTF-8,
      doing any necessary dereferencing of possibly
      <span class="Li">&quot;SV*&quot;</span> keys. The value returned will be 0
      or non-0, not necessarily 1 (or even a value with any low bits set), so
      <b>do not</b> blindly assign this to a
      <span class="Li">&quot;bool&quot;</span> variable, as
      <span class="Li">&quot;bool&quot;</span> may be a typedef for
      <span class="Li">&quot;char&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     HeUTF8(HE* he)
    </pre>
  </dd>
  <dt>HeVAL</dt>
  <dd>Returns the value slot (type <span class="Li">&quot;SV*&quot;</span>)
      stored in the hash entry. Can be assigned to.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  SV *foo= HeVAL(hv);
  HeVAL(hv)= sv;


        SV*     HeVAL(HE* he)
    </pre>
  </dd>
  <dt>hv_assert</dt>
  <dd>Check that a hash is in an internally consistent state.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    hv_assert(HV *hv)
    </pre>
  </dd>
  <dt>hv_bucket_ratio</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">If the hash is tied dispatches through to the SCALAR tied
        method, otherwise if the hash contains no keys returns 0, otherwise
        returns a mortal sv containing a string specifying the number of used
        buckets, followed by a slash, followed by the number of available
        buckets.</p>
    <p class="Pp">This function is expensive, it must scan all of the buckets to
        determine which are used, and the count is NOT cached. In a large hash
        this could be a lot of buckets.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_bucket_ratio(HV *hv)
    </pre>
  </dd>
  <dt>hv_clear</dt>
  <dd>Frees the all the elements of a hash, leaving it empty. The XS equivalent
      of <span class="Li">&quot;%hash = ()&quot;</span>. See also
      &quot;hv_undef&quot;.
    <p class="Pp">See &quot;av_clear&quot; for a note about the hash possibly
        being invalid on return.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    hv_clear(HV *hv)
    </pre>
  </dd>
  <dt>hv_clear_placeholders</dt>
  <dd>Clears any placeholders from a hash. If a restricted hash has any of its
      keys marked as readonly and the key is subsequently deleted, the key is
      not actually deleted but is marked by assigning it a value of
      <span class="Li">&amp;PL_sv_placeholder</span>. This tags it so it will be
      ignored by future operations such as iterating over the hash, but will
      still allow the hash to have a value reassigned to the key at some future
      point. This function clears any such placeholder keys from the hash. See
      <span class="Li">&quot;Hash::Util::lock_keys()&quot;</span> for an example
      of its use.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    hv_clear_placeholders(HV *hv)
    </pre>
  </dd>
  <dt>hv_copy_hints_hv</dt>
  <dd>A specialised version of &quot;newHVhv&quot; for copying
      <span class="Li">&quot;%^H&quot;</span>.
      <span class="Li">&quot;ohv&quot;</span> must be a pointer to a hash (which
      may have <span class="Li">&quot;%^H&quot;</span> magic, but should be
      generally non-magical), or <span class="Li">&quot;NULL&quot;</span>
      (interpreted as an empty hash). The content of
      <span class="Li">&quot;ohv&quot;</span> is copied to a new hash, which has
      the <span class="Li">&quot;%^H&quot;</span>-specific magic added to it. A
      pointer to the new hash is returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    hv_copy_hints_hv(HV *ohv)
    </pre>
  </dd>
  <dt>hv_delete</dt>
  <dd>Deletes a key/value pair in the hash. The value's SV is removed from the
      hash, made mortal, and returned to the caller. The absolute value of
      <span class="Li">&quot;klen&quot;</span> is the length of the key. If
      <span class="Li">&quot;klen&quot;</span> is negative the key is assumed to
      be in UTF-8-encoded Unicode. The <span class="Li">&quot;flags&quot;</span>
      value will normally be zero; if set to
      <span class="Li">&quot;G_DISCARD&quot;</span> then
      <span class="Li">&quot;NULL&quot;</span> will be returned.
      <span class="Li">&quot;NULL&quot;</span> will also be returned if the key
      is not found.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_delete(HV *hv, const char *key, I32 klen,
                          I32 flags)
    </pre>
  </dd>
  <dt>hv_delete_ent</dt>
  <dd>Deletes a key/value pair in the hash. The value SV is removed from the
      hash, made mortal, and returned to the caller. The
      <span class="Li">&quot;flags&quot;</span> value will normally be zero; if
      set to <span class="Li">&quot;G_DISCARD&quot;</span> then
      <span class="Li">&quot;NULL&quot;</span> will be returned.
      <span class="Li">&quot;NULL&quot;</span> will also be returned if the key
      is not found. <span class="Li">&quot;hash&quot;</span> can be a valid
      precomputed hash value, or 0 to ask for it to be computed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_delete_ent(HV *hv, SV *keysv, I32 flags,
                              U32 hash)
    </pre>
  </dd>
  <dt>HvENAME</dt>
  <dd>Returns the effective name of a stash, or NULL if there is none. The
      effective name represents a location in the symbol table where this stash
      resides. It is updated automatically when packages are aliased or deleted.
      A stash that is no longer in the symbol table has no effective name. This
      name is preferable to <span class="Li">&quot;HvNAME&quot;</span> for use
      in MRO linearisations and isa caches.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   HvENAME(HV* stash)
    </pre>
  </dd>
  <dt>HvENAMELEN</dt>
  <dd>Returns the length of the stash's effective name.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  HvENAMELEN(HV *stash)
    </pre>
  </dd>
  <dt>HvENAMEUTF8</dt>
  <dd>Returns true if the effective name is in UTF-8 encoding.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        unsigned char HvENAMEUTF8(HV *stash)
    </pre>
  </dd>
  <dt>hv_exists</dt>
  <dd>Returns a boolean indicating whether the specified hash key exists. The
      absolute value of <span class="Li">&quot;klen&quot;</span> is the length
      of the key. If <span class="Li">&quot;klen&quot;</span> is negative the
      key is assumed to be in UTF-8-encoded Unicode.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    hv_exists(HV *hv, const char *key, I32 klen)
    </pre>
  </dd>
  <dt>hv_exists_ent</dt>
  <dd>Returns a boolean indicating whether the specified hash key exists.
      <span class="Li">&quot;hash&quot;</span> can be a valid precomputed hash
      value, or 0 to ask for it to be computed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    hv_exists_ent(HV *hv, SV *keysv, U32 hash)
    </pre>
  </dd>
  <dt>hv_fetch</dt>
  <dd>Returns the SV which corresponds to the specified key in the hash. The
      absolute value of <span class="Li">&quot;klen&quot;</span> is the length
      of the key. If <span class="Li">&quot;klen&quot;</span> is negative the
      key is assumed to be in UTF-8-encoded Unicode. If
      <span class="Li">&quot;lval&quot;</span> is set then the fetch will be
      part of a store. This means that if there is no value in the hash
      associated with the given key, then one is created and a pointer to it is
      returned. The <span class="Li">&quot;SV*&quot;</span> it points to can be
      assigned to. But always check that the return value is non-null before
      dereferencing it to an <span class="Li">&quot;SV*&quot;</span>.
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied hashes.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    hv_fetch(HV *hv, const char *key, I32 klen,
                         I32 lval)
    </pre>
  </dd>
  <dt>hv_fetchs</dt>
  <dd>Like <span class="Li">&quot;hv_fetch&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    hv_fetchs(HV* tb, &quot;literal string&quot; key,
                          I32 lval)
    </pre>
  </dd>
  <dt>hv_fetch_ent</dt>
  <dd>Returns the hash entry which corresponds to the specified key in the hash.
      <span class="Li">&quot;hash&quot;</span> must be a valid precomputed hash
      number for the given <span class="Li">&quot;key&quot;</span>, or 0 if you
      want the function to compute it. IF
      <span class="Li">&quot;lval&quot;</span> is set then the fetch will be
      part of a store. Make sure the return value is non-null before accessing
      it. The return value when <span class="Li">&quot;hv&quot;</span> is a tied
      hash is a pointer to a static location, so be sure to make a copy of the
      structure if you need to store it somewhere.
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied hashes.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HE*     hv_fetch_ent(HV *hv, SV *keysv, I32 lval,
                             U32 hash)
    </pre>
  </dd>
  <dt>hv_fill</dt>
  <dd>Returns the number of hash buckets that happen to be in use.
    <p class="Pp">This function is wrapped by the macro
        <span class="Li">&quot;HvFILL&quot;</span>.</p>
    <p class="Pp">As of perl 5.25 this function is used only for debugging
        purposes, and the number of used hash buckets is not in any way cached,
        thus this function can be costly to execute as it must iterate over all
        the buckets in the hash.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  hv_fill(HV *const hv)
    </pre>
  </dd>
  <dt>hv_iterinit</dt>
  <dd>Prepares a starting point to traverse a hash table. Returns the number of
      keys in the hash, including placeholders (i.e. the same as
      <span class="Li">&quot;HvTOTALKEYS(hv)&quot;</span>). The return value is
      currently only meaningful for hashes without tie magic.
    <p class="Pp">NOTE: Before version 5.004_65,
        <span class="Li">&quot;hv_iterinit&quot;</span> used to return the
        number of hash buckets that happen to be in use. If you still need that
        esoteric value, you can get it through the macro
        <span class="Li">&quot;HvFILL(hv)&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     hv_iterinit(HV *hv)
    </pre>
  </dd>
  <dt>hv_iterkey</dt>
  <dd>Returns the key from the current position of the hash iterator. See
      <span class="Li">&quot;hv_iterinit&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   hv_iterkey(HE* entry, I32* retlen)
    </pre>
  </dd>
  <dt>hv_iterkeysv</dt>
  <dd>Returns the key as an <span class="Li">&quot;SV*&quot;</span> from the
      current position of the hash iterator. The return value will always be a
      mortal copy of the key. Also see
      <span class="Li">&quot;hv_iterinit&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_iterkeysv(HE* entry)
    </pre>
  </dd>
  <dt>hv_iternext</dt>
  <dd>Returns entries from a hash iterator. See
      <span class="Li">&quot;hv_iterinit&quot;</span>.
    <p class="Pp">You may call <span class="Li">&quot;hv_delete&quot;</span> or
        <span class="Li">&quot;hv_delete_ent&quot;</span> on the hash entry that
        the iterator currently points to, without losing your place or
        invalidating your iterator. Note that in this case the current entry is
        deleted from the hash with your iterator holding the last reference to
        it. Your iterator is flagged to free the entry on the next call to
        <span class="Li">&quot;hv_iternext&quot;</span>, so you must not discard
        your iterator immediately else the entry will leak - call
        <span class="Li">&quot;hv_iternext&quot;</span> to trigger the resource
        deallocation.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HE*     hv_iternext(HV *hv)
    </pre>
  </dd>
  <dt>hv_iternextsv</dt>
  <dd>Performs an <span class="Li">&quot;hv_iternext&quot;</span>,
      <span class="Li">&quot;hv_iterkey&quot;</span>, and
      <span class="Li">&quot;hv_iterval&quot;</span> in one operation.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_iternextsv(HV *hv, char **key, I32 *retlen)
    </pre>
  </dd>
  <dt>hv_iternext_flags</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Returns entries from a hash iterator. See
        <span class="Li">&quot;hv_iterinit&quot;</span> and
        <span class="Li">&quot;hv_iternext&quot;</span>. The
        <span class="Li">&quot;flags&quot;</span> value will normally be zero;
        if <span class="Li">&quot;HV_ITERNEXT_WANTPLACEHOLDERS&quot;</span> is
        set the placeholders keys (for restricted hashes) will be returned in
        addition to normal keys. By default placeholders are automatically
        skipped over. Currently a placeholder is implemented with a value that
        is <span class="Li">&amp;PL_sv_placeholder</span>. Note that the
        implementation of placeholders and restricted hashes may change, and the
        implementation currently is insufficiently abstracted for any change to
        be tidy.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HE*     hv_iternext_flags(HV *hv, I32 flags)
    </pre>
  </dd>
  <dt>hv_iterval</dt>
  <dd>Returns the value from the current position of the hash iterator. See
      <span class="Li">&quot;hv_iterkey&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_iterval(HV *hv, HE *entry)
    </pre>
  </dd>
  <dt>hv_magic</dt>
  <dd>Adds magic to a hash. See <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    hv_magic(HV *hv, GV *gv, int how)
    </pre>
  </dd>
  <dt>HvNAME</dt>
  <dd>Returns the package name of a stash, or
      <span class="Li">&quot;NULL&quot;</span> if
      <span class="Li">&quot;stash&quot;</span> isn't a stash. See
      <span class="Li">&quot;SvSTASH&quot;</span>,
      <span class="Li">&quot;CvSTASH&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   HvNAME(HV* stash)
    </pre>
  </dd>
  <dt>HvNAMELEN</dt>
  <dd>Returns the length of the stash's name.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  HvNAMELEN(HV *stash)
    </pre>
  </dd>
  <dt>HvNAMEUTF8</dt>
  <dd>Returns true if the name is in UTF-8 encoding.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        unsigned char HvNAMEUTF8(HV *stash)
    </pre>
  </dd>
  <dt>hv_scalar</dt>
  <dd>Evaluates the hash in scalar context and returns the result.
    <p class="Pp">When the hash is tied dispatches through to the SCALAR method,
        otherwise returns a mortal SV containing the number of keys in the
      hash.</p>
    <p class="Pp">Note, prior to 5.25 this function returned what is now
        returned by the <b>hv_bucket_ratio()</b> function.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     hv_scalar(HV *hv)
    </pre>
  </dd>
  <dt>hv_store</dt>
  <dd>Stores an SV in a hash. The hash key is specified as
      <span class="Li">&quot;key&quot;</span> and the absolute value of
      <span class="Li">&quot;klen&quot;</span> is the length of the key. If
      <span class="Li">&quot;klen&quot;</span> is negative the key is assumed to
      be in UTF-8-encoded Unicode. The <span class="Li">&quot;hash&quot;</span>
      parameter is the precomputed hash value; if it is zero then Perl will
      compute it.
    <p class="Pp">The return value will be
        <span class="Li">&quot;NULL&quot;</span> if the operation failed or if
        the value did not need to be actually stored within the hash (as in the
        case of tied hashes). Otherwise it can be dereferenced to get the
        original <span class="Li">&quot;SV*&quot;</span>. Note that the caller
        is responsible for suitably incrementing the reference count of
        <span class="Li">&quot;val&quot;</span> before the call, and
        decrementing it if the function returned
        <span class="Li">&quot;NULL&quot;</span>. Effectively a successful
        <span class="Li">&quot;hv_store&quot;</span> takes ownership of one
        reference to <span class="Li">&quot;val&quot;</span>. This is usually
        what you want; a newly created SV has a reference count of one, so if
        all your code does is create SVs then store them in a hash,
        <span class="Li">&quot;hv_store&quot;</span> will own the only reference
        to the new SV, and your code doesn't need to do anything further to tidy
        up. <span class="Li">&quot;hv_store&quot;</span> is not implemented as a
        call to <span class="Li">&quot;hv_store_ent&quot;</span>, and does not
        create a temporary SV for the key, so if your key data is not already in
        SV form then use <span class="Li">&quot;hv_store&quot;</span> in
        preference to <span class="Li">&quot;hv_store_ent&quot;</span>.</p>
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied hashes.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    hv_store(HV *hv, const char *key, I32 klen,
                         SV *val, U32 hash)
    </pre>
  </dd>
  <dt>hv_stores</dt>
  <dd>Like <span class="Li">&quot;hv_store&quot;</span>, but takes a literal
      string instead of a string/length pair and omits the hash parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV**    hv_stores(HV* tb, &quot;literal string&quot; key, SV* val)
    </pre>
  </dd>
  <dt>hv_store_ent</dt>
  <dd>Stores <span class="Li">&quot;val&quot;</span> in a hash. The hash key is
      specified as <span class="Li">&quot;key&quot;</span>. The
      <span class="Li">&quot;hash&quot;</span> parameter is the precomputed hash
      value; if it is zero then Perl will compute it. The return value is the
      new hash entry so created. It will be
      <span class="Li">&quot;NULL&quot;</span> if the operation failed or if the
      value did not need to be actually stored within the hash (as in the case
      of tied hashes). Otherwise the contents of the return value can be
      accessed using the <span class="Li">&quot;He?&quot;</span> macros
      described here. Note that the caller is responsible for suitably
      incrementing the reference count of
      <span class="Li">&quot;val&quot;</span> before the call, and decrementing
      it if the function returned NULL. Effectively a successful
      <span class="Li">&quot;hv_store_ent&quot;</span> takes ownership of one
      reference to <span class="Li">&quot;val&quot;</span>. This is usually what
      you want; a newly created SV has a reference count of one, so if all your
      code does is create SVs then store them in a hash,
      <span class="Li">&quot;hv_store&quot;</span> will own the only reference
      to the new SV, and your code doesn't need to do anything further to tidy
      up. Note that <span class="Li">&quot;hv_store_ent&quot;</span> only reads
      the <span class="Li">&quot;key&quot;</span>; unlike
      <span class="Li">&quot;val&quot;</span> it does not take ownership of it,
      so maintaining the correct reference count on
      <span class="Li">&quot;key&quot;</span> is entirely the caller's
      responsibility. The reason it does not take ownership, is that
      <span class="Li">&quot;key&quot;</span> is not used after this function
      returns, and so can be freed immediately.
      <span class="Li">&quot;hv_store&quot;</span> is not implemented as a call
      to <span class="Li">&quot;hv_store_ent&quot;</span>, and does not create a
      temporary SV for the key, so if your key data is not already in SV form
      then use <span class="Li">&quot;hv_store&quot;</span> in preference to
      <span class="Li">&quot;hv_store_ent&quot;</span>.
    <p class="Pp">See &quot;Understanding the Magic of Tied Hashes and
        Arrays&quot; in perlguts for more information on how to use this
        function on tied hashes.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HE*     hv_store_ent(HV *hv, SV *key, SV *val, U32 hash)
    </pre>
  </dd>
  <dt>hv_undef</dt>
  <dd>Undefines the hash. The XS equivalent of
      <span class="Li">&quot;undef(%hash)&quot;</span>.
    <p class="Pp">As well as freeing all the elements of the hash (like
        <span class="Li">&quot;hv_clear()&quot;</span>), this also frees any
        auxiliary data and storage associated with the hash.</p>
    <p class="Pp">See &quot;av_clear&quot; for a note about the hash possibly
        being invalid on return.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    hv_undef(HV *hv)
    </pre>
  </dd>
  <dt>newHV</dt>
  <dd>Creates a new HV. The reference count is set to 1.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     newHV()
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Hook_manipulation"><a class="permalink" href="#Hook_manipulation">Hook
  manipulation</a></h1>
These functions provide convenient and thread-safe means of manipulating hook
  variables.
<dl class="Bl-tag">
  <dt>wrap_op_checker</dt>
  <dd>Puts a C function into the chain of check functions for a specified op
      type. This is the preferred way to manipulate the &quot;PL_check&quot;
      array. <span class="Li">&quot;opcode&quot;</span> specifies which type of
      op is to be affected. <span class="Li">&quot;new_checker&quot;</span> is a
      pointer to the C function that is to be added to that opcode's check
      chain, and <span class="Li">&quot;old_checker_p&quot;</span> points to the
      storage location where a pointer to the next function in the chain will be
      stored. The value of <span class="Li">&quot;new_checker&quot;</span> is
      written into the &quot;PL_check&quot; array, while the value previously
      stored there is written to <span class="Li">*old_checker_p</span>.
    <p class="Pp">&quot;PL_check&quot; is global to an entire process, and a
        module wishing to hook op checking may find itself invoked more than
        once per process, typically in different threads. To handle that
        situation, this function is idempotent. The location
        <span class="Li">*old_checker_p</span> must initially (once per process)
        contain a null pointer. A C variable of static duration (declared at
        file scope, typically also marked
        <span class="Li">&quot;static&quot;</span> to give it internal linkage)
        will be implicitly initialised appropriately, if it does not have an
        explicit initialiser. This function will only actually modify the check
        chain if it finds <span class="Li">*old_checker_p</span> to be null.
        This function is also thread safe on the small scale. It uses
        appropriate locking to avoid race conditions in accessing
        &quot;PL_check&quot;.</p>
    <p class="Pp">When this function is called, the function referenced by
        <span class="Li">&quot;new_checker&quot;</span> must be ready to be
        called, except for <span class="Li">*old_checker_p</span> being
        unfilled. In a threading situation,
        <span class="Li">&quot;new_checker&quot;</span> may be called
        immediately, even before this function has returned.
        <span class="Li">*old_checker_p</span> will always be appropriately set
        before <span class="Li">&quot;new_checker&quot;</span> is called. If
        <span class="Li">&quot;new_checker&quot;</span> decides not to do
        anything special with an op that it is given (which is the usual case
        for most uses of op check hooking), it must chain the check function
        referenced by <span class="Li">*old_checker_p</span>.</p>
    <p class="Pp">Taken all together, XS code to hook an op checker should
        typically look something like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    static Perl_check_t nxck_frob;
    static OP *myck_frob(pTHX_ OP *op) {
        ...
        op = nxck_frob(aTHX_ op);
        ...
        return op;
    }
    BOOT:
        wrap_op_checker(OP_FROB, myck_frob, &amp;nxck_frob);
    </pre>
    <p class="Pp">If you want to influence compilation of calls to a specific
        subroutine, then use &quot;cv_set_call_checker_flags&quot; rather than
        hooking checking of all <span class="Li">&quot;entersub&quot;</span>
        ops.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    wrap_op_checker(Optype opcode,
                                Perl_check_t new_checker,
                                Perl_check_t *old_checker_p)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Lexer_interface"><a class="permalink" href="#Lexer_interface">Lexer
  interface</a></h1>
This is the lower layer of the Perl parser, managing characters and tokens.
<dl class="Bl-tag">
  <dt>lex_bufutf8</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Indicates whether the octets in the lexer buffer
        (&quot;PL_parser-&gt;linestr&quot;) should be interpreted as the UTF-8
        encoding of Unicode characters. If not, they should be interpreted as
        Latin-1 characters. This is analogous to the
        <span class="Li">&quot;SvUTF8&quot;</span> flag for scalars.</p>
    <p class="Pp">In UTF-8 mode, it is not guaranteed that the lexer buffer
        actually contains valid UTF-8. Lexing code must be robust in the face of
        invalid encoding.</p>
    <p class="Pp">The actual <span class="Li">&quot;SvUTF8&quot;</span> flag of
        the &quot;PL_parser-&gt;linestr&quot; scalar is significant, but not the
        whole story regarding the input character encoding. Normally, when a
        file is being read, the scalar contains octets and its
        <span class="Li">&quot;SvUTF8&quot;</span> flag is off, but the octets
        should be interpreted as UTF-8 if the <span class="Li">&quot;use
        utf8&quot;</span> pragma is in effect. During a string eval, however,
        the scalar may have the <span class="Li">&quot;SvUTF8&quot;</span> flag
        on, and in this case its octets should be interpreted as UTF-8 unless
        the <span class="Li">&quot;use bytes&quot;</span> pragma is in effect.
        This logic may change in the future; use this function instead of
        implementing the logic yourself.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    lex_bufutf8()
    </pre>
  </dd>
  <dt>lex_discard_to</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Discards the first part of the
        &quot;PL_parser-&gt;linestr&quot; buffer, up to
        <span class="Li">&quot;ptr&quot;</span>. The remaining content of the
        buffer will be moved, and all pointers into the buffer updated
        appropriately. <span class="Li">&quot;ptr&quot;</span> must not be later
        in the buffer than the position of &quot;PL_parser-&gt;bufptr&quot;: it
        is not permitted to discard text that has yet to be lexed.</p>
    <p class="Pp">Normally it is not necessarily to do this directly, because it
        suffices to use the implicit discarding behaviour of
        &quot;lex_next_chunk&quot; and things based on it. However, if a token
        stretches across multiple lines, and the lexing code has kept multiple
        lines of text in the buffer for that purpose, then after completion of
        the token it would be wise to explicitly discard the now-unneeded
        earlier lines, to avoid future multi-line tokens growing the buffer
        without bound.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_discard_to(char *ptr)
    </pre>
  </dd>
  <dt>lex_grow_linestr</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Reallocates the lexer buffer
        (&quot;PL_parser-&gt;linestr&quot;) to accommodate at least
        <span class="Li">&quot;len&quot;</span> octets (including terminating
        <span class="Li">&quot;NUL&quot;</span>). Returns a pointer to the
        reallocated buffer. This is necessary before making any direct
        modification of the buffer that would increase its length.
        &quot;lex_stuff_pvn&quot; provides a more convenient way to insert text
        into the buffer.</p>
    <p class="Pp">Do not use <span class="Li">&quot;SvGROW&quot;</span> or
        <span class="Li">&quot;sv_grow&quot;</span> directly on
        <span class="Li">&quot;PL_parser-&gt;linestr&quot;</span>; this function
        updates all of the lexer's variables that point directly into the
        buffer.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char *  lex_grow_linestr(STRLEN len)
    </pre>
  </dd>
  <dt>lex_next_chunk</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Reads in the next chunk of text to be lexed, appending it to
        &quot;PL_parser-&gt;linestr&quot;. This should be called when lexing
        code has looked to the end of the current chunk and wants to know more.
        It is usual, but not necessary, for lexing to have consumed the entirety
        of the current chunk at this time.</p>
    <p class="Pp">If &quot;PL_parser-&gt;bufptr&quot; is pointing to the very
        end of the current chunk (i.e., the current chunk has been entirely
        consumed), normally the current chunk will be discarded at the same time
        that the new chunk is read in. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;LEX_KEEP_PREVIOUS&quot;</span> bit set, the
        current chunk will not be discarded. If the current chunk has not been
        entirely consumed, then it will not be discarded regardless of the
      flag.</p>
    <p class="Pp">Returns true if some new text was added to the buffer, or
        false if the buffer has reached the end of the input text.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    lex_next_chunk(U32 flags)
    </pre>
  </dd>
  <dt>lex_peek_unichar</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Looks ahead one (Unicode) character in the text currently
        being lexed. Returns the codepoint (unsigned integer value) of the next
        character, or -1 if lexing has reached the end of the input text. To
        consume the peeked character, use &quot;lex_read_unichar&quot;.</p>
    <p class="Pp">If the next character is in (or extends into) the next chunk
        of input text, the next chunk will be read in. Normally the current
        chunk will be discarded at the same time, but if
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;LEX_KEEP_PREVIOUS&quot;</span> bit set, then the
        current chunk will not be discarded.</p>
    <p class="Pp">If the input is being interpreted as UTF-8 and a UTF-8
        encoding error is encountered, an exception is generated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     lex_peek_unichar(U32 flags)
    </pre>
  </dd>
  <dt>lex_read_space</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Reads optional spaces, in Perl style, in the text currently
        being lexed. The spaces may include ordinary whitespace characters and
        Perl-style comments. <span class="Li">&quot;#line&quot;</span>
        directives are processed if encountered.
        &quot;PL_parser-&gt;bufptr&quot; is moved past the spaces, so that it
        points at a non-space character (or the end of the input text).</p>
    <p class="Pp">If spaces extend into the next chunk of input text, the next
        chunk will be read in. Normally the current chunk will be discarded at
        the same time, but if <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;LEX_KEEP_PREVIOUS&quot;</span> bit set, then the
        current chunk will not be discarded.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_read_space(U32 flags)
    </pre>
  </dd>
  <dt>lex_read_to</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Consume text in the lexer buffer, from
        &quot;PL_parser-&gt;bufptr&quot; up to
        <span class="Li">&quot;ptr&quot;</span>. This advances
        &quot;PL_parser-&gt;bufptr&quot; to match
        <span class="Li">&quot;ptr&quot;</span>, performing the correct
        bookkeeping whenever a newline character is passed. This is the normal
        way to consume lexed text.</p>
    <p class="Pp">Interpretation of the buffer's octets can be abstracted out by
        using the slightly higher-level functions &quot;lex_peek_unichar&quot;
        and &quot;lex_read_unichar&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_read_to(char *ptr)
    </pre>
  </dd>
  <dt>lex_read_unichar</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Reads the next (Unicode) character in the text currently being
        lexed. Returns the codepoint (unsigned integer value) of the character
        read, and moves &quot;PL_parser-&gt;bufptr&quot; past the character, or
        returns -1 if lexing has reached the end of the input text. To
        non-destructively examine the next character, use
        &quot;lex_peek_unichar&quot; instead.</p>
    <p class="Pp">If the next character is in (or extends into) the next chunk
        of input text, the next chunk will be read in. Normally the current
        chunk will be discarded at the same time, but if
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;LEX_KEEP_PREVIOUS&quot;</span> bit set, then the
        current chunk will not be discarded.</p>
    <p class="Pp">If the input is being interpreted as UTF-8 and a UTF-8
        encoding error is encountered, an exception is generated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     lex_read_unichar(U32 flags)
    </pre>
  </dd>
  <dt>lex_start</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Creates and initialises a new lexer/parser state object,
        supplying a context in which to lex and parse from a new source of Perl
        code. A pointer to the new state object is placed in
        &quot;PL_parser&quot;. An entry is made on the save stack so that upon
        unwinding, the new state object will be destroyed and the former value
        of &quot;PL_parser&quot; will be restored. Nothing else need be done to
        clean up the parsing context.</p>
    <p class="Pp">The code to be parsed comes from
        <span class="Li">&quot;line&quot;</span> and
        <span class="Li">&quot;rsfp&quot;</span>.
        <span class="Li">&quot;line&quot;</span>, if non-null, provides a string
        (in SV form) containing code to be parsed. A copy of the string is made,
        so subsequent modification of <span class="Li">&quot;line&quot;</span>
        does not affect parsing. <span class="Li">&quot;rsfp&quot;</span>, if
        non-null, provides an input stream from which code will be read to be
        parsed. If both are non-null, the code in
        <span class="Li">&quot;line&quot;</span> comes first and must consist of
        complete lines of input, and <span class="Li">&quot;rsfp&quot;</span>
        supplies the remainder of the source.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter is
        reserved for future use. Currently it is only used by perl internally,
        so extensions should always pass zero.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_start(SV *line, PerlIO *rsfp, U32 flags)
    </pre>
  </dd>
  <dt>lex_stuff_pv</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Insert characters into the lexer buffer
        (&quot;PL_parser-&gt;linestr&quot;), immediately after the current
        lexing point (&quot;PL_parser-&gt;bufptr&quot;), reallocating the buffer
        if necessary. This means that lexing code that runs later will see the
        characters as if they had appeared in the input. It is not recommended
        to do this as part of normal parsing, and most uses of this facility run
        the risk of the inserted characters being interpreted in an unintended
        manner.</p>
    <p class="Pp">The string to be inserted is represented by octets starting at
        <span class="Li">&quot;pv&quot;</span> and continuing to the first nul.
        These octets are interpreted as either UTF-8 or Latin-1, according to
        whether the <span class="Li">&quot;LEX_STUFF_UTF8&quot;</span> flag is
        set in <span class="Li">&quot;flags&quot;</span>. The characters are
        recoded for the lexer buffer, according to how the buffer is currently
        being interpreted (&quot;lex_bufutf8&quot;). If it is not convenient to
        nul-terminate a string to be inserted, the &quot;lex_stuff_pvn&quot;
        function is more appropriate.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_stuff_pv(const char *pv, U32 flags)
    </pre>
  </dd>
  <dt>lex_stuff_pvn</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Insert characters into the lexer buffer
        (&quot;PL_parser-&gt;linestr&quot;), immediately after the current
        lexing point (&quot;PL_parser-&gt;bufptr&quot;), reallocating the buffer
        if necessary. This means that lexing code that runs later will see the
        characters as if they had appeared in the input. It is not recommended
        to do this as part of normal parsing, and most uses of this facility run
        the risk of the inserted characters being interpreted in an unintended
        manner.</p>
    <p class="Pp">The string to be inserted is represented by
        <span class="Li">&quot;len&quot;</span> octets starting at
        <span class="Li">&quot;pv&quot;</span>. These octets are interpreted as
        either UTF-8 or Latin-1, according to whether the
        <span class="Li">&quot;LEX_STUFF_UTF8&quot;</span> flag is set in
        <span class="Li">&quot;flags&quot;</span>. The characters are recoded
        for the lexer buffer, according to how the buffer is currently being
        interpreted (&quot;lex_bufutf8&quot;). If a string to be inserted is
        available as a Perl scalar, the &quot;lex_stuff_sv&quot; function is
        more convenient.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_stuff_pvn(const char *pv, STRLEN len,
                              U32 flags)
    </pre>
  </dd>
  <dt>lex_stuff_pvs</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Like &quot;lex_stuff_pvn&quot;, but takes a literal string
        instead of a string/length pair.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_stuff_pvs(&quot;literal string&quot; pv, U32 flags)
    </pre>
  </dd>
  <dt>lex_stuff_sv</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Insert characters into the lexer buffer
        (&quot;PL_parser-&gt;linestr&quot;), immediately after the current
        lexing point (&quot;PL_parser-&gt;bufptr&quot;), reallocating the buffer
        if necessary. This means that lexing code that runs later will see the
        characters as if they had appeared in the input. It is not recommended
        to do this as part of normal parsing, and most uses of this facility run
        the risk of the inserted characters being interpreted in an unintended
        manner.</p>
    <p class="Pp">The string to be inserted is the string value of
        <span class="Li">&quot;sv&quot;</span>. The characters are recoded for
        the lexer buffer, according to how the buffer is currently being
        interpreted (&quot;lex_bufutf8&quot;). If a string to be inserted is not
        already a Perl scalar, the &quot;lex_stuff_pvn&quot; function avoids the
        need to construct a scalar.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_stuff_sv(SV *sv, U32 flags)
    </pre>
  </dd>
  <dt>lex_unstuff</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Discards text about to be lexed, from
        &quot;PL_parser-&gt;bufptr&quot; up to
        <span class="Li">&quot;ptr&quot;</span>. Text following
        <span class="Li">&quot;ptr&quot;</span> will be moved, and the buffer
        shortened. This hides the discarded text from any lexing code that runs
        later, as if the text had never appeared.</p>
    <p class="Pp">This is not the normal way to consume lexed text. For that,
        use &quot;lex_read_to&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    lex_unstuff(char *ptr)
    </pre>
  </dd>
  <dt>parse_arithexpr</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Parse a Perl arithmetic expression. This may contain operators
        of precedence down to the bit shift operators. The expression must be
        followed (and thus terminated) either by a comparison or
        lower-precedence operator or by something that would normally terminate
        an expression such as semicolon. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> bit set, then the
        expression is optional, otherwise it is mandatory. It is up to the
        caller to ensure that the dynamic parser state (&quot;PL_parser&quot; et
        al) is correctly set to reflect the source of the code to be parsed and
        the lexical context for the expression.</p>
    <p class="Pp">The op tree representing the expression is returned. If an
        optional expression is absent, a null pointer is returned, otherwise the
        pointer will be non-null.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_arithexpr(U32 flags)
    </pre>
  </dd>
  <dt>parse_barestmt</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Parse a single unadorned Perl statement. This may be a normal
        imperative statement or a declaration that has compile-time effect. It
        does not include any label or other affixture. It is up to the caller to
        ensure that the dynamic parser state (&quot;PL_parser&quot; et al) is
        correctly set to reflect the source of the code to be parsed and the
        lexical context for the statement.</p>
    <p class="Pp">The op tree representing the statement is returned. This may
        be a null pointer if the statement is null, for example if it was
        actually a subroutine definition (which has compile-time side effects).
        If not null, it will be ops directly implementing the statement,
        suitable to pass to &quot;newSTATEOP&quot;. It will not normally include
        a <span class="Li">&quot;nextstate&quot;</span> or equivalent op (except
        for those embedded in a scope contained entirely within the
      statement).</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree (most likely null) is returned anyway. The error is
        reflected in the parser state, normally resulting in a single exception
        at the top level of parsing which covers all the compilation errors that
        occurred. Some compilation errors, however, will throw an exception
        immediately.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter is
        reserved for future use, and must always be zero.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_barestmt(U32 flags)
    </pre>
  </dd>
  <dt>parse_block</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Parse a single complete Perl code block. This consists of an
        opening brace, a sequence of statements, and a closing brace. The block
        constitutes a lexical scope, so <span class="Li">&quot;my&quot;</span>
        variables and various compile-time effects can be contained within it.
        It is up to the caller to ensure that the dynamic parser state
        (&quot;PL_parser&quot; et al) is correctly set to reflect the source of
        the code to be parsed and the lexical context for the statement.</p>
    <p class="Pp">The op tree representing the code block is returned. This is
        always a real op, never a null pointer. It will normally be a
        <span class="Li">&quot;lineseq&quot;</span> list, including
        <span class="Li">&quot;nextstate&quot;</span> or equivalent ops. No ops
        to construct any kind of runtime scope are included by virtue of it
        being a block.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree (most likely null) is returned anyway. The error is
        reflected in the parser state, normally resulting in a single exception
        at the top level of parsing which covers all the compilation errors that
        occurred. Some compilation errors, however, will throw an exception
        immediately.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter is
        reserved for future use, and must always be zero.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_block(U32 flags)
    </pre>
  </dd>
  <dt>parse_fullexpr</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Parse a single complete Perl expression. This allows the full
        expression grammar, including the lowest-precedence operators such as
        <span class="Li">&quot;or&quot;</span>. The expression must be followed
        (and thus terminated) by a token that an expression would normally be
        terminated by: end-of-file, closing bracketing punctuation, semicolon,
        or one of the keywords that signals a postfix expression-statement
        modifier. If <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> bit set, then the
        expression is optional, otherwise it is mandatory. It is up to the
        caller to ensure that the dynamic parser state (&quot;PL_parser&quot; et
        al) is correctly set to reflect the source of the code to be parsed and
        the lexical context for the expression.</p>
    <p class="Pp">The op tree representing the expression is returned. If an
        optional expression is absent, a null pointer is returned, otherwise the
        pointer will be non-null.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_fullexpr(U32 flags)
    </pre>
  </dd>
  <dt>parse_fullstmt</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Parse a single complete Perl statement. This may be a normal
        imperative statement or a declaration that has compile-time effect, and
        may include optional labels. It is up to the caller to ensure that the
        dynamic parser state (&quot;PL_parser&quot; et al) is correctly set to
        reflect the source of the code to be parsed and the lexical context for
        the statement.</p>
    <p class="Pp">The op tree representing the statement is returned. This may
        be a null pointer if the statement is null, for example if it was
        actually a subroutine definition (which has compile-time side effects).
        If not null, it will be the result of a &quot;newSTATEOP&quot; call,
        normally including a <span class="Li">&quot;nextstate&quot;</span> or
        equivalent op.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree (most likely null) is returned anyway. The error is
        reflected in the parser state, normally resulting in a single exception
        at the top level of parsing which covers all the compilation errors that
        occurred. Some compilation errors, however, will throw an exception
        immediately.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter is
        reserved for future use, and must always be zero.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_fullstmt(U32 flags)
    </pre>
  </dd>
  <dt>parse_label</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Parse a single label, possibly optional, of the type that may
        prefix a Perl statement. It is up to the caller to ensure that the
        dynamic parser state (&quot;PL_parser&quot; et al) is correctly set to
        reflect the source of the code to be parsed. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> bit set, then the
        label is optional, otherwise it is mandatory.</p>
    <p class="Pp">The name of the label is returned in the form of a fresh
        scalar. If an optional label is absent, a null pointer is returned.</p>
    <p class="Pp">If an error occurs in parsing, which can only occur if the
        label is mandatory, a valid label is returned anyway. The error is
        reflected in the parser state, normally resulting in a single exception
        at the top level of parsing which covers all the compilation errors that
        occurred.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    parse_label(U32 flags)
    </pre>
  </dd>
  <dt>parse_listexpr</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Parse a Perl list expression. This may contain operators of
        precedence down to the comma operator. The expression must be followed
        (and thus terminated) either by a low-precedence logic operator such as
        <span class="Li">&quot;or&quot;</span> or by something that would
        normally terminate an expression such as semicolon. If
        <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> bit set, then the
        expression is optional, otherwise it is mandatory. It is up to the
        caller to ensure that the dynamic parser state (&quot;PL_parser&quot; et
        al) is correctly set to reflect the source of the code to be parsed and
        the lexical context for the expression.</p>
    <p class="Pp">The op tree representing the expression is returned. If an
        optional expression is absent, a null pointer is returned, otherwise the
        pointer will be non-null.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_listexpr(U32 flags)
    </pre>
  </dd>
  <dt>parse_stmtseq</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Parse a sequence of zero or more Perl statements. These may be
        normal imperative statements, including optional labels, or declarations
        that have compile-time effect, or any mixture thereof. The statement
        sequence ends when a closing brace or end-of-file is encountered in a
        place where a new statement could have validly started. It is up to the
        caller to ensure that the dynamic parser state (&quot;PL_parser&quot; et
        al) is correctly set to reflect the source of the code to be parsed and
        the lexical context for the statements.</p>
    <p class="Pp">The op tree representing the statement sequence is returned.
        This may be a null pointer if the statements were all null, for example
        if there were no statements or if there were only subroutine definitions
        (which have compile-time side effects). If not null, it will be a
        <span class="Li">&quot;lineseq&quot;</span> list, normally including
        <span class="Li">&quot;nextstate&quot;</span> or equivalent ops.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter is
        reserved for future use, and must always be zero.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_stmtseq(U32 flags)
    </pre>
  </dd>
  <dt>parse_termexpr</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Parse a Perl term expression. This may contain operators of
        precedence down to the assignment operators. The expression must be
        followed (and thus terminated) either by a comma or lower-precedence
        operator or by something that would normally terminate an expression
        such as semicolon. If <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;PARSE_OPTIONAL&quot;</span> bit set, then the
        expression is optional, otherwise it is mandatory. It is up to the
        caller to ensure that the dynamic parser state (&quot;PL_parser&quot; et
        al) is correctly set to reflect the source of the code to be parsed and
        the lexical context for the expression.</p>
    <p class="Pp">The op tree representing the expression is returned. If an
        optional expression is absent, a null pointer is returned, otherwise the
        pointer will be non-null.</p>
    <p class="Pp">If an error occurs in parsing or compilation, in most cases a
        valid op tree is returned anyway. The error is reflected in the parser
        state, normally resulting in a single exception at the top level of
        parsing which covers all the compilation errors that occurred. Some
        compilation errors, however, will throw an exception immediately.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    parse_termexpr(U32 flags)
    </pre>
  </dd>
  <dt>PL_parser</dt>
  <dd>Pointer to a structure encapsulating the state of the parsing operation
      currently in progress. The pointer can be locally changed to perform a
      nested parse without interfering with the state of an outer parse.
      Individual members of <span class="Li">&quot;PL_parser&quot;</span> have
      their own documentation.</dd>
  <dt>PL_parser-&gt;bufend</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Direct pointer to the end of the chunk of text currently being
        lexed, the end of the lexer buffer. This is equal to
        <span class="Li">&quot;SvPVX(PL_parser-&gt;linestr)</span>
        <span class="Li">+ SvCUR(PL_parser-&gt;linestr)&quot;</span>. A
        <span class="Li">&quot;NUL&quot;</span> character (zero octet) is always
        located at the end of the buffer, and does not count as part of the
        buffer's contents.</p>
  </dd>
  <dt>PL_parser-&gt;bufptr</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Points to the current position of lexing inside the lexer
        buffer. Characters around this point may be freely examined, within the
        range delimited by
        <span class="Li">&quot;SvPVX(&quot;PL_parser-&gt;linestr&quot;)&quot;</span>
        and &quot;PL_parser-&gt;bufend&quot;. The octets of the buffer may be
        intended to be interpreted as either UTF-8 or Latin-1, as indicated by
        &quot;lex_bufutf8&quot;.</p>
    <p class="Pp">Lexing code (whether in the Perl core or not) moves this
        pointer past the characters that it consumes. It is also expected to
        perform some bookkeeping whenever a newline character is consumed. This
        movement can be more conveniently performed by the function
        &quot;lex_read_to&quot;, which handles newlines appropriately.</p>
    <p class="Pp">Interpretation of the buffer's octets can be abstracted out by
        using the slightly higher-level functions &quot;lex_peek_unichar&quot;
        and &quot;lex_read_unichar&quot;.</p>
  </dd>
  <dt>PL_parser-&gt;linestart</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Points to the start of the current line inside the lexer
        buffer. This is useful for indicating at which column an error occurred,
        and not much else. This must be updated by any lexing code that consumes
        a newline; the function &quot;lex_read_to&quot; handles this detail.</p>
  </dd>
  <dt>PL_parser-&gt;linestr</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Buffer scalar containing the chunk currently under
        consideration of the text currently being lexed. This is always a plain
        string scalar (for which <span class="Li">&quot;SvPOK&quot;</span> is
        true). It is not intended to be used as a scalar by normal scalar means;
        instead refer to the buffer directly by the pointer variables described
        below.</p>
    <p class="Pp">The lexer maintains various
        <span class="Li">&quot;char*&quot;</span> pointers to things in the
        <span class="Li">&quot;PL_parser-&gt;linestr&quot;</span> buffer. If
        <span class="Li">&quot;PL_parser-&gt;linestr&quot;</span> is ever
        reallocated, all of these pointers must be updated. Don't attempt to do
        this manually, but rather use &quot;lex_grow_linestr&quot; if you need
        to reallocate the buffer.</p>
    <p class="Pp">The content of the text chunk in the buffer is commonly
        exactly one complete line of input, up to and including a newline
        terminator, but there are situations where it is otherwise. The octets
        of the buffer may be intended to be interpreted as either UTF-8 or
        Latin-1. The function &quot;lex_bufutf8&quot; tells you which. Do not
        use the <span class="Li">&quot;SvUTF8&quot;</span> flag on this scalar,
        which may disagree with it.</p>
    <p class="Pp">For direct examination of the buffer, the variable
        &quot;PL_parser-&gt;bufend&quot; points to the end of the buffer. The
        current lexing position is pointed to by
        &quot;PL_parser-&gt;bufptr&quot;. Direct use of these pointers is
        usually preferable to examination of the scalar through normal scalar
        means.</p>
  </dd>
  <dt>wrap_keyword_plugin</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Puts a C function into the chain of keyword plugins. This is
        the preferred way to manipulate the &quot;PL_keyword_plugin&quot;
        variable. <span class="Li">&quot;new_plugin&quot;</span> is a pointer to
        the C function that is to be added to the keyword plugin chain, and
        <span class="Li">&quot;old_plugin_p&quot;</span> points to the storage
        location where a pointer to the next function in the chain will be
        stored. The value of <span class="Li">&quot;new_plugin&quot;</span> is
        written into the &quot;PL_keyword_plugin&quot; variable, while the value
        previously stored there is written to
        <span class="Li">*old_plugin_p</span>.</p>
    <p class="Pp">&quot;PL_keyword_plugin&quot; is global to an entire process,
        and a module wishing to hook keyword parsing may find itself invoked
        more than once per process, typically in different threads. To handle
        that situation, this function is idempotent. The location
        <span class="Li">*old_plugin_p</span> must initially (once per process)
        contain a null pointer. A C variable of static duration (declared at
        file scope, typically also marked
        <span class="Li">&quot;static&quot;</span> to give it internal linkage)
        will be implicitly initialised appropriately, if it does not have an
        explicit initialiser. This function will only actually modify the plugin
        chain if it finds <span class="Li">*old_plugin_p</span> to be null. This
        function is also thread safe on the small scale. It uses appropriate
        locking to avoid race conditions in accessing
        &quot;PL_keyword_plugin&quot;.</p>
    <p class="Pp">When this function is called, the function referenced by
        <span class="Li">&quot;new_plugin&quot;</span> must be ready to be
        called, except for <span class="Li">*old_plugin_p</span> being unfilled.
        In a threading situation, <span class="Li">&quot;new_plugin&quot;</span>
        may be called immediately, even before this function has returned.
        <span class="Li">*old_plugin_p</span> will always be appropriately set
        before <span class="Li">&quot;new_plugin&quot;</span> is called. If
        <span class="Li">&quot;new_plugin&quot;</span> decides not to do
        anything special with the identifier that it is given (which is the
        usual case for most calls to a keyword plugin), it must chain the plugin
        function referenced by <span class="Li">*old_plugin_p</span>.</p>
    <p class="Pp">Taken all together, XS code to install a keyword plugin should
        typically look something like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    static Perl_keyword_plugin_t next_keyword_plugin;
    static OP *my_keyword_plugin(pTHX_
        char *keyword_plugin, STRLEN keyword_len, OP **op_ptr)
    {
        if (memEQs(keyword_ptr, keyword_len,
                   &quot;my_new_keyword&quot;)) {
            ...
        } else {
            return next_keyword_plugin(aTHX_
                keyword_ptr, keyword_len, op_ptr);
        }
    }
    BOOT:
        wrap_keyword_plugin(my_keyword_plugin,
                            &amp;next_keyword_plugin);
    </pre>
    <p class="Pp">Direct access to &quot;PL_keyword_plugin&quot; should be
        avoided.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    wrap_keyword_plugin(
                    Perl_keyword_plugin_t new_plugin,
                    Perl_keyword_plugin_t *old_plugin_p
                )
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Locale-related_functions_and_macros"><a class="permalink" href="#Locale-related_functions_and_macros">Locale-related
  functions and macros</a></h1>
<dl class="Bl-tag">
  <dt>DECLARATION_FOR_LC_NUMERIC_MANIPULATION</dt>
  <dd>This macro should be used as a statement. It declares a private variable
      (whose name begins with an underscore) that is needed by the other macros
      in this section. Failing to include this correctly should lead to a syntax
      error. For compatibility with C89 C compilers it should be placed in a
      block before any executable statements.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    DECLARATION_FOR_LC_NUMERIC_MANIPULATION
    </pre>
  </dd>
  <dt>Perl_langinfo</dt>
  <dd>This is an (almost) drop-in replacement for the system
      <span class="Li">nl_langinfo(3)</span>, taking the same
      <span class="Li">&quot;item&quot;</span> parameter values, and returning
      the same information. But it is more thread-safe than regular
      <span class="Li">&quot;nl_langinfo()&quot;</span>, and hides the quirks of
      Perl's locale handling from your code, and can be used on systems that
      lack a native <span class="Li">&quot;nl_langinfo&quot;</span>.
    <p class="Pp">Expanding on these:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>The reason it isn't quite a drop-in replacement is actually an advantage.
      The only difference is that it returns
      <span class="Li">&quot;const&#x00A0;char&#x00A0;*&quot;</span>, whereas
      plain <span class="Li">&quot;nl_langinfo()&quot;</span> returns
      <span class="Li">&quot;char&#x00A0;*&quot;</span>, but you are (only by
      documentation) forbidden to write into the buffer. By declaring this
      <span class="Li">&quot;const&quot;</span>, the compiler enforces this
      restriction, so if it is violated, you know at compilation time, rather
      than getting segfaults at runtime.</li>
  <li>It delivers the correct results for the
      <span class="Li">&quot;RADIXCHAR&quot;</span> and
      <span class="Li">&quot;THOUSEP&quot;</span> items, without you having to
      write extra code. The reason for the extra code would be because these are
      from the <span class="Li">&quot;LC_NUMERIC&quot;</span> locale category,
      which is normally kept set by Perl so that the radix is a dot, and the
      separator is the empty string, no matter what the underlying locale is
      supposed to be, and so to get the expected results, you have to
      temporarily toggle into the underlying locale, and later toggle back. (You
      could use plain <span class="Li">&quot;nl_langinfo&quot;</span> and
      <span class="Li">&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;</span>
      for this but then you wouldn't get the other advantages of
      <span class="Li">&quot;Perl_langinfo()&quot;</span>; not keeping
      <span class="Li">&quot;LC_NUMERIC&quot;</span> in the C (or equivalent)
      locale would break a lot of CPAN, which is expecting the radix (decimal
      point) character to be a dot.)</li>
  <li>The system function it replaces can have its static return buffer trashed,
      not only by a subesequent call to that function, but by a
      <span class="Li">&quot;freelocale&quot;</span>,
      <span class="Li">&quot;setlocale&quot;</span>, or other locale change. The
      returned buffer of this function is not changed until the next call to it,
      so the buffer is never in a trashed state.</li>
  <li>Its return buffer is per-thread, so it also is never overwritten by a call
      to this function from another thread; unlike the function it
    replaces.</li>
  <li>But most importantly, it works on systems that don't have
      <span class="Li">&quot;nl_langinfo&quot;</span>, such as Windows, hence
      makes your code more portable. Of the fifty-some possible items specified
      by the POSIX 2008 standard,
      &lt;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&gt;,
      only one is completely unimplemented, though on non-Windows platforms,
      another significant one is also not implemented). It uses various
      techniques to recover the other items, including calling
      <span class="Li">localeconv(3)</span>, and
      <span class="Li">strftime(3)</span>, both of which are specified in C89,
      so should be always be available. Later
      <span class="Li">&quot;strftime()&quot;</span> versions have additional
      capabilities; <span class="Li">&quot;&quot;</span> is returned for those
      not available on your system.
    <p class="Pp">It is important to note that when called with an item that is
        recovered by using <span class="Li">&quot;localeconv&quot;</span>, the
        buffer from any previous explicit call to
        <span class="Li">&quot;localeconv&quot;</span> will be overwritten. This
        means you must save that buffer's contents if you need to access them
        after a call to this function. (But note that you might not want to be
        using <span class="Li">&quot;localeconv()&quot;</span> directly anyway,
        because of issues like the ones listed in the second item of this list
        (above) for <span class="Li">&quot;RADIXCHAR&quot;</span> and
        <span class="Li">&quot;THOUSEP&quot;</span>. You can use the methods
        given in perlcall to call &quot;localeconv&quot; in POSIX and avoid all
        the issues, but then you have a hash to unpack).</p>
    <p class="Pp">The details for those items which may deviate from what this
        emulation returns and what a native
        <span class="Li">&quot;nl_langinfo()&quot;</span> would return are
        specified in I18N::Langinfo.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">When using <span class="Li">&quot;Perl_langinfo&quot;</span> on
    systems that don't have a native
    <span class="Li">&quot;nl_langinfo()&quot;</span>, you must</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 #include &quot;perl_langinfo.h&quot;
</pre>
<p class="Pp">before the <span class="Li">&quot;perl.h&quot;</span>
    <span class="Li">&quot;#include&quot;</span>. You can replace your
    <span class="Li">&quot;langinfo.h&quot;</span>
    <span class="Li">&quot;#include&quot;</span> with this one. (Doing it this
    way keeps out the symbols that plain
    <span class="Li">&quot;langinfo.h&quot;</span> would try to import into the
    namespace for code that doesn't need it.)</p>
<p class="Pp">The original impetus for
    <span class="Li">&quot;Perl_langinfo()&quot;</span> was so that code that
    needs to find out the current currency symbol, floating point radix
    character, or digit grouping separator can use, on all systems, the simpler
    and more thread-friendly <span class="Li">&quot;nl_langinfo&quot;</span> API
    instead of <span class="Li">localeconv(3)</span> which is a pain to make
    thread-friendly. For other fields returned by
    <span class="Li">&quot;localeconv&quot;</span>, it is better to use the
    methods given in perlcall to call
    <span class="Li">&quot;POSIX::localeconv()&quot;</span>, which is
    thread-friendly.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        const char* Perl_langinfo(const nl_item item)
</pre>
</div>
<dl class="Bl-tag">
  <dt>Perl_setlocale</dt>
  <dd>This is an (almost) drop-in replacement for the system
      <span class="Li">setlocale(3)</span>, taking the same parameters, and
      returning the same information, except that it returns the correct
      underlying <span class="Li">&quot;LC_NUMERIC&quot;</span> locale. Regular
      <span class="Li">&quot;setlocale&quot;</span> will instead return
      <span class="Li">&quot;C&quot;</span> if the underlying locale has a
      non-dot decimal point character, or a non-empty thousands separator for
      displaying floating point numbers. This is because perl keeps that locale
      category such that it has a dot and empty separator, changing the locale
      briefly during the operations where the underlying one is required.
      <span class="Li">&quot;Perl_setlocale&quot;</span> knows about this, and
      compensates; regular <span class="Li">&quot;setlocale&quot;</span>
      doesn't.
    <p class="Pp">Another reason it isn't completely a drop-in replacement is
        that it is declared to return
        <span class="Li">&quot;const&#x00A0;char&#x00A0;*&quot;</span>, whereas
        the system setlocale omits the <span class="Li">&quot;const&quot;</span>
        (presumably because its API was specified long ago, and can't be
        updated; it is illegal to change the information
        <span class="Li">&quot;setlocale&quot;</span> returns; doing so leads to
        segfaults.)</p>
    <p class="Pp">Finally, <span class="Li">&quot;Perl_setlocale&quot;</span>
        works under all circumstances, whereas plain
        <span class="Li">&quot;setlocale&quot;</span> can be completely
        ineffective on some platforms under some configurations.</p>
    <p class="Pp"><span class="Li">&quot;Perl_setlocale&quot;</span> should not
        be used to change the locale except on systems where the predefined
        variable <span class="Li">&quot;${^SAFE_LOCALES}&quot;</span> is 1. On
        some such systems, the system
        <span class="Li">&quot;setlocale()&quot;</span> is ineffective,
        returning the wrong information, and failing to actually change the
        locale. <span class="Li">&quot;Perl_setlocale&quot;</span>, however
        works properly in all circumstances.</p>
    <p class="Pp">The return points to a per-thread static buffer, which is
        overwritten the next time
        <span class="Li">&quot;Perl_setlocale&quot;</span> is called from the
        same thread.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char* Perl_setlocale(const int category,
                                   const char* locale)
    </pre>
  </dd>
  <dt>RESTORE_LC_NUMERIC</dt>
  <dd>This is used in conjunction with one of the macros
      &quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot; and
      &quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot; to properly restore the
      <span class="Li">&quot;LC_NUMERIC&quot;</span> state.
    <p class="Pp">A call to &quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;
        must have been made to declare at compile time a private variable used
        by this macro and the two <span class="Li">&quot;STORE&quot;</span>
        ones. This macro should be called as a single statement, not an
        expression, but with an empty argument list, like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    RESTORE_LC_NUMERIC();
     ...
 }

        void    RESTORE_LC_NUMERIC()
    </pre>
  </dd>
  <dt>STORE_LC_NUMERIC_FORCE_TO_UNDERLYING</dt>
  <dd>This is used by XS code that that is
      <span class="Li">&quot;LC_NUMERIC&quot;</span> locale-aware to force the
      locale for category <span class="Li">&quot;LC_NUMERIC&quot;</span> to be
      what perl thinks is the current underlying locale. (The perl interpreter
      could be wrong about what the underlying locale actually is if some C or
      XS code has called the C library function <b>setlocale</b>(3) behind its
      back; calling &quot;sync_locale&quot; before calling this macro will
      update perl's records.)
    <p class="Pp">A call to &quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;
        must have been made to declare at compile time a private variable used
        by this macro. This macro should be called as a single statement, not an
        expression, but with an empty argument list, like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    STORE_LC_NUMERIC_FORCE_TO_UNDERLYING();
     ...
    RESTORE_LC_NUMERIC();
     ...
 }
    </pre>
    <p class="Pp">The private variable is used to save the current locale state,
        so that the requisite matching call to &quot;RESTORE_LC_NUMERIC&quot;
        can restore it.</p>
    <p class="Pp">On threaded perls not operating with thread-safe
        functionality, this macro uses a mutex to force a critical section.
        Therefore the matching RESTORE should be close by, and guaranteed to be
        called.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    STORE_LC_NUMERIC_FORCE_TO_UNDERLYING()
    </pre>
  </dd>
  <dt>STORE_LC_NUMERIC_SET_TO_NEEDED</dt>
  <dd>This is used to help wrap XS or C code that is
      <span class="Li">&quot;LC_NUMERIC&quot;</span> locale-aware. This locale
      category is generally kept set to a locale where the decimal radix
      character is a dot, and the separator between groups of digits is empty.
      This is because most XS code that reads floating point numbers is
      expecting them to have this syntax.
    <p class="Pp">This macro makes sure the current
        <span class="Li">&quot;LC_NUMERIC&quot;</span> state is set properly, to
        be aware of locale if the call to the XS or C code from the Perl program
        is from within the scope of a
        <span class="Li">&quot;use&#x00A0;locale&quot;</span>; or to ignore
        locale if the call is instead from outside such scope.</p>
    <p class="Pp">This macro is the start of wrapping the C or XS code; the wrap
        ending is done by calling the &quot;RESTORE_LC_NUMERIC&quot; macro after
        the operation. Otherwise the state can be changed that will adversely
        affect other XS code.</p>
    <p class="Pp">A call to &quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;
        must have been made to declare at compile time a private variable used
        by this macro. This macro should be called as a single statement, not an
        expression, but with an empty argument list, like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 {
    DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
     ...
    STORE_LC_NUMERIC_SET_TO_NEEDED();
     ...
    RESTORE_LC_NUMERIC();
     ...
 }
    </pre>
    <p class="Pp">On threaded perls not operating with thread-safe
        functionality, this macro uses a mutex to force a critical section.
        Therefore the matching RESTORE should be close by, and guaranteed to be
        called.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    STORE_LC_NUMERIC_SET_TO_NEEDED()
    </pre>
  </dd>
  <dt>switch_to_global_locale</dt>
  <dd>On systems without locale support, or on typical single-threaded builds,
      or on platforms that do not support per-thread locale operations, this
      function does nothing. On such systems that do have locale support, only a
      locale global to the whole program is available.
    <p class="Pp">On multi-threaded builds on systems that do have per-thread
        locale operations, this function converts the thread it is running in to
        use the global locale. This is for code that has not yet or cannot be
        updated to handle multi-threaded locale operation. As long as only a
        single thread is so-converted, everything works fine, as all the other
        threads continue to ignore the global one, so only this thread looks at
        it.</p>
    <p class="Pp">However, on Windows systems this isn't quite true prior to
        Visual Studio 15, at which point Microsoft fixed a bug. A race can occur
        if you use the following operations on earlier Windows platforms:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>POSIX::localeconv</dt>
  <dd></dd>
  <dt>I18N::Langinfo, items &quot;CRNCYSTR&quot; and &quot;THOUSEP&quot;</dt>
  <dd></dd>
  <dt>&quot;Perl_langinfo&quot; in perlapi, items &quot;CRNCYSTR&quot; and
    &quot;THOUSEP&quot;</dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">The first item is not fixable (except by upgrading to a later
    Visual Studio release), but it would be possible to work around the latter
    two items by using the Windows API functions
    <span class="Li">&quot;GetNumberFormat&quot;</span> and
    <span class="Li">&quot;GetCurrencyFormat&quot;</span>; patches welcome.</p>
<p class="Pp">Without this function call, threads that use the
    <span class="Li">setlocale(3)</span> system function will not work properly,
    as all the locale-sensitive functions will look at the per-thread locale,
    and <span class="Li">&quot;setlocale&quot;</span> will have no effect on
    this thread.</p>
<p class="Pp">Perl code should convert to either call
    <span class="Li">&quot;Perl_setlocale&quot;</span> (which is a drop-in for
    the system <span class="Li">&quot;setlocale&quot;</span>) or use the methods
    given in perlcall to call
    <span class="Li">&quot;POSIX::setlocale&quot;</span>. Either one will
    transparently properly handle all cases of single- vs multi-thread, POSIX
    2008-supported or not.</p>
<p class="Pp">Non-Perl libraries, such as
    <span class="Li">&quot;gtk&quot;</span>, that call the system
    <span class="Li">&quot;setlocale&quot;</span> can continue to work if this
    function is called before transferring control to the library.</p>
<p class="Pp">Upon return from the code that needs to use the global locale,
    <span class="Li">&quot;sync_locale()&quot;</span> should be called to
    restore the safe multi-thread operation.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        void    switch_to_global_locale()
</pre>
</div>
<dl class="Bl-tag">
  <dt>sync_locale</dt>
  <dd><span class="Li">&quot;Perl_setlocale&quot;</span> can be used at any time
      to query or change the locale (though changing the locale is antisocial
      and dangerous on multi-threaded systems that don't have multi-thread safe
      locale operations. (See &quot;Multi-threaded operation&quot; in
      perllocale). Using the system <span class="Li">setlocale(3)</span> should
      be avoided. Nevertheless, certain non-Perl libraries called from XS, such
      as <span class="Li">&quot;Gtk&quot;</span> do so, and this can't be
      changed. When the locale is changed by XS code that didn't use
      <span class="Li">&quot;Perl_setlocale&quot;</span>, Perl needs to be told
      that the locale has changed. Use this function to do so, before returning
      to Perl.
    <p class="Pp">The return value is a boolean: TRUE if the global locale at
        the time of call was in effect; and FALSE if a per-thread locale was in
        effect. This can be used by the caller that needs to restore things
        as-they-were to decide whether or not to call
        <span class="Li">&quot;Perl_switch_to_global_locale&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sync_locale()
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Magical_Functions"><a class="permalink" href="#Magical_Functions">Magical
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>mg_clear</dt>
  <dd>Clear something magical that the SV represents. See
      <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     mg_clear(SV* sv)
    </pre>
  </dd>
  <dt>mg_copy</dt>
  <dd>Copies the magic from one SV to another. See
      <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     mg_copy(SV *sv, SV *nsv, const char *key,
                        I32 klen)
    </pre>
  </dd>
  <dt>mg_find</dt>
  <dd>Finds the magic pointer for <span class="Li">&quot;type&quot;</span>
      matching the SV. See <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        MAGIC*  mg_find(const SV* sv, int type)
    </pre>
  </dd>
  <dt>mg_findext</dt>
  <dd>Finds the magic pointer of <span class="Li">&quot;type&quot;</span> with
      the given <span class="Li">&quot;vtbl&quot;</span> for the
      <span class="Li">&quot;SV&quot;</span>. See
      <span class="Li">&quot;sv_magicext&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        MAGIC*  mg_findext(const SV* sv, int type,
                           const MGVTBL *vtbl)
    </pre>
  </dd>
  <dt>mg_free</dt>
  <dd>Free any magic storage used by the SV. See
      <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     mg_free(SV* sv)
    </pre>
  </dd>
  <dt>mg_freeext</dt>
  <dd>Remove any magic of type <span class="Li">&quot;how&quot;</span> using
      virtual table <span class="Li">&quot;vtbl&quot;</span> from the SV
      <span class="Li">&quot;sv&quot;</span>. See &quot;sv_magic&quot;.
    <p class="Pp"><span class="Li">&quot;mg_freeext(sv, how, NULL)&quot;</span>
        is equivalent to <span class="Li">&quot;mg_free_type(sv,
        how)&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mg_freeext(SV* sv, int how, const MGVTBL *vtbl)
    </pre>
  </dd>
  <dt>mg_free_type</dt>
  <dd>Remove any magic of type <span class="Li">&quot;how&quot;</span> from the
      SV <span class="Li">&quot;sv&quot;</span>. See &quot;sv_magic&quot;.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mg_free_type(SV *sv, int how)
    </pre>
  </dd>
  <dt>mg_get</dt>
  <dd>Do magic before a value is retrieved from the SV. The type of SV must be
      &gt;= <span class="Li">&quot;SVt_PVMG&quot;</span>. See
      <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     mg_get(SV* sv)
    </pre>
  </dd>
  <dt>mg_length</dt>
  <dd>DEPRECATED! It is planned to remove this function from a future release of
      Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Reports on the SV's length in bytes, calling length magic if
        available, but does not set the UTF8 flag on
        <span class="Li">&quot;sv&quot;</span>. It will fall back to 'get' magic
        if there is no 'length' magic, but with no indication as to whether it
        called 'get' magic. It assumes <span class="Li">&quot;sv&quot;</span> is
        a <span class="Li">&quot;PVMG&quot;</span> or higher. Use
        <span class="Li">&quot;sv_len()&quot;</span> instead.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     mg_length(SV* sv)
    </pre>
  </dd>
  <dt>mg_magical</dt>
  <dd>Turns on the magical status of an SV. See
      <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mg_magical(SV* sv)
    </pre>
  </dd>
  <dt>mg_set</dt>
  <dd>Do magic after a value is assigned to the SV. See
      <span class="Li">&quot;sv_magic&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     mg_set(SV* sv)
    </pre>
  </dd>
  <dt>SvGETMAGIC</dt>
  <dd>Invokes <span class="Li">&quot;mg_get&quot;</span> on an SV if it has
      'get' magic. For example, this will call
      <span class="Li">&quot;FETCH&quot;</span> on a tied variable. This macro
      evaluates its argument more than once.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvGETMAGIC(SV* sv)
    </pre>
  </dd>
  <dt>SvLOCK</dt>
  <dd>Arranges for a mutual exclusion lock to be obtained on
      <span class="Li">&quot;sv&quot;</span> if a suitable module has been
      loaded.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvLOCK(SV* sv)
    </pre>
  </dd>
  <dt>SvSETMAGIC</dt>
  <dd>Invokes <span class="Li">&quot;mg_set&quot;</span> on an SV if it has
      'set' magic. This is necessary after modifying a scalar, in case it is a
      magical variable like <span class="Li">$|</span> or a tied variable (it
      calls <span class="Li">&quot;STORE&quot;</span>). This macro evaluates its
      argument more than once.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSETMAGIC(SV* sv)
    </pre>
  </dd>
  <dt>SvSetMagicSV</dt>
  <dd>Like <span class="Li">&quot;SvSetSV&quot;</span>, but does any set magic
      required afterwards.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSetMagicSV(SV* dsv, SV* ssv)
    </pre>
  </dd>
  <dt>SvSetMagicSV_nosteal</dt>
  <dd>Like <span class="Li">&quot;SvSetSV_nosteal&quot;</span>, but does any set
      magic required afterwards.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSetMagicSV_nosteal(SV* dsv, SV* ssv)
    </pre>
  </dd>
  <dt>SvSetSV</dt>
  <dd>Calls <span class="Li">&quot;sv_setsv&quot;</span> if
      <span class="Li">&quot;dsv&quot;</span> is not the same as
      <span class="Li">&quot;ssv&quot;</span>. May evaluate arguments more than
      once. Does not handle 'set' magic on the destination SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSetSV(SV* dsv, SV* ssv)
    </pre>
  </dd>
  <dt>SvSetSV_nosteal</dt>
  <dd>Calls a non-destructive version of
      <span class="Li">&quot;sv_setsv&quot;</span> if
      <span class="Li">&quot;dsv&quot;</span> is not the same as
      <span class="Li">&quot;ssv&quot;</span>. May evaluate arguments more than
      once.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSetSV_nosteal(SV* dsv, SV* ssv)
    </pre>
  </dd>
  <dt>SvSHARE</dt>
  <dd>Arranges for <span class="Li">&quot;sv&quot;</span> to be shared between
      threads if a suitable module has been loaded.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSHARE(SV* sv)
    </pre>
  </dd>
  <dt>sv_string_from_errnum</dt>
  <dd>Generates the message string describing an OS error and returns it as an
      SV. <span class="Li">&quot;errnum&quot;</span> must be a value that
      <span class="Li">&quot;errno&quot;</span> could take, identifying the type
      of error.
    <p class="Pp">If <span class="Li">&quot;tgtsv&quot;</span> is non-null then
        the string will be written into that SV (overwriting existing content)
        and it will be returned. If <span class="Li">&quot;tgtsv&quot;</span> is
        a null pointer then the string will be written into a new mortal SV
        which will be returned.</p>
    <p class="Pp">The message will be taken from whatever locale would be used
        by <span class="Li">$!</span>, and will be encoded in the SV in whatever
        manner would be used by <span class="Li">$!</span>. The details of this
        process are subject to future change. Currently, the message is taken
        from the C locale by default (usually producing an English message), and
        from the currently selected locale when in the scope of the
        <span class="Li">&quot;use locale&quot;</span> pragma. A heuristic
        attempt is made to decode the message from the locale's character
        encoding, but it will only be decoded as either UTF-8 or ISO-8859-1. It
        is always correctly decoded in a UTF-8 locale, usually in an ISO-8859-1
        locale, and never in any other locale.</p>
    <p class="Pp">The SV is always returned containing an actual string, and
        with no other OK bits set. Unlike <span class="Li">$!</span>, a message
        is even yielded for <span class="Li">&quot;errnum&quot;</span> zero
        (meaning success), and if no useful message is available then a useless
        string (currently empty) is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    sv_string_from_errnum(int errnum, SV *tgtsv)
    </pre>
  </dd>
  <dt>SvUNLOCK</dt>
  <dd>Releases a mutual exclusion lock on <span class="Li">&quot;sv&quot;</span>
      if a suitable module has been loaded.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvUNLOCK(SV* sv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Memory_Management"><a class="permalink" href="#Memory_Management">Memory
  Management</a></h1>
<dl class="Bl-tag">
  <dt>Copy</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;memcpy&quot;</span> function. The
      <span class="Li">&quot;src&quot;</span> is the source,
      <span class="Li">&quot;dest&quot;</span> is the destination,
      <span class="Li">&quot;nitems&quot;</span> is the number of items, and
      <span class="Li">&quot;type&quot;</span> is the type. May fail on
      overlapping copies. See also <span class="Li">&quot;Move&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Copy(void* src, void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>CopyD</dt>
  <dd>Like <span class="Li">&quot;Copy&quot;</span> but returns
      <span class="Li">&quot;dest&quot;</span>. Useful for encouraging compilers
      to tail-call optimise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void *  CopyD(void* src, void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>Move</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;memmove&quot;</span> function. The
      <span class="Li">&quot;src&quot;</span> is the source,
      <span class="Li">&quot;dest&quot;</span> is the destination,
      <span class="Li">&quot;nitems&quot;</span> is the number of items, and
      <span class="Li">&quot;type&quot;</span> is the type. Can do overlapping
      moves. See also <span class="Li">&quot;Copy&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Move(void* src, void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>MoveD</dt>
  <dd>Like <span class="Li">&quot;Move&quot;</span> but returns
      <span class="Li">&quot;dest&quot;</span>. Useful for encouraging compilers
      to tail-call optimise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void *  MoveD(void* src, void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>Newx</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;malloc&quot;</span> function.
    <p class="Pp">Memory obtained by this should <b>ONLY</b> be freed with
        &quot;Safefree&quot;.</p>
    <p class="Pp">In 5.9.3, <b>Newx()</b> and friends replace the older
        <b>New()</b> API, and drops the first parameter, <i>x</i>, a debug aid
        which allowed callers to identify themselves. This aid has been
        superseded by a new build option, PERL_MEM_LOG (see
        &quot;PERL_MEM_LOG&quot; in perlhacktips). The older API is still there
        for use in XS modules supporting older perls.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Newx(void* ptr, int nitems, type)
    </pre>
  </dd>
  <dt>Newxc</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;malloc&quot;</span> function, with cast. See also
      <span class="Li">&quot;Newx&quot;</span>.
    <p class="Pp">Memory obtained by this should <b>ONLY</b> be freed with
        &quot;Safefree&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Newxc(void* ptr, int nitems, type, cast)
    </pre>
  </dd>
  <dt>Newxz</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;malloc&quot;</span> function. The allocated memory
      is zeroed with <span class="Li">&quot;memzero&quot;</span>. See also
      <span class="Li">&quot;Newx&quot;</span>.
    <p class="Pp">Memory obtained by this should <b>ONLY</b> be freed with
        &quot;Safefree&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Newxz(void* ptr, int nitems, type)
    </pre>
  </dd>
  <dt>Poison</dt>
  <dd>PoisonWith(0xEF) for catching access to freed memory.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Poison(void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>PoisonFree</dt>
  <dd>PoisonWith(0xEF) for catching access to freed memory.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PoisonFree(void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>PoisonNew</dt>
  <dd>PoisonWith(0xAB) for catching access to allocated but uninitialized
      memory.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PoisonNew(void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>PoisonWith</dt>
  <dd>Fill up memory with a byte pattern (a byte repeated over and over again)
      that hopefully catches attempts to access uninitialized memory.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PoisonWith(void* dest, int nitems, type,
                           U8 byte)
    </pre>
  </dd>
  <dt>Renew</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;realloc&quot;</span> function.
    <p class="Pp">Memory obtained by this should <b>ONLY</b> be freed with
        &quot;Safefree&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Renew(void* ptr, int nitems, type)
    </pre>
  </dd>
  <dt>Renewc</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;realloc&quot;</span> function, with cast.
    <p class="Pp">Memory obtained by this should <b>ONLY</b> be freed with
        &quot;Safefree&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Renewc(void* ptr, int nitems, type, cast)
    </pre>
  </dd>
  <dt>Safefree</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;free&quot;</span> function.
    <p class="Pp">This should <b>ONLY</b> be used on memory obtained using
        &quot;Newx&quot; and friends.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Safefree(void* ptr)
    </pre>
  </dd>
  <dt>savepv</dt>
  <dd>Perl's version of <span class="Li">&quot;strdup()&quot;</span>. Returns a
      pointer to a newly allocated string which is a duplicate of
      <span class="Li">&quot;pv&quot;</span>. The size of the string is
      determined by <span class="Li">&quot;strlen()&quot;</span>, which means it
      may not contain embedded <span class="Li">&quot;NUL&quot;</span>
      characters and must have a trailing
      <span class="Li">&quot;NUL&quot;</span>. The memory allocated for the new
      string can be freed with the
      <span class="Li">&quot;Safefree()&quot;</span> function.
    <p class="Pp">On some platforms, Windows for example, all allocated memory
        owned by a thread is deallocated when that thread ends. So if you need
        that not to happen, you need to use the shared memory functions, such as
        <span class="Li">&quot;savesharedpv&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savepv(const char* pv)
    </pre>
  </dd>
  <dt>savepvn</dt>
  <dd>Perl's version of what <span class="Li">&quot;strndup()&quot;</span> would
      be if it existed. Returns a pointer to a newly allocated string which is a
      duplicate of the first <span class="Li">&quot;len&quot;</span> bytes from
      <span class="Li">&quot;pv&quot;</span>, plus a trailing
      <span class="Li">&quot;NUL&quot;</span> byte. The memory allocated for the
      new string can be freed with the
      <span class="Li">&quot;Safefree()&quot;</span> function.
    <p class="Pp">On some platforms, Windows for example, all allocated memory
        owned by a thread is deallocated when that thread ends. So if you need
        that not to happen, you need to use the shared memory functions, such as
        <span class="Li">&quot;savesharedpvn&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savepvn(const char* pv, I32 len)
    </pre>
  </dd>
  <dt>savepvs</dt>
  <dd>Like <span class="Li">&quot;savepvn&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savepvs(&quot;literal string&quot; s)
    </pre>
  </dd>
  <dt>savesharedpv</dt>
  <dd>A version of <span class="Li">&quot;savepv()&quot;</span> which allocates
      the duplicate string in memory which is shared between threads.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savesharedpv(const char* pv)
    </pre>
  </dd>
  <dt>savesharedpvn</dt>
  <dd>A version of <span class="Li">&quot;savepvn()&quot;</span> which allocates
      the duplicate string in memory which is shared between threads. (With the
      specific difference that a <span class="Li">&quot;NULL&quot;</span>
      pointer is not acceptable)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savesharedpvn(const char *const pv,
                              const STRLEN len)
    </pre>
  </dd>
  <dt>savesharedpvs</dt>
  <dd>A version of <span class="Li">&quot;savepvs()&quot;</span> which allocates
      the duplicate string in memory which is shared between threads.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savesharedpvs(&quot;literal string&quot; s)
    </pre>
  </dd>
  <dt>savesharedsvpv</dt>
  <dd>A version of <span class="Li">&quot;savesharedpv()&quot;</span> which
      allocates the duplicate string in memory which is shared between threads.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savesharedsvpv(SV *sv)
    </pre>
  </dd>
  <dt>savesvpv</dt>
  <dd>A version of
      <span class="Li">&quot;savepv()&quot;</span>/<span class="Li">&quot;savepvn()&quot;</span>
      which gets the string to duplicate from the passed in SV using
      <span class="Li">&quot;SvPV()&quot;</span>
    <p class="Pp">On some platforms, Windows for example, all allocated memory
        owned by a thread is deallocated when that thread ends. So if you need
        that not to happen, you need to use the shared memory functions, such as
        <span class="Li">&quot;savesharedsvpv&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   savesvpv(SV* sv)
    </pre>
  </dd>
  <dt>StructCopy</dt>
  <dd>This is an architecture-independent macro to copy one structure to
      another.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    StructCopy(type *src, type *dest, type)
    </pre>
  </dd>
  <dt>Zero</dt>
  <dd>The XSUB-writer's interface to the C
      <span class="Li">&quot;memzero&quot;</span> function. The
      <span class="Li">&quot;dest&quot;</span> is the destination,
      <span class="Li">&quot;nitems&quot;</span> is the number of items, and
      <span class="Li">&quot;type&quot;</span> is the type.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    Zero(void* dest, int nitems, type)
    </pre>
  </dd>
  <dt>ZeroD</dt>
  <dd>Like <span class="Li">&quot;Zero&quot;</span> but returns dest. Useful for
      encouraging compilers to tail-call optimise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void *  ZeroD(void* dest, int nitems, type)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Miscellaneous_Functions"><a class="permalink" href="#Miscellaneous_Functions">Miscellaneous
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>dump_c_backtrace</dt>
  <dd>Dumps the C backtrace to the given <span class="Li">&quot;fp&quot;</span>.
    <p class="Pp">Returns true if a backtrace could be retrieved, false if
      not.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    dump_c_backtrace(PerlIO* fp, int max_depth,
                                 int skip)
    </pre>
  </dd>
  <dt>fbm_compile</dt>
  <dd>Analyzes the string in order to make fast searches on it using
      <span class="Li">&quot;fbm_instr()&quot;</span> -- the Boyer-Moore
      algorithm.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    fbm_compile(SV* sv, U32 flags)
    </pre>
  </dd>
  <dt>fbm_instr</dt>
  <dd>Returns the location of the SV in the string delimited by
      <span class="Li">&quot;big&quot;</span> and
      <span class="Li">&quot;bigend&quot;</span>
      (<span class="Li">&quot;bigend&quot;</span>) is the char following the
      last char). It returns <span class="Li">&quot;NULL&quot;</span> if the
      string can't be found. The <span class="Li">&quot;sv&quot;</span> does not
      have to be <span class="Li">&quot;fbm_compiled&quot;</span>, but the
      search will not be as fast then.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   fbm_instr(unsigned char* big,
                          unsigned char* bigend, SV* littlestr,
                          U32 flags)
    </pre>
  </dd>
  <dt>foldEQ</dt>
  <dd>Returns true if the leading <span class="Li">&quot;len&quot;</span> bytes
      of the strings <span class="Li">&quot;s1&quot;</span> and
      <span class="Li">&quot;s2&quot;</span> are the same case-insensitively;
      false otherwise. Uppercase and lowercase ASCII range bytes match
      themselves and their opposite case counterparts. Non-cased and non-ASCII
      range bytes match only themselves.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     foldEQ(const char* a, const char* b, I32 len)
    </pre>
  </dd>
  <dt>foldEQ_locale</dt>
  <dd>Returns true if the leading <span class="Li">&quot;len&quot;</span> bytes
      of the strings <span class="Li">&quot;s1&quot;</span> and
      <span class="Li">&quot;s2&quot;</span> are the same case-insensitively in
      the current locale; false otherwise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     foldEQ_locale(const char* a, const char* b,
                              I32 len)
    </pre>
  </dd>
  <dt>form</dt>
  <dd>Takes a sprintf-style format pattern and conventional (non-SV) arguments
      and returns the formatted string.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    (char *) Perl_form(pTHX_ const char* pat, ...)
    </pre>
    <p class="Pp">can be used any place a string (char *) is required:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    char * s = Perl_form(&quot;%d.%d&quot;,major,minor);
    </pre>
    <p class="Pp">Uses a single private buffer so if you want to format several
        strings you must explicitly copy the earlier strings away (and free the
        copies when you are done).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   form(const char* pat, ...)
    </pre>
  </dd>
  <dt>getcwd_sv</dt>
  <dd>Fill <span class="Li">&quot;sv&quot;</span> with current working directory
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     getcwd_sv(SV* sv)
    </pre>
  </dd>
  <dt>get_c_backtrace_dump</dt>
  <dd>Returns a SV containing a dump of
      <span class="Li">&quot;depth&quot;</span> frames of the call stack,
      skipping the <span class="Li">&quot;skip&quot;</span> innermost ones.
      <span class="Li">&quot;depth&quot;</span> of 20 is usually enough.
    <p class="Pp">The appended output looks like:</p>
    <p class="Pp">... 1 10e004812:0082 Perl_croak util.c:1716 /usr/bin/perl 2
        10df8d6d2:1d72 perl_parse perl.c:3975 /usr/bin/perl ...</p>
    <p class="Pp">The fields are tab-separated. The first column is the depth
        (zero being the innermost non-skipped frame). In the hex:offset, the hex
        is where the program counter was in
        <span class="Li">&quot;S_parse_body&quot;</span>, and the :offset (might
        be missing) tells how much inside the
        <span class="Li">&quot;S_parse_body&quot;</span> the program counter
        was.</p>
    <p class="Pp">The <span class="Li">&quot;util.c:1716&quot;</span> is the
        source code file and line number.</p>
    <p class="Pp">The <i>/usr/bin/perl</i> is obvious (hopefully).</p>
    <p class="Pp">Unknowns are <span class="Li">&quot;-&quot;</span>. Unknowns
        can happen unfortunately quite easily: if the platform doesn't support
        retrieving the information; if the binary is missing the debug
        information; if the optimizer has transformed the code by for example
        inlining.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     get_c_backtrace_dump(int max_depth, int skip)
    </pre>
  </dd>
  <dt>ibcmp</dt>
  <dd>This is a synonym for
      <span class="Li">&quot;(!&#x00A0;foldEQ())&quot;</span>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     ibcmp(const char* a, const char* b, I32 len)
    </pre>
  </dd>
  <dt>ibcmp_locale</dt>
  <dd>This is a synonym for
      <span class="Li">&quot;(!&#x00A0;foldEQ_locale())&quot;</span>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     ibcmp_locale(const char* a, const char* b,
                             I32 len)
    </pre>
  </dd>
  <dt>is_safe_syscall</dt>
  <dd>Test that the given <span class="Li">&quot;pv&quot;</span> doesn't contain
      any internal <span class="Li">&quot;NUL&quot;</span> characters. If it
      does, set <span class="Li">&quot;errno&quot;</span> to
      <span class="Li">&quot;ENOENT&quot;</span>, optionally warn, and return
      FALSE.
    <p class="Pp">Return TRUE if the name is safe.</p>
    <p class="Pp">Used by the
        <span class="Li">&quot;IS_SAFE_SYSCALL()&quot;</span> macro.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_safe_syscall(const char *pv, STRLEN len,
                                const char *what,
                                const char *op_name)
    </pre>
  </dd>
  <dt>memEQ</dt>
  <dd>Test two buffers (which may contain embedded
      <span class="Li">&quot;NUL&quot;</span> characters, to see if they are
      equal. The <span class="Li">&quot;len&quot;</span> parameter indicates the
      number of bytes to compare. Returns zero if equal, or non-zero if
      non-equal.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    memEQ(char* s1, char* s2, STRLEN len)
    </pre>
  </dd>
  <dt>memNE</dt>
  <dd>Test two buffers (which may contain embedded
      <span class="Li">&quot;NUL&quot;</span> characters, to see if they are not
      equal. The <span class="Li">&quot;len&quot;</span> parameter indicates the
      number of bytes to compare. Returns zero if non-equal, or non-zero if
      equal.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    memNE(char* s1, char* s2, STRLEN len)
    </pre>
  </dd>
  <dt>mess</dt>
  <dd>Take a sprintf-style format pattern and argument list. These are used to
      generate a string message. If the message does not end with a newline,
      then it will be extended with some indication of the current location in
      the code, as described for &quot;mess_sv&quot;.
    <p class="Pp">Normally, the resulting message is returned in a new mortal
        SV. During global destruction a single SV may be shared between uses of
        this function.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    mess(const char *pat, ...)
    </pre>
  </dd>
  <dt>mess_sv</dt>
  <dd>Expands a message, intended for the user, to include an indication of the
      current location in the code, if the message does not already appear to be
      complete.
    <p class="Pp"><span class="Li">&quot;basemsg&quot;</span> is the initial
        message or object. If it is a reference, it will be used as-is and will
        be the result of this function. Otherwise it is used as a string, and if
        it already ends with a newline, it is taken to be complete, and the
        result of this function will be the same string. If the message does not
        end with a newline, then a segment such as
        <span class="Li">&quot;at</span> <span class="Li">foo.pl line
        37&quot;</span> will be appended, and possibly other clauses indicating
        the current state of execution. The resulting message will end with a
        dot and a newline.</p>
    <p class="Pp">Normally, the resulting message is returned in a new mortal
        SV. During global destruction a single SV may be shared between uses of
        this function. If <span class="Li">&quot;consume&quot;</span> is true,
        then the function is permitted (but not required) to modify and return
        <span class="Li">&quot;basemsg&quot;</span> instead of allocating a new
        SV.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    mess_sv(SV *basemsg, bool consume)
    </pre>
  </dd>
  <dt>my_snprintf</dt>
  <dd>The C library <span class="Li">&quot;snprintf&quot;</span> functionality,
      if available and standards-compliant (uses
      <span class="Li">&quot;vsnprintf&quot;</span>, actually). However, if the
      <span class="Li">&quot;vsnprintf&quot;</span> is not available, will
      unfortunately use the unsafe <span class="Li">&quot;vsprintf&quot;</span>
      which can overrun the buffer (there is an overrun check, but that may be
      too late). Consider using <span class="Li">&quot;sv_vcatpvf&quot;</span>
      instead, or getting <span class="Li">&quot;vsnprintf&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     my_snprintf(char *buffer, const Size_t len,
                            const char *format, ...)
    </pre>
  </dd>
  <dt>my_strlcat</dt>
  <dd>The C library <span class="Li">&quot;strlcat&quot;</span> if available, or
      a Perl implementation of it. This operates on C
      <span class="Li">&quot;NUL&quot;</span>-terminated strings.
    <p class="Pp"><span class="Li">&quot;my_strlcat()&quot;</span> appends
        string <span class="Li">&quot;src&quot;</span> to the end of
        <span class="Li">&quot;dst&quot;</span>. It will append at most
        <span class="Li">&quot;size&#x00A0;-&#x00A0;strlen(dst)&#x00A0;-&#x00A0;1&quot;</span>
        characters. It will then
        <span class="Li">&quot;NUL&quot;</span>-terminate, unless
        <span class="Li">&quot;size&quot;</span> is 0 or the original
        <span class="Li">&quot;dst&quot;</span> string was longer than
        <span class="Li">&quot;size&quot;</span> (in practice this should not
        happen as it means that either <span class="Li">&quot;size&quot;</span>
        is incorrect or that <span class="Li">&quot;dst&quot;</span> is not a
        proper <span class="Li">&quot;NUL&quot;</span>-terminated string).</p>
    <p class="Pp">Note that <span class="Li">&quot;size&quot;</span> is the full
        size of the destination buffer and the result is guaranteed to be
        <span class="Li">&quot;NUL&quot;</span>-terminated if there is room.
        Note that room for the <span class="Li">&quot;NUL&quot;</span> should be
        included in <span class="Li">&quot;size&quot;</span>.</p>
    <p class="Pp">The return value is the total length that
        <span class="Li">&quot;dst&quot;</span> would have if
        <span class="Li">&quot;size&quot;</span> is sufficiently large. Thus it
        is the initial length of <span class="Li">&quot;dst&quot;</span> plus
        the length of <span class="Li">&quot;src&quot;</span>. If
        <span class="Li">&quot;size&quot;</span> is smaller than the return, the
        excess was not appended.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        Size_t  my_strlcat(char *dst, const char *src,
                           Size_t size)
    </pre>
  </dd>
  <dt>my_strlcpy</dt>
  <dd>The C library <span class="Li">&quot;strlcpy&quot;</span> if available, or
      a Perl implementation of it. This operates on C
      <span class="Li">&quot;NUL&quot;</span>-terminated strings.
    <p class="Pp"><span class="Li">&quot;my_strlcpy()&quot;</span> copies up to
        <span class="Li">&quot;size&#x00A0;-&#x00A0;1&quot;</span> characters
        from the string <span class="Li">&quot;src&quot;</span> to
        <span class="Li">&quot;dst&quot;</span>,
        <span class="Li">&quot;NUL&quot;</span>-terminating the result if
        <span class="Li">&quot;size&quot;</span> is not 0.</p>
    <p class="Pp">The return value is the total length
        <span class="Li">&quot;src&quot;</span> would be if the copy completely
        succeeded. If it is larger than
        <span class="Li">&quot;size&quot;</span>, the excess was not copied.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        Size_t  my_strlcpy(char *dst, const char *src,
                           Size_t size)
    </pre>
  </dd>
  <dt>my_strnlen</dt>
  <dd>The C library <span class="Li">&quot;strnlen&quot;</span> if available, or
      a Perl implementation of it.
    <p class="Pp"><span class="Li">&quot;my_strnlen()&quot;</span> computes the
        length of the string, up to <span class="Li">&quot;maxlen&quot;</span>
        characters. It will will never attempt to address more than
        <span class="Li">&quot;maxlen&quot;</span> characters, making it
        suitable for use with strings that are not guaranteed to be
        NUL-terminated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        Size_t  my_strnlen(const char *str, Size_t maxlen)
    </pre>
  </dd>
  <dt>my_vsnprintf</dt>
  <dd>The C library <span class="Li">&quot;vsnprintf&quot;</span> if available
      and standards-compliant. However, if if the
      <span class="Li">&quot;vsnprintf&quot;</span> is not available, will
      unfortunately use the unsafe <span class="Li">&quot;vsprintf&quot;</span>
      which can overrun the buffer (there is an overrun check, but that may be
      too late). Consider using <span class="Li">&quot;sv_vcatpvf&quot;</span>
      instead, or getting <span class="Li">&quot;vsnprintf&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     my_vsnprintf(char *buffer, const Size_t len,
                             const char *format, va_list ap)
    </pre>
  </dd>
  <dt>ninstr</dt>
  <dd>Find the first (leftmost) occurrence of a sequence of bytes within another
      sequence. This is the Perl version of
      <span class="Li">&quot;strstr()&quot;</span>, extended to handle arbitrary
      sequences, potentially containing embedded
      <span class="Li">&quot;NUL&quot;</span> characters
      (<span class="Li">&quot;NUL&quot;</span> is what the initial
      <span class="Li">&quot;n&quot;</span> in the function name stands for;
      some systems have an equivalent,
      <span class="Li">&quot;memmem()&quot;</span>, but with a somewhat
      different API).
    <p class="Pp">Another way of thinking about this function is finding a
        needle in a haystack. <span class="Li">&quot;big&quot;</span> points to
        the first byte in the haystack.
        <span class="Li">&quot;big_end&quot;</span> points to one byte beyond
        the final byte in the haystack.
        <span class="Li">&quot;little&quot;</span> points to the first byte in
        the needle. <span class="Li">&quot;little_end&quot;</span> points to one
        byte beyond the final byte in the needle. All the parameters must be
        non-<span class="Li">&quot;NULL&quot;</span>.</p>
    <p class="Pp">The function returns <span class="Li">&quot;NULL&quot;</span>
        if there is no occurrence of <span class="Li">&quot;little&quot;</span>
        within <span class="Li">&quot;big&quot;</span>. If
        <span class="Li">&quot;little&quot;</span> is the empty string,
        <span class="Li">&quot;big&quot;</span> is returned.</p>
    <p class="Pp">Because this function operates at the byte level, and because
        of the inherent characteristics of UTF-8 (or UTF-EBCDIC), it will work
        properly if both the needle and the haystack are strings with the same
        UTF-8ness, but not if the UTF-8ness differs.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char *  ninstr(char * big, char * bigend, char * little,
                       char * little_end)
    </pre>
  </dd>
  <dt>PERL_SYS_INIT</dt>
  <dd>Provides system-specific tune up of the C runtime environment necessary to
      run Perl interpreters. This should be called only once, before creating
      any Perl interpreters.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PERL_SYS_INIT(int *argc, char*** argv)
    </pre>
  </dd>
  <dt>PERL_SYS_INIT3</dt>
  <dd>Provides system-specific tune up of the C runtime environment necessary to
      run Perl interpreters. This should be called only once, before creating
      any Perl interpreters.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PERL_SYS_INIT3(int *argc, char*** argv,
                               char*** env)
    </pre>
  </dd>
  <dt>PERL_SYS_TERM</dt>
  <dd>Provides system-specific clean up of the C runtime environment after
      running Perl interpreters. This should be called only once, after freeing
      any remaining Perl interpreters.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PERL_SYS_TERM()
    </pre>
  </dd>
  <dt>quadmath_format_needed</dt>
  <dd><span class="Li">&quot;quadmath_format_needed()&quot;</span> returns true
      if the <span class="Li">&quot;format&quot;</span> string seems to contain
      at least one non-Q-prefixed
      <span class="Li">&quot;%[efgaEFGA]&quot;</span> format specifier, or
      returns false otherwise.
    <p class="Pp">The format specifier detection is not complete printf-syntax
        detection, but it should catch most common cases.</p>
    <p class="Pp">If true is returned, those arguments <b>should</b> in theory
        be processed with
        <span class="Li">&quot;quadmath_snprintf()&quot;</span>, but in case
        there is more than one such format specifier (see
        &quot;quadmath_format_single&quot;), and if there is anything else
        beyond that one (even just a single byte), they <b>cannot</b> be
        processed because
        <span class="Li">&quot;quadmath_snprintf()&quot;</span> is very strict,
        accepting only one format spec, and nothing else. In this case, the code
        should probably fail.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    quadmath_format_needed(const char* format)
    </pre>
  </dd>
  <dt>quadmath_format_single</dt>
  <dd><span class="Li">&quot;quadmath_snprintf()&quot;</span> is very strict
      about its <span class="Li">&quot;format&quot;</span> string and will fail,
      returning -1, if the format is invalid. It accepts exactly one format
      spec.
    <p class="Pp"><span class="Li">&quot;quadmath_format_single()&quot;</span>
        checks that the intended single spec looks sane: begins with
        <span class="Li">&quot;%&quot;</span>, has only one
        <span class="Li">&quot;%&quot;</span>, ends with
        <span class="Li">&quot;[efgaEFGA]&quot;</span>, and has
        <span class="Li">&quot;Q&quot;</span> before it. This is not a full
        &quot;printf syntax check&quot;, just the basics.</p>
    <p class="Pp">Returns the format if it is valid, NULL if not.</p>
    <p class="Pp"><span class="Li">&quot;quadmath_format_single()&quot;</span>
        can and will actually patch in the missing
        <span class="Li">&quot;Q&quot;</span>, if necessary. In this case it
        will return the modified copy of the format, <b>which the caller will
        need to free.</b></p>
    <p class="Pp">See also &quot;quadmath_format_needed&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char* quadmath_format_single(const char* format)
    </pre>
  </dd>
  <dt>READ_XDIGIT</dt>
  <dd>Returns the value of an ASCII-range hex digit and advances the string
      pointer. Behaviour is only well defined when isXDIGIT(*str) is true.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8      READ_XDIGIT(char str*)
    </pre>
  </dd>
  <dt>rninstr</dt>
  <dd>Like <span class="Li">&quot;ninstr&quot;</span>, but instead finds the
      final (rightmost) occurrence of a sequence of bytes within another
      sequence, returning <span class="Li">&quot;NULL&quot;</span> if there is
      no such occurrence.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char *  rninstr(char * big, char * bigend,
                        char * little, char * little_end)
    </pre>
  </dd>
  <dt>strEQ</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if they are equal. Returns true or false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strEQ(char* s1, char* s2)
    </pre>
  </dd>
  <dt>strGE</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if the first, <span class="Li">&quot;s1&quot;</span>, is greater than or
      equal to the second, <span class="Li">&quot;s2&quot;</span>. Returns true
      or false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strGE(char* s1, char* s2)
    </pre>
  </dd>
  <dt>strGT</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if the first, <span class="Li">&quot;s1&quot;</span>, is greater than the
      second, <span class="Li">&quot;s2&quot;</span>. Returns true or false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strGT(char* s1, char* s2)
    </pre>
  </dd>
  <dt>strLE</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if the first, <span class="Li">&quot;s1&quot;</span>, is less than or
      equal to the second, <span class="Li">&quot;s2&quot;</span>. Returns true
      or false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strLE(char* s1, char* s2)
    </pre>
  </dd>
  <dt>strLT</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if the first, <span class="Li">&quot;s1&quot;</span>, is less than the
      second, <span class="Li">&quot;s2&quot;</span>. Returns true or false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strLT(char* s1, char* s2)
    </pre>
  </dd>
  <dt>strNE</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if they are different. Returns true or false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strNE(char* s1, char* s2)
    </pre>
  </dd>
  <dt>strnEQ</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if they are equal. The <span class="Li">&quot;len&quot;</span> parameter
      indicates the number of bytes to compare. Returns true or false. (A
      wrapper for <span class="Li">&quot;strncmp&quot;</span>).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strnEQ(char* s1, char* s2, STRLEN len)
    </pre>
  </dd>
  <dt>strnNE</dt>
  <dd>Test two <span class="Li">&quot;NUL&quot;</span>-terminated strings to see
      if they are different. The <span class="Li">&quot;len&quot;</span>
      parameter indicates the number of bytes to compare. Returns true or false.
      (A wrapper for <span class="Li">&quot;strncmp&quot;</span>).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    strnNE(char* s1, char* s2, STRLEN len)
    </pre>
  </dd>
  <dt>sv_destroyable</dt>
  <dd>Dummy routine which reports that object can be destroyed when there is no
      sharing module present. It ignores its single SV argument, and returns
      'true'. Exists to avoid test for a
      <span class="Li">&quot;NULL&quot;</span> function pointer and because it
      could potentially warn under some level of strict-ness.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_destroyable(SV *sv)
    </pre>
  </dd>
  <dt>sv_nosharing</dt>
  <dd>Dummy routine which &quot;shares&quot; an SV when there is no sharing
      module present. Or &quot;locks&quot; it. Or &quot;unlocks&quot; it. In
      other words, ignores its single SV argument. Exists to avoid test for a
      <span class="Li">&quot;NULL&quot;</span> function pointer and because it
      could potentially warn under some level of strict-ness.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_nosharing(SV *sv)
    </pre>
  </dd>
  <dt>vmess</dt>
  <dd><span class="Li">&quot;pat&quot;</span> and
      <span class="Li">&quot;args&quot;</span> are a sprintf-style format
      pattern and encapsulated argument list, respectively. These are used to
      generate a string message. If the message does not end with a newline,
      then it will be extended with some indication of the current location in
      the code, as described for &quot;mess_sv&quot;.
    <p class="Pp">Normally, the resulting message is returned in a new mortal
        SV. During global destruction a single SV may be shared between uses of
        this function.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    vmess(const char *pat, va_list *args)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="MRO_Functions"><a class="permalink" href="#MRO_Functions">MRO
  Functions</a></h1>
These functions are related to the method resolution order of perl classes
<dl class="Bl-tag">
  <dt>mro_get_linear_isa</dt>
  <dd>Returns the mro linearisation for the given stash. By default, this will
      be whatever <span class="Li">&quot;mro_get_linear_isa_dfs&quot;</span>
      returns unless some other MRO is in effect for the stash. The return value
      is a read-only AV*.
    <p class="Pp">You are responsible for
        <span class="Li">&quot;SvREFCNT_inc()&quot;</span> on the return value
        if you plan to store it anywhere semi-permanently (otherwise it might be
        deleted out from under you the next time the cache is invalidated).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        AV*     mro_get_linear_isa(HV* stash)
    </pre>
  </dd>
  <dt>mro_method_changed_in</dt>
  <dd>Invalidates method caching on any child classes of the given stash, so
      that they might notice the changes in this one.
    <p class="Pp">Ideally, all instances of
        <span class="Li">&quot;PL_sub_generation++&quot;</span> in perl source
        outside of <i>mro.c</i> should be replaced by calls to this.</p>
    <p class="Pp">Perl automatically handles most of the common ways a method
        might be redefined. However, there are a few ways you could change a
        method in a stash without the cache code noticing, in which case you
        need to call this method afterwards:</p>
    <p class="Pp">1) Directly manipulating the stash HV entries from XS
      code.</p>
    <p class="Pp">2) Assigning a reference to a readonly scalar constant into a
        stash entry in order to create a constant subroutine (like
        <i>constant.pm</i> does).</p>
    <p class="Pp">This same method is available from pure perl via,
        <span class="Li">&quot;mro::method_changed_in(classname)&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mro_method_changed_in(HV* stash)
    </pre>
  </dd>
  <dt>mro_register</dt>
  <dd>Registers a custom mro plugin. See perlmroapi for details.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mro_register(const struct mro_alg *mro)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Multicall_Functions"><a class="permalink" href="#Multicall_Functions">Multicall
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>dMULTICALL</dt>
  <dd>Declare local variables for a multicall. See &quot;LIGHTWEIGHT
      CALLBACKS&quot; in perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dMULTICALL;
    </pre>
  </dd>
  <dt>MULTICALL</dt>
  <dd>Make a lightweight callback. See &quot;LIGHTWEIGHT CALLBACKS&quot; in
      perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                MULTICALL;
    </pre>
  </dd>
  <dt>POP_MULTICALL</dt>
  <dd>Closing bracket for a lightweight callback. See &quot;LIGHTWEIGHT
      CALLBACKS&quot; in perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                POP_MULTICALL;
    </pre>
  </dd>
  <dt>PUSH_MULTICALL</dt>
  <dd>Opening bracket for a lightweight callback. See &quot;LIGHTWEIGHT
      CALLBACKS&quot; in perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                PUSH_MULTICALL;
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Numeric_functions"><a class="permalink" href="#Numeric_functions">Numeric
  functions</a></h1>
<dl class="Bl-tag">
  <dt>grok_bin</dt>
  <dd>converts a string representing a binary number to numeric form.
    <p class="Pp">On entry <span class="Li">&quot;start&quot;</span> and
        <span class="Li">*len</span> give the string to scan,
        <span class="Li">*flags</span> gives conversion flags, and
        <span class="Li">&quot;result&quot;</span> should be
        <span class="Li">&quot;NULL&quot;</span> or a pointer to an NV. The scan
        stops at the end of the string, or the first invalid character. Unless
        <span class="Li">&quot;PERL_SCAN_SILENT_ILLDIGIT&quot;</span> is set in
        <span class="Li">*flags</span>, encountering an invalid character will
        also trigger a warning. On return <span class="Li">*len</span> is set to
        the length of the scanned string, and <span class="Li">*flags</span>
        gives output flags.</p>
    <p class="Pp">If the value is &lt;=
        <span class="Li">&quot;UV_MAX&quot;</span> it is returned as a UV, the
        output flags are clear, and nothing is written to
        <span class="Li">*result</span>. If the value is &gt;
        <span class="Li">&quot;UV_MAX&quot;</span>,
        <span class="Li">&quot;grok_bin&quot;</span> returns
        <span class="Li">&quot;UV_MAX&quot;</span>, sets
        <span class="Li">&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot;</span> in the
        output flags, and writes the value to <span class="Li">*result</span>
        (or the value is discarded if <span class="Li">&quot;result&quot;</span>
        is NULL).</p>
    <p class="Pp">The binary number may optionally be prefixed with
        <span class="Li">&quot;0b&quot;</span> or
        <span class="Li">&quot;b&quot;</span> unless
        <span class="Li">&quot;PERL_SCAN_DISALLOW_PREFIX&quot;</span> is set in
        <span class="Li">*flags</span> on entry. If
        <span class="Li">&quot;PERL_SCAN_ALLOW_UNDERSCORES&quot;</span> is set
        in <span class="Li">*flags</span> then the binary number may use
        <span class="Li">&quot;_&quot;</span> characters to separate digits.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      grok_bin(const char* start, STRLEN* len_p,
                         I32* flags, NV *result)
    </pre>
  </dd>
  <dt>grok_hex</dt>
  <dd>converts a string representing a hex number to numeric form.
    <p class="Pp">On entry <span class="Li">&quot;start&quot;</span> and
        <span class="Li">*len_p</span> give the string to scan,
        <span class="Li">*flags</span> gives conversion flags, and
        <span class="Li">&quot;result&quot;</span> should be
        <span class="Li">&quot;NULL&quot;</span> or a pointer to an NV. The scan
        stops at the end of the string, or the first invalid character. Unless
        <span class="Li">&quot;PERL_SCAN_SILENT_ILLDIGIT&quot;</span> is set in
        <span class="Li">*flags</span>, encountering an invalid character will
        also trigger a warning. On return <span class="Li">*len</span> is set to
        the length of the scanned string, and <span class="Li">*flags</span>
        gives output flags.</p>
    <p class="Pp">If the value is &lt;=
        <span class="Li">&quot;UV_MAX&quot;</span> it is returned as a UV, the
        output flags are clear, and nothing is written to
        <span class="Li">*result</span>. If the value is &gt;
        <span class="Li">&quot;UV_MAX&quot;</span>,
        <span class="Li">&quot;grok_hex&quot;</span> returns
        <span class="Li">&quot;UV_MAX&quot;</span>, sets
        <span class="Li">&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot;</span> in the
        output flags, and writes the value to <span class="Li">*result</span>
        (or the value is discarded if <span class="Li">&quot;result&quot;</span>
        is <span class="Li">&quot;NULL&quot;</span>).</p>
    <p class="Pp">The hex number may optionally be prefixed with
        <span class="Li">&quot;0x&quot;</span> or
        <span class="Li">&quot;x&quot;</span> unless
        <span class="Li">&quot;PERL_SCAN_DISALLOW_PREFIX&quot;</span> is set in
        <span class="Li">*flags</span> on entry. If
        <span class="Li">&quot;PERL_SCAN_ALLOW_UNDERSCORES&quot;</span> is set
        in <span class="Li">*flags</span> then the hex number may use
        <span class="Li">&quot;_&quot;</span> characters to separate digits.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      grok_hex(const char* start, STRLEN* len_p,
                         I32* flags, NV *result)
    </pre>
  </dd>
  <dt>grok_infnan</dt>
  <dd>Helper for <span class="Li">&quot;grok_number()&quot;</span>, accepts
      various ways of spelling &quot;infinity&quot; or &quot;not a number&quot;,
      and returns one of the following flag combinations:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  IS_NUMBER_INFINITY
  IS_NUMBER_NAN
  IS_NUMBER_INFINITY | IS_NUMBER_NEG
  IS_NUMBER_NAN | IS_NUMBER_NEG
  0
    </pre>
    <p class="Pp">possibly |-ed with
        <span class="Li">&quot;IS_NUMBER_TRAILING&quot;</span>.</p>
    <p class="Pp">If an infinity or a not-a-number is recognized,
        <span class="Li">*sp</span> will point to one byte past the end of the
        recognized string. If the recognition fails, zero is returned, and
        <span class="Li">*sp</span> will not move.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     grok_infnan(const char** sp, const char *send)
    </pre>
  </dd>
  <dt>grok_number</dt>
  <dd>Identical to <span class="Li">&quot;grok_number_flags()&quot;</span> with
      <span class="Li">&quot;flags&quot;</span> set to zero.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     grok_number(const char *pv, STRLEN len,
                            UV *valuep)
    </pre>
  </dd>
  <dt>grok_number_flags</dt>
  <dd>Recognise (or not) a number. The type of the number is returned (0 if
      unrecognised), otherwise it is a bit-ORed combination of
      <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span>,
      <span class="Li">&quot;IS_NUMBER_GREATER_THAN_UV_MAX&quot;</span>,
      <span class="Li">&quot;IS_NUMBER_NOT_INT&quot;</span>,
      <span class="Li">&quot;IS_NUMBER_NEG&quot;</span>,
      <span class="Li">&quot;IS_NUMBER_INFINITY&quot;</span>,
      <span class="Li">&quot;IS_NUMBER_NAN&quot;</span> (defined in perl.h).
    <p class="Pp">If the value of the number can fit in a UV, it is returned in
        <span class="Li">*valuep</span>.
        <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span> will be set to
        indicate that <span class="Li">*valuep</span> is valid,
        <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span> will never be set
        unless <span class="Li">*valuep</span> is valid, but
        <span class="Li">*valuep</span> may have been assigned to during
        processing even though
        <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span> is not set on
        return. If <span class="Li">&quot;valuep&quot;</span> is
        <span class="Li">&quot;NULL&quot;</span>,
        <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span> will be set for the
        same cases as when <span class="Li">&quot;valuep&quot;</span> is
        non-<span class="Li">&quot;NULL&quot;</span>, but no actual assignment
        (or SEGV) will occur.</p>
    <p class="Pp"><span class="Li">&quot;IS_NUMBER_NOT_INT&quot;</span> will be
        set with <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span> if trailing
        decimals were seen (in which case <span class="Li">*valuep</span> gives
        the true value truncated to an integer), and
        <span class="Li">&quot;IS_NUMBER_NEG&quot;</span> if the number is
        negative (in which case <span class="Li">*valuep</span> holds the
        absolute value). <span class="Li">&quot;IS_NUMBER_IN_UV&quot;</span> is
        not set if e notation was used or the number is larger than a UV.</p>
    <p class="Pp"><span class="Li">&quot;flags&quot;</span> allows only
        <span class="Li">&quot;PERL_SCAN_TRAILING&quot;</span>, which allows for
        trailing non-numeric text on an otherwise successful <i>grok</i>,
        setting <span class="Li">&quot;IS_NUMBER_TRAILING&quot;</span> on the
        result.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     grok_number_flags(const char *pv, STRLEN len,
                                  UV *valuep, U32 flags)
    </pre>
  </dd>
  <dt>grok_numeric_radix</dt>
  <dd>Scan and skip for a numeric decimal separator (radix).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    grok_numeric_radix(const char **sp,
                                   const char *send)
    </pre>
  </dd>
  <dt>grok_oct</dt>
  <dd>converts a string representing an octal number to numeric form.
    <p class="Pp">On entry <span class="Li">&quot;start&quot;</span> and
        <span class="Li">*len</span> give the string to scan,
        <span class="Li">*flags</span> gives conversion flags, and
        <span class="Li">&quot;result&quot;</span> should be
        <span class="Li">&quot;NULL&quot;</span> or a pointer to an NV. The scan
        stops at the end of the string, or the first invalid character. Unless
        <span class="Li">&quot;PERL_SCAN_SILENT_ILLDIGIT&quot;</span> is set in
        <span class="Li">*flags</span>, encountering an 8 or 9 will also trigger
        a warning. On return <span class="Li">*len</span> is set to the length
        of the scanned string, and <span class="Li">*flags</span> gives output
        flags.</p>
    <p class="Pp">If the value is &lt;=
        <span class="Li">&quot;UV_MAX&quot;</span> it is returned as a UV, the
        output flags are clear, and nothing is written to
        <span class="Li">*result</span>. If the value is &gt;
        <span class="Li">&quot;UV_MAX&quot;</span>,
        <span class="Li">&quot;grok_oct&quot;</span> returns
        <span class="Li">&quot;UV_MAX&quot;</span>, sets
        <span class="Li">&quot;PERL_SCAN_GREATER_THAN_UV_MAX&quot;</span> in the
        output flags, and writes the value to <span class="Li">*result</span>
        (or the value is discarded if <span class="Li">&quot;result&quot;</span>
        is <span class="Li">&quot;NULL&quot;</span>).</p>
    <p class="Pp">If
        <span class="Li">&quot;PERL_SCAN_ALLOW_UNDERSCORES&quot;</span> is set
        in <span class="Li">*flags</span> then the octal number may use
        <span class="Li">&quot;_&quot;</span> characters to separate digits.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      grok_oct(const char* start, STRLEN* len_p,
                         I32* flags, NV *result)
    </pre>
  </dd>
  <dt>isinfnan</dt>
  <dd><span class="Li">&quot;Perl_isinfnan()&quot;</span> is utility function
      that returns true if the NV argument is either an infinity or a
      <span class="Li">&quot;NaN&quot;</span>, false otherwise. To test in more
      detail, use <span class="Li">&quot;Perl_isinf()&quot;</span> and
      <span class="Li">&quot;Perl_isnan()&quot;</span>.
    <p class="Pp">This is also the logical inverse of
      <b>Perl_isfinite()</b>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    isinfnan(NV nv)
    </pre>
  </dd>
  <dt>my_strtod</dt>
  <dd>This function is equivalent to the libc <b>strtod()</b> function, and is
      available even on platforms that lack plain <b>strtod()</b>. Its return
      value is the best available precision depending on platform capabilities
      and <i>Configure</i> options.
    <p class="Pp">It properly handles the locale radix character, meaning it
        expects a dot except when called from within the scope of
        <span class="Li">&quot;use&#x00A0;locale&quot;</span>, in which case the
        radix character should be that specified by the current locale.</p>
    <p class="Pp">The synonym <b>Strod()</b> may be used instead.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      my_strtod(const char * const s, char ** e)
    </pre>
  </dd>
  <dt>Perl_signbit</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Return a non-zero integer if the sign bit on an NV is set, and
        0 if it is not.</p>
    <p class="Pp">If <i>Configure</i> detects this system has a
        <span class="Li">&quot;signbit()&quot;</span> that will work with our
        NVs, then we just use it via the
        <span class="Li">&quot;#define&quot;</span> in <i>perl.h</i>. Otherwise,
        fall back on this implementation. The main use of this function is
        catching <span class="Li">&quot;-0.0&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;Configure&quot;</span> notes: This
        function is called <span class="Li">'Perl_signbit'</span> instead of a
        plain <span class="Li">'signbit'</span> because it is easy to imagine a
        system having a <span class="Li">&quot;signbit()&quot;</span> function
        or macro that doesn't happen to work with our particular choice of NVs.
        We shouldn't just re-<span class="Li">&quot;#define&quot;</span>
        <span class="Li">&quot;signbit&quot;</span> as
        <span class="Li">&quot;Perl_signbit&quot;</span> and expect the standard
        system headers to be happy. Also, this is a no-context function (no
        <span class="Li">&quot;pTHX_&quot;</span>) because
        <span class="Li">&quot;Perl_signbit()&quot;</span> is usually
        re-<span class="Li">&quot;#defined&quot;</span> in <i>perl.h</i> as a
        simple macro call to the system's
        <span class="Li">&quot;signbit()&quot;</span>. Users should just always
        call <span class="Li">&quot;Perl_signbit()&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     Perl_signbit(NV f)
    </pre>
  </dd>
  <dt>scan_bin</dt>
  <dd>For backwards compatibility. Use
      <span class="Li">&quot;grok_bin&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      scan_bin(const char* start, STRLEN len,
                         STRLEN* retlen)
    </pre>
  </dd>
  <dt>scan_hex</dt>
  <dd>For backwards compatibility. Use
      <span class="Li">&quot;grok_hex&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      scan_hex(const char* start, STRLEN len,
                         STRLEN* retlen)
    </pre>
  </dd>
  <dt>scan_oct</dt>
  <dd>For backwards compatibility. Use
      <span class="Li">&quot;grok_oct&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      scan_oct(const char* start, STRLEN len,
                         STRLEN* retlen)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Obsolete_backwards_compatibility_functions"><a class="permalink" href="#Obsolete_backwards_compatibility_functions">Obsolete
  backwards compatibility functions</a></h1>
Some of these are also deprecated. You can exclude these from your compiled Perl
  by adding this option to Configure:
  <span class="Li">&quot;-Accflags='-DNO_MATHOMS'&quot;</span>
<dl class="Bl-tag">
  <dt>custom_op_desc</dt>
  <dd>Return the description of a given custom op. This was once used by the
      <span class="Li">&quot;OP_DESC&quot;</span> macro, but is no longer: it
      has only been kept for compatibility, and should not be used.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char * custom_op_desc(const OP *o)
    </pre>
  </dd>
  <dt>custom_op_name</dt>
  <dd>Return the name for a given custom op. This was once used by the
      <span class="Li">&quot;OP_NAME&quot;</span> macro, but is no longer: it
      has only been kept for compatibility, and should not be used.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char * custom_op_name(const OP *o)
    </pre>
  </dd>
  <dt>gv_fetchmethod</dt>
  <dd>See &quot;gv_fetchmethod_autoload&quot;.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     gv_fetchmethod(HV* stash, const char* name)
    </pre>
  </dd>
  <dt>is_utf8_char</dt>
  <dd>DEPRECATED! It is planned to remove this function from a future release of
      Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Tests if some arbitrary number of bytes begins in a valid
        UTF-8 character. Note that an INVARIANT (i.e. ASCII on non-EBCDIC
        machines) character is a valid UTF-8 character. The actual number of
        bytes in the UTF-8 character will be returned if it is valid, otherwise
        0.</p>
    <p class="Pp">This function is deprecated due to the possibility that
        malformed input could cause reading beyond the end of the input buffer.
        Use &quot;isUTF8_CHAR&quot; instead.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  is_utf8_char(const U8 *s)
    </pre>
  </dd>
  <dt>is_utf8_char_buf</dt>
  <dd>This is identical to the macro &quot;isUTF8_CHAR&quot;.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  is_utf8_char_buf(const U8 *buf,
                                 const U8 *buf_end)
    </pre>
  </dd>
  <dt>pack_cat</dt>
  <dd>The engine implementing <span class="Li">&quot;pack()&quot;</span> Perl
      function. Note: parameters
      <span class="Li">&quot;next_in_list&quot;</span> and
      <span class="Li">&quot;flags&quot;</span> are not used. This call should
      not be used; use <span class="Li">&quot;packlist&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pack_cat(SV *cat, const char *pat,
                         const char *patend, SV **beglist,
                         SV **endlist, SV ***next_in_list,
                         U32 flags)
    </pre>
  </dd>
  <dt>pad_compname_type</dt>
  <dd>Looks up the type of the lexical variable at position
      <span class="Li">&quot;po&quot;</span> in the currently-compiling pad. If
      the variable is typed, the stash of the class to which it is typed is
      returned. If not, <span class="Li">&quot;NULL&quot;</span> is returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    pad_compname_type(PADOFFSET po)
    </pre>
  </dd>
  <dt>sv_2pvbyte_nolen</dt>
  <dd>Return a pointer to the byte-encoded representation of the SV. May cause
      the SV to be downgraded from UTF-8 as a side-effect.
    <p class="Pp">Usually accessed via the
        <span class="Li">&quot;SvPVbyte_nolen&quot;</span> macro.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_2pvbyte_nolen(SV* sv)
    </pre>
  </dd>
  <dt>sv_2pvutf8_nolen</dt>
  <dd>Return a pointer to the UTF-8-encoded representation of the SV. May cause
      the SV to be upgraded to UTF-8 as a side-effect.
    <p class="Pp">Usually accessed via the
        <span class="Li">&quot;SvPVutf8_nolen&quot;</span> macro.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_2pvutf8_nolen(SV* sv)
    </pre>
  </dd>
  <dt>sv_2pv_nolen</dt>
  <dd>Like <span class="Li">&quot;sv_2pv()&quot;</span>, but doesn't return the
      length too. You should usually use the macro wrapper
      <span class="Li">&quot;SvPV_nolen(sv)&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_2pv_nolen(SV* sv)
    </pre>
  </dd>
  <dt>sv_catpvn_mg</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvn_mg(SV *sv, const char *ptr,
                             STRLEN len)
    </pre>
  </dd>
  <dt>sv_catsv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_catsv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catsv_mg(SV *dsv, SV *ssv)
    </pre>
  </dd>
  <dt>sv_force_normal</dt>
  <dd>Undo various types of fakery on an SV: if the PV is a shared string, make
      a private copy; if we're a ref, stop refing; if we're a glob, downgrade to
      an <span class="Li">&quot;xpvmg&quot;</span>. See also
      <span class="Li">&quot;sv_force_normal_flags&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_force_normal(SV *sv)
    </pre>
  </dd>
  <dt>sv_iv</dt>
  <dd>A private implementation of the <span class="Li">&quot;SvIVx&quot;</span>
      macro for compilers which can't cope with complex macro expressions.
      Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      sv_iv(SV* sv)
    </pre>
  </dd>
  <dt>sv_nolocking</dt>
  <dd>Dummy routine which &quot;locks&quot; an SV when there is no locking
      module present. Exists to avoid test for a
      <span class="Li">&quot;NULL&quot;</span> function pointer and because it
      could potentially warn under some level of strict-ness.
    <p class="Pp">&quot;Superseded&quot; by
        <span class="Li">&quot;sv_nosharing()&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_nolocking(SV *sv)
    </pre>
  </dd>
  <dt>sv_nounlocking</dt>
  <dd>Dummy routine which &quot;unlocks&quot; an SV when there is no locking
      module present. Exists to avoid test for a
      <span class="Li">&quot;NULL&quot;</span> function pointer and because it
      could potentially warn under some level of strict-ness.
    <p class="Pp">&quot;Superseded&quot; by
        <span class="Li">&quot;sv_nosharing()&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_nounlocking(SV *sv)
    </pre>
  </dd>
  <dt>sv_nv</dt>
  <dd>A private implementation of the <span class="Li">&quot;SvNVx&quot;</span>
      macro for compilers which can't cope with complex macro expressions.
      Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      sv_nv(SV* sv)
    </pre>
  </dd>
  <dt>sv_pv</dt>
  <dd>Use the <span class="Li">&quot;SvPV_nolen&quot;</span> macro instead
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pv(SV *sv)
    </pre>
  </dd>
  <dt>sv_pvbyte</dt>
  <dd>Use <span class="Li">&quot;SvPVbyte_nolen&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvbyte(SV *sv)
    </pre>
  </dd>
  <dt>sv_pvbyten</dt>
  <dd>A private implementation of the
      <span class="Li">&quot;SvPVbyte&quot;</span> macro for compilers which
      can't cope with complex macro expressions. Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvbyten(SV *sv, STRLEN *lp)
    </pre>
  </dd>
  <dt>sv_pvn</dt>
  <dd>A private implementation of the <span class="Li">&quot;SvPV&quot;</span>
      macro for compilers which can't cope with complex macro expressions.
      Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvn(SV *sv, STRLEN *lp)
    </pre>
  </dd>
  <dt>sv_pvutf8</dt>
  <dd>Use the <span class="Li">&quot;SvPVutf8_nolen&quot;</span> macro instead
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvutf8(SV *sv)
    </pre>
  </dd>
  <dt>sv_pvutf8n</dt>
  <dd>A private implementation of the
      <span class="Li">&quot;SvPVutf8&quot;</span> macro for compilers which
      can't cope with complex macro expressions. Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvutf8n(SV *sv, STRLEN *lp)
    </pre>
  </dd>
  <dt>sv_taint</dt>
  <dd>Taint an SV. Use <span class="Li">&quot;SvTAINTED_on&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_taint(SV* sv)
    </pre>
  </dd>
  <dt>sv_unref</dt>
  <dd>Unsets the RV status of the SV, and decrements the reference count of
      whatever was being referenced by the RV. This can almost be thought of as
      a reversal of <span class="Li">&quot;newSVrv&quot;</span>. This is
      <span class="Li">&quot;sv_unref_flags&quot;</span> with the
      <span class="Li">&quot;flag&quot;</span> being zero. See
      <span class="Li">&quot;SvROK_off&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_unref(SV* sv)
    </pre>
  </dd>
  <dt>sv_usepvn</dt>
  <dd>Tells an SV to use <span class="Li">&quot;ptr&quot;</span> to find its
      string value. Implemented by calling
      <span class="Li">&quot;sv_usepvn_flags&quot;</span> with
      <span class="Li">&quot;flags&quot;</span> of 0, hence does not handle
      'set' magic. See <span class="Li">&quot;sv_usepvn_flags&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_usepvn(SV* sv, char* ptr, STRLEN len)
    </pre>
  </dd>
  <dt>sv_usepvn_mg</dt>
  <dd>Like <span class="Li">&quot;sv_usepvn&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_usepvn_mg(SV *sv, char *ptr, STRLEN len)
    </pre>
  </dd>
  <dt>sv_uv</dt>
  <dd>A private implementation of the <span class="Li">&quot;SvUVx&quot;</span>
      macro for compilers which can't cope with complex macro expressions.
      Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      sv_uv(SV* sv)
    </pre>
  </dd>
  <dt>unpack_str</dt>
  <dd>The engine implementing <span class="Li">&quot;unpack()&quot;</span> Perl
      function. Note: parameters <span class="Li">&quot;strbeg&quot;</span>,
      <span class="Li">&quot;new_s&quot;</span> and
      <span class="Li">&quot;ocnt&quot;</span> are not used. This call should
      not be used, use <span class="Li">&quot;unpackstring&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t unpack_str(const char *pat, const char *patend,
                           const char *s, const char *strbeg,
                           const char *strend, char **new_s,
                           I32 ocnt, U32 flags)
    </pre>
  </dd>
  <dt>utf8_to_uvuni</dt>
  <dd>DEPRECATED! It is planned to remove this function from a future release of
      Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Returns the Unicode code point of the first character in the
        string <span class="Li">&quot;s&quot;</span> which is assumed to be in
        UTF-8 encoding; <span class="Li">&quot;retlen&quot;</span> will be set
        to the length, in bytes, of that character.</p>
    <p class="Pp">Some, but not all, UTF-8 malformations are detected, and in
        fact, some malformed input could cause reading beyond the end of the
        input buffer, which is one reason why this function is deprecated. The
        other is that only in extremely limited circumstances should the Unicode
        versus native code point be of any interest to you. See
        &quot;utf8_to_uvuni_buf&quot; for alternatives.</p>
    <p class="Pp">If <span class="Li">&quot;s&quot;</span> points to one of the
        detected malformations, and UTF8 warnings are enabled, zero is returned
        and <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> doesn't point to NULL) to -1.
        If those warnings are off, the computed value if well-defined (or the
        Unicode REPLACEMENT CHARACTER, if not) is silently returned, and
        <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. See
        &quot;utf8n_to_uvchr&quot; for details on when the REPLACEMENT CHARACTER
        is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      utf8_to_uvuni(const U8 *s, STRLEN *retlen)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Optree_construction"><a class="permalink" href="#Optree_construction">Optree
  construction</a></h1>
<dl class="Bl-tag">
  <dt>newASSIGNOP</dt>
  <dd>Constructs, checks, and returns an assignment op.
      <span class="Li">&quot;left&quot;</span> and
      <span class="Li">&quot;right&quot;</span> supply the parameters of the
      assignment; they are consumed by this function and become part of the
      constructed op tree.
    <p class="Pp">If <span class="Li">&quot;optype&quot;</span> is
        <span class="Li">&quot;OP_ANDASSIGN&quot;</span>,
        <span class="Li">&quot;OP_ORASSIGN&quot;</span>, or
        <span class="Li">&quot;OP_DORASSIGN&quot;</span>, then a suitable
        conditional optree is constructed. If
        <span class="Li">&quot;optype&quot;</span> is the opcode of a binary
        operator, such as <span class="Li">&quot;OP_BIT_OR&quot;</span>, then an
        op is constructed that performs the binary operation and assigns the
        result to the left argument. Either way, if
        <span class="Li">&quot;optype&quot;</span> is non-zero then
        <span class="Li">&quot;flags&quot;</span> has no effect.</p>
    <p class="Pp">If <span class="Li">&quot;optype&quot;</span> is zero, then a
        plain scalar or list assignment is constructed. Which type of assignment
        it is is automatically determined.
        <span class="Li">&quot;flags&quot;</span> gives the eight bits of
        <span class="Li">&quot;op_flags&quot;</span>, except that
        <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
        and, shifted up eight bits, the eight bits of
        <span class="Li">&quot;op_private&quot;</span>, except that the bit with
        value 1 or 2 is automatically set as required.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newASSIGNOP(I32 flags, OP *left, I32 optype,
                            OP *right)
    </pre>
  </dd>
  <dt>newBINOP</dt>
  <dd>Constructs, checks, and returns an op of any binary type.
      <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 or 2 is automatically set as required.
      <span class="Li">&quot;first&quot;</span> and
      <span class="Li">&quot;last&quot;</span> supply up to two ops to be the
      direct children of the binary op; they are consumed by this function and
      become part of the constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newBINOP(I32 type, I32 flags, OP *first,
                         OP *last)
    </pre>
  </dd>
  <dt>newCONDOP</dt>
  <dd>Constructs, checks, and returns a conditional-expression
      (<span class="Li">&quot;cond_expr&quot;</span>) op.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 is automatically set. <span class="Li">&quot;first&quot;</span>
      supplies the expression selecting between the two branches, and
      <span class="Li">&quot;trueop&quot;</span> and
      <span class="Li">&quot;falseop&quot;</span> supply the branches; they are
      consumed by this function and become part of the constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newCONDOP(I32 flags, OP *first, OP *trueop,
                          OP *falseop)
    </pre>
  </dd>
  <dt>newDEFSVOP</dt>
  <dd>Constructs and returns an op to access <span class="Li">$_</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newDEFSVOP()
    </pre>
  </dd>
  <dt>newFOROP</dt>
  <dd>Constructs, checks, and returns an op tree expressing a
      <span class="Li">&quot;foreach&quot;</span> loop (iteration through a list
      of values). This is a heavyweight loop, with structure that allows exiting
      the loop by <span class="Li">&quot;last&quot;</span> and suchlike.
    <p class="Pp"><span class="Li">&quot;sv&quot;</span> optionally supplies the
        variable that will be aliased to each item in turn; if null, it defaults
        to <span class="Li">$_</span>. <span class="Li">&quot;expr&quot;</span>
        supplies the list of values to iterate over.
        <span class="Li">&quot;block&quot;</span> supplies the main body of the
        loop, and <span class="Li">&quot;cont&quot;</span> optionally supplies a
        <span class="Li">&quot;continue&quot;</span> block that operates as a
        second half of the body. All of these optree inputs are consumed by this
        function and become part of the constructed op tree.</p>
    <p class="Pp"><span class="Li">&quot;flags&quot;</span> gives the eight bits
        of <span class="Li">&quot;op_flags&quot;</span> for the
        <span class="Li">&quot;leaveloop&quot;</span> op and, shifted up eight
        bits, the eight bits of <span class="Li">&quot;op_private&quot;</span>
        for the <span class="Li">&quot;leaveloop&quot;</span> op, except that
        (in both cases) some bits will be set automatically.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newFOROP(I32 flags, OP *sv, OP *expr, OP *block,
                         OP *cont)
    </pre>
  </dd>
  <dt>newGIVENOP</dt>
  <dd>Constructs, checks, and returns an op tree expressing a
      <span class="Li">&quot;given&quot;</span> block.
      <span class="Li">&quot;cond&quot;</span> supplies the expression to whose
      value <span class="Li">$_</span> will be locally aliased, and
      <span class="Li">&quot;block&quot;</span> supplies the body of the
      <span class="Li">&quot;given&quot;</span> construct; they are consumed by
      this function and become part of the constructed op tree.
      <span class="Li">&quot;defsv_off&quot;</span> must be zero (it used to
      identity the pad slot of lexical <span class="Li">$_</span>).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newGIVENOP(OP *cond, OP *block,
                           PADOFFSET defsv_off)
    </pre>
  </dd>
  <dt>newGVOP</dt>
  <dd>Constructs, checks, and returns an op of any type that involves an
      embedded reference to a GV. <span class="Li">&quot;type&quot;</span> is
      the opcode. <span class="Li">&quot;flags&quot;</span> gives the eight bits
      of <span class="Li">&quot;op_flags&quot;</span>.
      <span class="Li">&quot;gv&quot;</span> identifies the GV that the op
      should reference; calling this function does not transfer ownership of any
      reference to it.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newGVOP(I32 type, I32 flags, GV *gv)
    </pre>
  </dd>
  <dt>newLISTOP</dt>
  <dd>Constructs, checks, and returns an op of any list type.
      <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically if
      required. <span class="Li">&quot;first&quot;</span> and
      <span class="Li">&quot;last&quot;</span> supply up to two ops to be direct
      children of the list op; they are consumed by this function and become
      part of the constructed op tree.
    <p class="Pp">For most list operators, the check function expects all the
        kid ops to be present already, so calling
        <span class="Li">&quot;newLISTOP(OP_JOIN, ...)&quot;</span> (e.g.) is
        not appropriate. What you want to do in that case is create an op of
        type <span class="Li">&quot;OP_LIST&quot;</span>, append more children
        to it, and then call &quot;op_convert_list&quot;. See
        &quot;op_convert_list&quot; for more information.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newLISTOP(I32 type, I32 flags, OP *first,
                          OP *last)
    </pre>
  </dd>
  <dt>newLOGOP</dt>
  <dd>Constructs, checks, and returns a logical (flow control) op.
      <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 is automatically set. <span class="Li">&quot;first&quot;</span>
      supplies the expression controlling the flow, and
      <span class="Li">&quot;other&quot;</span> supplies the side (alternate)
      chain of ops; they are consumed by this function and become part of the
      constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newLOGOP(I32 type, I32 flags, OP *first,
                         OP *other)
    </pre>
  </dd>
  <dt>newLOOPEX</dt>
  <dd>Constructs, checks, and returns a loop-exiting op (such as
      <span class="Li">&quot;goto&quot;</span> or
      <span class="Li">&quot;last&quot;</span>).
      <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;label&quot;</span> supplies the parameter
      determining the target of the op; it is consumed by this function and
      becomes part of the constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newLOOPEX(I32 type, OP *label)
    </pre>
  </dd>
  <dt>newLOOPOP</dt>
  <dd>Constructs, checks, and returns an op tree expressing a loop. This is only
      a loop in the control flow through the op tree; it does not have the
      heavyweight loop structure that allows exiting the loop by
      <span class="Li">&quot;last&quot;</span> and suchlike.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span> for the top-level op, except
      that some bits will be set automatically as required.
      <span class="Li">&quot;expr&quot;</span> supplies the expression
      controlling loop iteration, and <span class="Li">&quot;block&quot;</span>
      supplies the body of the loop; they are consumed by this function and
      become part of the constructed op tree.
      <span class="Li">&quot;debuggable&quot;</span> is currently unused and
      should always be 1.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newLOOPOP(I32 flags, I32 debuggable, OP *expr,
                          OP *block)
    </pre>
  </dd>
  <dt>newMETHOP</dt>
  <dd>Constructs, checks, and returns an op of method type with a method name
      evaluated at runtime. <span class="Li">&quot;type&quot;</span> is the
      opcode. <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 is automatically set.
      <span class="Li">&quot;dynamic_meth&quot;</span> supplies an op which
      evaluates method name; it is consumed by this function and become part of
      the constructed op tree. Supported optypes:
      <span class="Li">&quot;OP_METHOD&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newMETHOP(I32 type, I32 flags, OP *first)
    </pre>
  </dd>
  <dt>newMETHOP_named</dt>
  <dd>Constructs, checks, and returns an op of method type with a constant
      method name. <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, and, shifted up eight bits,
      the eight bits of <span class="Li">&quot;op_private&quot;</span>.
      <span class="Li">&quot;const_meth&quot;</span> supplies a constant method
      name; it must be a shared COW string. Supported optypes:
      <span class="Li">&quot;OP_METHOD_NAMED&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newMETHOP_named(I32 type, I32 flags,
                                SV *const_meth)
    </pre>
  </dd>
  <dt>newNULLLIST</dt>
  <dd>Constructs, checks, and returns a new
      <span class="Li">&quot;stub&quot;</span> op, which represents an empty
      list expression.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newNULLLIST()
    </pre>
  </dd>
  <dt>newOP</dt>
  <dd>Constructs, checks, and returns an op of any base type (any type that has
      no extra fields). <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, and, shifted up eight bits,
      the eight bits of <span class="Li">&quot;op_private&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newOP(I32 type, I32 flags)
    </pre>
  </dd>
  <dt>newPADOP</dt>
  <dd>Constructs, checks, and returns an op of any type that involves a
      reference to a pad element. <span class="Li">&quot;type&quot;</span> is
      the opcode. <span class="Li">&quot;flags&quot;</span> gives the eight bits
      of <span class="Li">&quot;op_flags&quot;</span>. A pad slot is
      automatically allocated, and is populated with
      <span class="Li">&quot;sv&quot;</span>; this function takes ownership of
      one reference to it.
    <p class="Pp">This function only exists if Perl has been compiled to use
        ithreads.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newPADOP(I32 type, I32 flags, SV *sv)
    </pre>
  </dd>
  <dt>newPMOP</dt>
  <dd>Constructs, checks, and returns an op of any pattern matching type.
      <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span> and, shifted up eight bits,
      the eight bits of <span class="Li">&quot;op_private&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newPMOP(I32 type, I32 flags)
    </pre>
  </dd>
  <dt>newPVOP</dt>
  <dd>Constructs, checks, and returns an op of any type that involves an
      embedded C-level pointer (PV). <span class="Li">&quot;type&quot;</span> is
      the opcode. <span class="Li">&quot;flags&quot;</span> gives the eight bits
      of <span class="Li">&quot;op_flags&quot;</span>.
      <span class="Li">&quot;pv&quot;</span> supplies the C-level pointer.
      Depending on the op type, the memory referenced by
      <span class="Li">&quot;pv&quot;</span> may be freed when the op is
      destroyed. If the op is of a freeing type,
      <span class="Li">&quot;pv&quot;</span> must have been allocated using
      <span class="Li">&quot;PerlMemShared_malloc&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newPVOP(I32 type, I32 flags, char *pv)
    </pre>
  </dd>
  <dt>newRANGE</dt>
  <dd>Constructs and returns a <span class="Li">&quot;range&quot;</span> op,
      with subordinate <span class="Li">&quot;flip&quot;</span> and
      <span class="Li">&quot;flop&quot;</span> ops.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span> for the
      <span class="Li">&quot;flip&quot;</span> op and, shifted up eight bits,
      the eight bits of <span class="Li">&quot;op_private&quot;</span> for both
      the <span class="Li">&quot;flip&quot;</span> and
      <span class="Li">&quot;range&quot;</span> ops, except that the bit with
      value 1 is automatically set. <span class="Li">&quot;left&quot;</span> and
      <span class="Li">&quot;right&quot;</span> supply the expressions
      controlling the endpoints of the range; they are consumed by this function
      and become part of the constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newRANGE(I32 flags, OP *left, OP *right)
    </pre>
  </dd>
  <dt>newSLICEOP</dt>
  <dd>Constructs, checks, and returns an
      <span class="Li">&quot;lslice&quot;</span> (list slice) op.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically,
      and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 or 2 is automatically set as required.
      <span class="Li">&quot;listval&quot;</span> and
      <span class="Li">&quot;subscript&quot;</span> supply the parameters of the
      slice; they are consumed by this function and become part of the
      constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newSLICEOP(I32 flags, OP *subscript,
                           OP *listval)
    </pre>
  </dd>
  <dt>newSTATEOP</dt>
  <dd>Constructs a state op (COP). The state op is normally a
      <span class="Li">&quot;nextstate&quot;</span> op, but will be a
      <span class="Li">&quot;dbstate&quot;</span> op if debugging is enabled for
      currently-compiled code. The state op is populated from
      <span class="Li">&quot;PL_curcop&quot;</span> (or
      <span class="Li">&quot;PL_compiling&quot;</span>). If
      <span class="Li">&quot;label&quot;</span> is non-null, it supplies the
      name of a label to attach to the state op; this function takes ownership
      of the memory pointed at by <span class="Li">&quot;label&quot;</span>, and
      will free it. <span class="Li">&quot;flags&quot;</span> gives the eight
      bits of <span class="Li">&quot;op_flags&quot;</span> for the state op.
    <p class="Pp">If <span class="Li">&quot;o&quot;</span> is null, the state op
        is returned. Otherwise the state op is combined with
        <span class="Li">&quot;o&quot;</span> into a
        <span class="Li">&quot;lineseq&quot;</span> list op, which is returned.
        <span class="Li">&quot;o&quot;</span> is consumed by this function and
        becomes part of the returned op tree.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newSTATEOP(I32 flags, char *label, OP *o)
    </pre>
  </dd>
  <dt>newSVOP</dt>
  <dd>Constructs, checks, and returns an op of any type that involves an
      embedded SV. <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>.
      <span class="Li">&quot;sv&quot;</span> gives the SV to embed in the op;
      this function takes ownership of one reference to it.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newSVOP(I32 type, I32 flags, SV *sv)
    </pre>
  </dd>
  <dt>newUNOP</dt>
  <dd>Constructs, checks, and returns an op of any unary type.
      <span class="Li">&quot;type&quot;</span> is the opcode.
      <span class="Li">&quot;flags&quot;</span> gives the eight bits of
      <span class="Li">&quot;op_flags&quot;</span>, except that
      <span class="Li">&quot;OPf_KIDS&quot;</span> will be set automatically if
      required, and, shifted up eight bits, the eight bits of
      <span class="Li">&quot;op_private&quot;</span>, except that the bit with
      value 1 is automatically set. <span class="Li">&quot;first&quot;</span>
      supplies an optional op to be the direct child of the unary op; it is
      consumed by this function and become part of the constructed op tree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newUNOP(I32 type, I32 flags, OP *first)
    </pre>
  </dd>
  <dt>newUNOP_AUX</dt>
  <dd>Similar to <span class="Li">&quot;newUNOP&quot;</span>, but creates an
      <span class="Li">&quot;UNOP_AUX&quot;</span> struct instead, with
      <span class="Li">&quot;op_aux&quot;</span> initialised to
      <span class="Li">&quot;aux&quot;</span>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP*     newUNOP_AUX(I32 type, I32 flags, OP* first,
                            UNOP_AUX_item *aux)
    </pre>
  </dd>
  <dt>newWHENOP</dt>
  <dd>Constructs, checks, and returns an op tree expressing a
      <span class="Li">&quot;when&quot;</span> block.
      <span class="Li">&quot;cond&quot;</span> supplies the test expression, and
      <span class="Li">&quot;block&quot;</span> supplies the block that will be
      executed if the test evaluates to true; they are consumed by this function
      and become part of the constructed op tree.
      <span class="Li">&quot;cond&quot;</span> will be interpreted DWIMically,
      often as a comparison against <span class="Li">$_</span>, and may be null
      to generate a <span class="Li">&quot;default&quot;</span> block.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newWHENOP(OP *cond, OP *block)
    </pre>
  </dd>
  <dt>newWHILEOP</dt>
  <dd>Constructs, checks, and returns an op tree expressing a
      <span class="Li">&quot;while&quot;</span> loop. This is a heavyweight
      loop, with structure that allows exiting the loop by
      <span class="Li">&quot;last&quot;</span> and suchlike.
    <p class="Pp"><span class="Li">&quot;loop&quot;</span> is an optional
        preconstructed <span class="Li">&quot;enterloop&quot;</span> op to use
        in the loop; if it is null then a suitable op will be constructed
        automatically. <span class="Li">&quot;expr&quot;</span> supplies the
        loop's controlling expression. <span class="Li">&quot;block&quot;</span>
        supplies the main body of the loop, and
        <span class="Li">&quot;cont&quot;</span> optionally supplies a
        <span class="Li">&quot;continue&quot;</span> block that operates as a
        second half of the body. All of these optree inputs are consumed by this
        function and become part of the constructed op tree.</p>
    <p class="Pp"><span class="Li">&quot;flags&quot;</span> gives the eight bits
        of <span class="Li">&quot;op_flags&quot;</span> for the
        <span class="Li">&quot;leaveloop&quot;</span> op and, shifted up eight
        bits, the eight bits of <span class="Li">&quot;op_private&quot;</span>
        for the <span class="Li">&quot;leaveloop&quot;</span> op, except that
        (in both cases) some bits will be set automatically.
        <span class="Li">&quot;debuggable&quot;</span> is currently unused and
        should always be 1. <span class="Li">&quot;has_my&quot;</span> can be
        supplied as true to force the loop body to be enclosed in its own
      scope.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    newWHILEOP(I32 flags, I32 debuggable,
                           LOOP *loop, OP *expr, OP *block,
                           OP *cont, I32 has_my)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Optree_Manipulation_Functions"><a class="permalink" href="#Optree_Manipulation_Functions">Optree
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>alloccopstash</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Available only under threaded builds, this function allocates
        an entry in <span class="Li">&quot;PL_stashpad&quot;</span> for the
        stash passed to it.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET alloccopstash(HV *hv)
    </pre>
  </dd>
  <dt>block_end</dt>
  <dd>Handles compile-time scope exit. <span class="Li">&quot;floor&quot;</span>
      is the savestack index returned by
      <span class="Li">&quot;block_start&quot;</span>, and
      <span class="Li">&quot;seq&quot;</span> is the body of the block. Returns
      the block, possibly modified.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    block_end(I32 floor, OP *seq)
    </pre>
  </dd>
  <dt>block_start</dt>
  <dd>Handles compile-time scope entry. Arranges for hints to be restored on
      block exit and also handles pad sequence numbers to make lexical variables
      scope right. Returns a savestack index for use with
      <span class="Li">&quot;block_end&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     block_start(int full)
    </pre>
  </dd>
  <dt>ck_entersub_args_list</dt>
  <dd>Performs the default fixup of the arguments part of an
      <span class="Li">&quot;entersub&quot;</span> op tree. This consists of
      applying list context to each of the argument ops. This is the standard
      treatment used on a call marked with
      <span class="Li">&quot;&amp;&quot;</span>, or a method call, or a call
      through a subroutine reference, or any other call where the callee can't
      be identified at compile time, or a call where the callee has no
      prototype.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    ck_entersub_args_list(OP *entersubop)
    </pre>
  </dd>
  <dt>ck_entersub_args_proto</dt>
  <dd>Performs the fixup of the arguments part of an
      <span class="Li">&quot;entersub&quot;</span> op tree based on a subroutine
      prototype. This makes various modifications to the argument ops, from
      applying context up to inserting
      <span class="Li">&quot;refgen&quot;</span> ops, and checking the number
      and syntactic types of arguments, as directed by the prototype. This is
      the standard treatment used on a subroutine call, not marked with
      <span class="Li">&quot;&amp;&quot;</span>, where the callee can be
      identified at compile time and has a prototype.
    <p class="Pp"><span class="Li">&quot;protosv&quot;</span> supplies the
        subroutine prototype to be applied to the call. It may be a normal
        defined scalar, of which the string value will be used. Alternatively,
        for convenience, it may be a subroutine object (a
        <span class="Li">&quot;CV*&quot;</span> that has been cast to
        <span class="Li">&quot;SV*&quot;</span>) which has a prototype. The
        prototype supplied, in whichever form, does not need to match the actual
        callee referenced by the op tree.</p>
    <p class="Pp">If the argument ops disagree with the prototype, for example
        by having an unacceptable number of arguments, a valid op tree is
        returned anyway. The error is reflected in the parser state, normally
        resulting in a single exception at the top level of parsing which covers
        all the compilation errors that occurred. In the error message, the
        callee is referred to by the name defined by the
        <span class="Li">&quot;namegv&quot;</span> parameter.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    ck_entersub_args_proto(OP *entersubop,
                                       GV *namegv, SV *protosv)
    </pre>
  </dd>
  <dt>ck_entersub_args_proto_or_list</dt>
  <dd>Performs the fixup of the arguments part of an
      <span class="Li">&quot;entersub&quot;</span> op tree either based on a
      subroutine prototype or using default list-context processing. This is the
      standard treatment used on a subroutine call, not marked with
      <span class="Li">&quot;&amp;&quot;</span>, where the callee can be
      identified at compile time.
    <p class="Pp"><span class="Li">&quot;protosv&quot;</span> supplies the
        subroutine prototype to be applied to the call, or indicates that there
        is no prototype. It may be a normal scalar, in which case if it is
        defined then the string value will be used as a prototype, and if it is
        undefined then there is no prototype. Alternatively, for convenience, it
        may be a subroutine object (a <span class="Li">&quot;CV*&quot;</span>
        that has been cast to <span class="Li">&quot;SV*&quot;</span>), of which
        the prototype will be used if it has one. The prototype (or lack
        thereof) supplied, in whichever form, does not need to match the actual
        callee referenced by the op tree.</p>
    <p class="Pp">If the argument ops disagree with the prototype, for example
        by having an unacceptable number of arguments, a valid op tree is
        returned anyway. The error is reflected in the parser state, normally
        resulting in a single exception at the top level of parsing which covers
        all the compilation errors that occurred. In the error message, the
        callee is referred to by the name defined by the
        <span class="Li">&quot;namegv&quot;</span> parameter.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    ck_entersub_args_proto_or_list(OP *entersubop,
                                               GV *namegv,
                                               SV *protosv)
    </pre>
  </dd>
  <dt>cv_const_sv</dt>
  <dd>If <span class="Li">&quot;cv&quot;</span> is a constant sub eligible for
      inlining, returns the constant value returned by the sub. Otherwise,
      returns <span class="Li">&quot;NULL&quot;</span>.
    <p class="Pp">Constant subs can be created with
        <span class="Li">&quot;newCONSTSUB&quot;</span> or as described in
        &quot;Constant Functions&quot; in perlsub.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     cv_const_sv(const CV *const cv)
    </pre>
  </dd>
  <dt>cv_get_call_checker</dt>
  <dd>The original form of &quot;cv_get_call_checker_flags&quot;, which does not
      return checker flags. When using a checker function returned by this
      function, it is only safe to call it with a genuine GV as its
      <span class="Li">&quot;namegv&quot;</span> argument.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cv_get_call_checker(CV *cv,
                                    Perl_call_checker *ckfun_p,
                                    SV **ckobj_p)
    </pre>
  </dd>
  <dt>cv_get_call_checker_flags</dt>
  <dd>Retrieves the function that will be used to fix up a call to
      <span class="Li">&quot;cv&quot;</span>. Specifically, the function is
      applied to an <span class="Li">&quot;entersub&quot;</span> op tree for a
      subroutine call, not marked with
      <span class="Li">&quot;&amp;&quot;</span>, where the callee can be
      identified at compile time as <span class="Li">&quot;cv&quot;</span>.
    <p class="Pp">The C-level function pointer is returned in
        <span class="Li">*ckfun_p</span>, an SV argument for it is returned in
        <span class="Li">*ckobj_p</span>, and control flags are returned in
        <span class="Li">*ckflags_p</span>. The function is intended to be
        called in this manner:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 entersubop = (*ckfun_p)(aTHX_ entersubop, namegv, (*ckobj_p));
    </pre>
    <p class="Pp">In this call, <span class="Li">&quot;entersubop&quot;</span>
        is a pointer to the <span class="Li">&quot;entersub&quot;</span> op,
        which may be replaced by the check function, and
        <span class="Li">&quot;namegv&quot;</span> supplies the name that should
        be used by the check function to refer to the callee of the
        <span class="Li">&quot;entersub&quot;</span> op if it needs to emit any
        diagnostics. It is permitted to apply the check function in non-standard
        situations, such as to a call to a different subroutine or to a method
        call.</p>
    <p class="Pp"><span class="Li">&quot;namegv&quot;</span> may not actually be
        a GV. If the <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span>
        bit is clear in <span class="Li">*ckflags_p</span>, it is permitted to
        pass a CV or other SV instead, anything that can be used as the first
        argument to &quot;cv_name&quot;. If the
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> bit is set
        in <span class="Li">*ckflags_p</span> then the check function requires
        <span class="Li">&quot;namegv&quot;</span> to be a genuine GV.</p>
    <p class="Pp">By default, the check function is
        Perl_ck_entersub_args_proto_or_list, the SV parameter is
        <span class="Li">&quot;cv&quot;</span> itself, and the
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> flag is
        clear. This implements standard prototype processing. It can be changed,
        for a particular subroutine, by
      &quot;cv_set_call_checker_flags&quot;.</p>
    <p class="Pp">If the
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> bit is set
        in <span class="Li">&quot;gflags&quot;</span> then it indicates that the
        caller only knows about the genuine GV version of
        <span class="Li">&quot;namegv&quot;</span>, and accordingly the
        corresponding bit will always be set in
        <span class="Li">*ckflags_p</span>, regardless of the check function's
        recorded requirements. If the
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> bit is clear
        in <span class="Li">&quot;gflags&quot;</span> then it indicates the
        caller knows about the possibility of passing something other than a GV
        as <span class="Li">&quot;namegv&quot;</span>, and accordingly the
        corresponding bit may be either set or clear in
        <span class="Li">*ckflags_p</span>, indicating the check function's
        recorded requirements.</p>
    <p class="Pp"><span class="Li">&quot;gflags&quot;</span> is a bitset passed
        into <span class="Li">&quot;cv_get_call_checker_flags&quot;</span>, in
        which only the
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> bit
        currently has a defined meaning (for which see above). All other bits
        should be clear.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cv_get_call_checker_flags(
                    CV *cv, U32 gflags,
                    Perl_call_checker *ckfun_p, SV **ckobj_p,
                    U32 *ckflags_p
                )
    </pre>
  </dd>
  <dt>cv_set_call_checker</dt>
  <dd>The original form of &quot;cv_set_call_checker_flags&quot;, which passes
      it the <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> flag
      for backward-compatibility. The effect of that flag setting is that the
      check function is guaranteed to get a genuine GV as its
      <span class="Li">&quot;namegv&quot;</span> argument.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cv_set_call_checker(CV *cv,
                                    Perl_call_checker ckfun,
                                    SV *ckobj)
    </pre>
  </dd>
  <dt>cv_set_call_checker_flags</dt>
  <dd>Sets the function that will be used to fix up a call to
      <span class="Li">&quot;cv&quot;</span>. Specifically, the function is
      applied to an <span class="Li">&quot;entersub&quot;</span> op tree for a
      subroutine call, not marked with
      <span class="Li">&quot;&amp;&quot;</span>, where the callee can be
      identified at compile time as <span class="Li">&quot;cv&quot;</span>.
    <p class="Pp">The C-level function pointer is supplied in
        <span class="Li">&quot;ckfun&quot;</span>, an SV argument for it is
        supplied in <span class="Li">&quot;ckobj&quot;</span>, and control flags
        are supplied in <span class="Li">&quot;ckflags&quot;</span>. The
        function should be defined like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    STATIC OP * ckfun(pTHX_ OP *op, GV *namegv, SV *ckobj)
    </pre>
    <p class="Pp">It is intended to be called in this manner:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    entersubop = ckfun(aTHX_ entersubop, namegv, ckobj);
    </pre>
    <p class="Pp">In this call, <span class="Li">&quot;entersubop&quot;</span>
        is a pointer to the <span class="Li">&quot;entersub&quot;</span> op,
        which may be replaced by the check function, and
        <span class="Li">&quot;namegv&quot;</span> supplies the name that should
        be used by the check function to refer to the callee of the
        <span class="Li">&quot;entersub&quot;</span> op if it needs to emit any
        diagnostics. It is permitted to apply the check function in non-standard
        situations, such as to a call to a different subroutine or to a method
        call.</p>
    <p class="Pp"><span class="Li">&quot;namegv&quot;</span> may not actually be
        a GV. For efficiency, perl may pass a CV or other SV instead. Whatever
        is passed can be used as the first argument to &quot;cv_name&quot;. You
        can force perl to pass a GV by including
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> in the
        <span class="Li">&quot;ckflags&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;ckflags&quot;</span> is a bitset, in
        which only the
        <span class="Li">&quot;CALL_CHECKER_REQUIRE_GV&quot;</span> bit
        currently has a defined meaning (for which see above). All other bits
        should be clear.</p>
    <p class="Pp">The current setting for a particular CV can be retrieved by
        &quot;cv_get_call_checker_flags&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cv_set_call_checker_flags(
                    CV *cv, Perl_call_checker ckfun, SV *ckobj,
                    U32 ckflags
                )
    </pre>
  </dd>
  <dt>LINKLIST</dt>
  <dd>Given the root of an optree, link the tree in execution order using the
      <span class="Li">&quot;op_next&quot;</span> pointers and return the first
      op executed. If this has already been done, it will not be redone, and
      <span class="Li">&quot;o-&gt;op_next&quot;</span> will be returned. If
      <span class="Li">&quot;o-&gt;op_next&quot;</span> is not already set,
      <span class="Li">&quot;o&quot;</span> should be at least an
      <span class="Li">&quot;UNOP&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP*     LINKLIST(OP *o)
    </pre>
  </dd>
  <dt>newCONSTSUB</dt>
  <dd>Behaves like &quot;newCONSTSUB_flags&quot;, except that
      <span class="Li">&quot;name&quot;</span> is nul-terminated rather than of
      counted length, and no flags are set. (This means that
      <span class="Li">&quot;name&quot;</span> is always interpreted as
      Latin-1.)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV *    newCONSTSUB(HV *stash, const char *name, SV *sv)
    </pre>
  </dd>
  <dt>newCONSTSUB_flags</dt>
  <dd>Construct a constant subroutine, also performing some surrounding jobs. A
      scalar constant-valued subroutine is eligible for inlining at
      compile-time, and in Perl code can be created by
      <span class="Li">&quot;sub&#x00A0;FOO&#x00A0;()&#x00A0;{&#x00A0;123&#x00A0;}&quot;</span>.
      Other kinds of constant subroutine have other treatment.
    <p class="Pp">The subroutine will have an empty prototype and will ignore
        any arguments when called. Its constant behaviour is determined by
        <span class="Li">&quot;sv&quot;</span>. If
        <span class="Li">&quot;sv&quot;</span> is null, the subroutine will
        yield an empty list. If <span class="Li">&quot;sv&quot;</span> points to
        a scalar, the subroutine will always yield that scalar. If
        <span class="Li">&quot;sv&quot;</span> points to an array, the
        subroutine will always yield a list of the elements of that array in
        list context, or the number of elements in the array in scalar context.
        This function takes ownership of one counted reference to the scalar or
        array, and will arrange for the object to live as long as the subroutine
        does. If <span class="Li">&quot;sv&quot;</span> points to a scalar then
        the inlining assumes that the value of the scalar will never change, so
        the caller must ensure that the scalar is not subsequently written to.
        If <span class="Li">&quot;sv&quot;</span> points to an array then no
        such assumption is made, so it is ostensibly safe to mutate the array or
        its elements, but whether this is really supported has not been
        determined.</p>
    <p class="Pp">The subroutine will have
        <span class="Li">&quot;CvFILE&quot;</span> set according to
        <span class="Li">&quot;PL_curcop&quot;</span>. Other aspects of the
        subroutine will be left in their default state. The caller is free to
        mutate the subroutine beyond its initial state after this function has
        returned.</p>
    <p class="Pp">If <span class="Li">&quot;name&quot;</span> is null then the
        subroutine will be anonymous, with its
        <span class="Li">&quot;CvGV&quot;</span> referring to an
        <span class="Li">&quot;__ANON__&quot;</span> glob. If
        <span class="Li">&quot;name&quot;</span> is non-null then the subroutine
        will be named accordingly, referenced by the appropriate glob.
        <span class="Li">&quot;name&quot;</span> is a string of length
        <span class="Li">&quot;len&quot;</span> bytes giving a sigilless symbol
        name, in UTF-8 if <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;SVf_UTF8&quot;</span> bit set and in Latin-1
        otherwise. The name may be either qualified or unqualified. If the name
        is unqualified then it defaults to being in the stash specified by
        <span class="Li">&quot;stash&quot;</span> if that is non-null, or to
        <span class="Li">&quot;PL_curstash&quot;</span> if
        <span class="Li">&quot;stash&quot;</span> is null. The symbol is always
        added to the stash if necessary, with
        <span class="Li">&quot;GV_ADDMULTI&quot;</span> semantics.</p>
    <p class="Pp"><span class="Li">&quot;flags&quot;</span> should not have bits
        set other than <span class="Li">&quot;SVf_UTF8&quot;</span>.</p>
    <p class="Pp">If there is already a subroutine of the specified name, then
        the new sub will replace the existing one in the glob. A warning may be
        generated about the redefinition.</p>
    <p class="Pp">If the subroutine has one of a few special names, such as
        <span class="Li">&quot;BEGIN&quot;</span> or
        <span class="Li">&quot;END&quot;</span>, then it will be claimed by the
        appropriate queue for automatic running of phase-related subroutines. In
        this case the relevant glob will be left not containing any subroutine,
        even if it did contain one before. Execution of the subroutine will
        likely be a no-op, unless <span class="Li">&quot;sv&quot;</span> was a
        tied array or the caller modified the subroutine in some interesting way
        before it was executed. In the case of
        <span class="Li">&quot;BEGIN&quot;</span>, the treatment is buggy: the
        sub will be executed when only half built, and may be deleted
        prematurely, possibly causing a crash.</p>
    <p class="Pp">The function returns a pointer to the constructed subroutine.
        If the sub is anonymous then ownership of one counted reference to the
        subroutine is transferred to the caller. If the sub is named then the
        caller does not get ownership of a reference. In most such cases, where
        the sub has a non-phase name, the sub will be alive at the point it is
        returned by virtue of being contained in the glob that names it. A
        phase-named subroutine will usually be alive by virtue of the reference
        owned by the phase's automatic run queue. A
        <span class="Li">&quot;BEGIN&quot;</span> subroutine may have been
        destroyed already by the time this function returns, but currently bugs
        occur in that case before the caller gets control. It is the caller's
        responsibility to ensure that it knows which of these situations
        applies.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV *    newCONSTSUB_flags(HV *stash, const char *name,
                                  STRLEN len, U32 flags, SV *sv)
    </pre>
  </dd>
  <dt>newXS</dt>
  <dd>Used by <span class="Li">&quot;xsubpp&quot;</span> to hook up XSUBs as
      Perl subs. <span class="Li">&quot;filename&quot;</span> needs to be static
      storage, as it is used directly as <b>CvFILE()</b>, without a copy being
      made.</dd>
  <dt>op_append_elem</dt>
  <dd>Append an item to the list of ops contained directly within a list-type
      op, returning the lengthened list.
      <span class="Li">&quot;first&quot;</span> is the list-type op, and
      <span class="Li">&quot;last&quot;</span> is the op to append to the list.
      <span class="Li">&quot;optype&quot;</span> specifies the intended opcode
      for the list. If <span class="Li">&quot;first&quot;</span> is not already
      a list of the right type, it will be upgraded into one. If either
      <span class="Li">&quot;first&quot;</span> or
      <span class="Li">&quot;last&quot;</span> is null, the other is returned
      unchanged.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_append_elem(I32 optype, OP *first, OP *last)
    </pre>
  </dd>
  <dt>op_append_list</dt>
  <dd>Concatenate the lists of ops contained directly within two list-type ops,
      returning the combined list. <span class="Li">&quot;first&quot;</span> and
      <span class="Li">&quot;last&quot;</span> are the list-type ops to
      concatenate. <span class="Li">&quot;optype&quot;</span> specifies the
      intended opcode for the list. If either
      <span class="Li">&quot;first&quot;</span> or
      <span class="Li">&quot;last&quot;</span> is not already a list of the
      right type, it will be upgraded into one. If either
      <span class="Li">&quot;first&quot;</span> or
      <span class="Li">&quot;last&quot;</span> is null, the other is returned
      unchanged.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_append_list(I32 optype, OP *first, OP *last)
    </pre>
  </dd>
  <dt>OP_CLASS</dt>
  <dd>Return the class of the provided OP: that is, which of the *OP structures
      it uses. For core ops this currently gets the information out of
      <span class="Li">&quot;PL_opargs&quot;</span>, which does not always
      accurately reflect the type used; in v5.26 onwards, see also the function
      <span class="Li">&quot;op_class&quot;</span> which can do a better job of
      determining the used type.
    <p class="Pp">For custom ops the type is returned from the registration, and
        it is up to the registree to ensure it is accurate. The value returned
        will be one of the <span class="Li">&quot;OA_&quot;</span>* constants
        from <i>op.h</i>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     OP_CLASS(OP *o)
    </pre>
  </dd>
  <dt>op_contextualize</dt>
  <dd>Applies a syntactic context to an op tree representing an expression.
      <span class="Li">&quot;o&quot;</span> is the op tree, and
      <span class="Li">&quot;context&quot;</span> must be
      <span class="Li">&quot;G_SCALAR&quot;</span>,
      <span class="Li">&quot;G_ARRAY&quot;</span>, or
      <span class="Li">&quot;G_VOID&quot;</span> to specify the context to
      apply. The modified op tree is returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_contextualize(OP *o, I32 context)
    </pre>
  </dd>
  <dt>op_convert_list</dt>
  <dd>Converts <span class="Li">&quot;o&quot;</span> into a list op if it is not
      one already, and then converts it into the specified
      <span class="Li">&quot;type&quot;</span>, calling its check function,
      allocating a target if it needs one, and folding constants.
    <p class="Pp">A list-type op is usually constructed one kid at a time via
        <span class="Li">&quot;newLISTOP&quot;</span>,
        <span class="Li">&quot;op_prepend_elem&quot;</span> and
        <span class="Li">&quot;op_append_elem&quot;</span>. Then finally it is
        passed to <span class="Li">&quot;op_convert_list&quot;</span> to make it
        the right type.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_convert_list(I32 type, I32 flags, OP *o)
    </pre>
  </dd>
  <dt>OP_DESC</dt>
  <dd>Return a short description of the provided OP.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char * OP_DESC(OP *o)
    </pre>
  </dd>
  <dt>op_free</dt>
  <dd>Free an op. Only use this when an op is no longer linked to from any
      optree.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    op_free(OP *o)
    </pre>
  </dd>
  <dt>OpHAS_SIBLING</dt>
  <dd>Returns true if <span class="Li">&quot;o&quot;</span> has a sibling
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    OpHAS_SIBLING(OP *o)
    </pre>
  </dd>
  <dt>OpLASTSIB_set</dt>
  <dd>Marks <span class="Li">&quot;o&quot;</span> as having no further siblings
      and marks o as having the specified parent. See also
      <span class="Li">&quot;OpMORESIB_set&quot;</span> and
      <span class="Li">&quot;OpMAYBESIB_set&quot;</span>. For a higher-level
      interface, see <span class="Li">&quot;op_sibling_splice&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    OpLASTSIB_set(OP *o, OP *parent)
    </pre>
  </dd>
  <dt>op_linklist</dt>
  <dd>This function is the implementation of the &quot;LINKLIST&quot; macro. It
      should not be called directly.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP*     op_linklist(OP *o)
    </pre>
  </dd>
  <dt>op_lvalue</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Propagate lvalue (&quot;modifiable&quot;) context to an op and
        its children. <span class="Li">&quot;type&quot;</span> represents the
        context type, roughly based on the type of op that would do the
        modifying, although <span class="Li">&quot;local()&quot;</span> is
        represented by <span class="Li">&quot;OP_NULL&quot;</span>, because it
        has no op type of its own (it is signalled by a flag on the lvalue
      op).</p>
    <p class="Pp">This function detects things that can't be modified, such as
        <span class="Li">&quot;$x+1&quot;</span>, and generates errors for them.
        For example, <span class="Li">&quot;$x+1 = 2&quot;</span> would cause it
        to be called with an op of type
        <span class="Li">&quot;OP_ADD&quot;</span> and a
        <span class="Li">&quot;type&quot;</span> argument of
        <span class="Li">&quot;OP_SASSIGN&quot;</span>.</p>
    <p class="Pp">It also flags things that need to behave specially in an
        lvalue context, such as <span class="Li">&quot;$$x = 5&quot;</span>
        which might have to vivify a reference in
      <span class="Li">$x</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_lvalue(OP *o, I32 type)
    </pre>
  </dd>
  <dt>OpMAYBESIB_set</dt>
  <dd>Conditionally does <span class="Li">&quot;OpMORESIB_set&quot;</span> or
      <span class="Li">&quot;OpLASTSIB_set&quot;</span> depending on whether
      <span class="Li">&quot;sib&quot;</span> is non-null. For a higher-level
      interface, see <span class="Li">&quot;op_sibling_splice&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    OpMAYBESIB_set(OP *o, OP *sib, OP *parent)
    </pre>
  </dd>
  <dt>OpMORESIB_set</dt>
  <dd>Sets the sibling of <span class="Li">&quot;o&quot;</span> to the non-zero
      value <span class="Li">&quot;sib&quot;</span>. See also
      <span class="Li">&quot;OpLASTSIB_set&quot;</span> and
      <span class="Li">&quot;OpMAYBESIB_set&quot;</span>. For a higher-level
      interface, see <span class="Li">&quot;op_sibling_splice&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    OpMORESIB_set(OP *o, OP *sib)
    </pre>
  </dd>
  <dt>OP_NAME</dt>
  <dd>Return the name of the provided OP. For core ops this looks up the name
      from the op_type; for custom ops from the op_ppaddr.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char * OP_NAME(OP *o)
    </pre>
  </dd>
  <dt>op_null</dt>
  <dd>Neutralizes an op when it is no longer needed, but is still linked to from
      other ops.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    op_null(OP *o)
    </pre>
  </dd>
  <dt>op_parent</dt>
  <dd>Returns the parent OP of <span class="Li">&quot;o&quot;</span>, if it has
      a parent. Returns <span class="Li">&quot;NULL&quot;</span> otherwise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP*     op_parent(OP *o)
    </pre>
  </dd>
  <dt>op_prepend_elem</dt>
  <dd>Prepend an item to the list of ops contained directly within a list-type
      op, returning the lengthened list.
      <span class="Li">&quot;first&quot;</span> is the op to prepend to the
      list, and <span class="Li">&quot;last&quot;</span> is the list-type op.
      <span class="Li">&quot;optype&quot;</span> specifies the intended opcode
      for the list. If <span class="Li">&quot;last&quot;</span> is not already a
      list of the right type, it will be upgraded into one. If either
      <span class="Li">&quot;first&quot;</span> or
      <span class="Li">&quot;last&quot;</span> is null, the other is returned
      unchanged.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_prepend_elem(I32 optype, OP *first, OP *last)
    </pre>
  </dd>
  <dt>op_scope</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Wraps up an op tree with some additional ops so that at
        runtime a dynamic scope will be created. The original ops run in the new
        dynamic scope, and then, provided that they exit normally, the scope
        will be unwound. The additional ops used to create and unwind the
        dynamic scope will normally be an
        <span class="Li">&quot;enter&quot;</span>/<span class="Li">&quot;leave&quot;</span>
        pair, but a <span class="Li">&quot;scope&quot;</span> op may be used
        instead if the ops are simple enough to not need the full dynamic scope
        structure.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    op_scope(OP *o)
    </pre>
  </dd>
  <dt>OpSIBLING</dt>
  <dd>Returns the sibling of <span class="Li">&quot;o&quot;</span>, or
      <span class="Li">&quot;NULL&quot;</span> if there is no sibling
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP*     OpSIBLING(OP *o)
    </pre>
  </dd>
  <dt>op_sibling_splice</dt>
  <dd>A general function for editing the structure of an existing chain of
      op_sibling nodes. By analogy with the perl-level
      <span class="Li">&quot;splice()&quot;</span> function, allows you to
      delete zero or more sequential nodes, replacing them with zero or more
      different nodes. Performs the necessary op_first/op_last housekeeping on
      the parent node and op_sibling manipulation on the children. The last
      deleted node will be marked as as the last node by updating the
      op_sibling/op_sibparent or op_moresib field as appropriate.
    <p class="Pp">Note that op_next is not manipulated, and nodes are not freed;
        that is the responsibility of the caller. It also won't create a new
        list op for an empty list etc; use higher-level functions like
        <b>op_append_elem()</b> for that.</p>
    <p class="Pp"><span class="Li">&quot;parent&quot;</span> is the parent node
        of the sibling chain. It may passed as
        <span class="Li">&quot;NULL&quot;</span> if the splicing doesn't affect
        the first or last op in the chain.</p>
    <p class="Pp"><span class="Li">&quot;start&quot;</span> is the node
        preceding the first node to be spliced. Node(s) following it will be
        deleted, and ops will be inserted after it. If it is
        <span class="Li">&quot;NULL&quot;</span>, the first node onwards is
        deleted, and nodes are inserted at the beginning.</p>
    <p class="Pp"><span class="Li">&quot;del_count&quot;</span> is the number of
        nodes to delete. If zero, no nodes are deleted. If -1 or greater than or
        equal to the number of remaining kids, all remaining kids are
      deleted.</p>
    <p class="Pp"><span class="Li">&quot;insert&quot;</span> is the first of a
        chain of nodes to be inserted in place of the nodes. If
        <span class="Li">&quot;NULL&quot;</span>, no nodes are inserted.</p>
    <p class="Pp">The head of the chain of deleted ops is returned, or
        <span class="Li">&quot;NULL&quot;</span> if no ops were deleted.</p>
    <p class="Pp">For example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    action                    before      after         returns
    ------                    -----       -----         -------

                              P           P
    splice(P, A, 2, X-Y-Z)    |           |             B-C
                              A-B-C-D     A-X-Y-Z-D

                              P           P
    splice(P, NULL, 1, X-Y)   |           |             A
                              A-B-C-D     X-Y-B-C-D

                              P           P
    splice(P, NULL, 3, NULL)  |           |             A-B-C
                              A-B-C-D     D

                              P           P
    splice(P, B, 0, X-Y)      |           |             NULL
                              A-B-C-D     A-B-X-Y-C-D
    </pre>
    <p class="Pp">For lower-level direct manipulation of
        <span class="Li">&quot;op_sibparent&quot;</span> and
        <span class="Li">&quot;op_moresib&quot;</span>, see
        <span class="Li">&quot;OpMORESIB_set&quot;</span>,
        <span class="Li">&quot;OpLASTSIB_set&quot;</span>,
        <span class="Li">&quot;OpMAYBESIB_set&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP*     op_sibling_splice(OP *parent, OP *start,
                                  int del_count, OP* insert)
    </pre>
  </dd>
  <dt>OP_TYPE_IS</dt>
  <dd>Returns true if the given OP is not a
      <span class="Li">&quot;NULL&quot;</span> pointer and if it is of the given
      type.
    <p class="Pp">The negation of this macro,
        <span class="Li">&quot;OP_TYPE_ISNT&quot;</span> is also available as
        well as <span class="Li">&quot;OP_TYPE_IS_NN&quot;</span> and
        <span class="Li">&quot;OP_TYPE_ISNT_NN&quot;</span> which elide the NULL
        pointer check.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    OP_TYPE_IS(OP *o, Optype type)
    </pre>
  </dd>
  <dt>OP_TYPE_IS_OR_WAS</dt>
  <dd>Returns true if the given OP is not a NULL pointer and if it is of the
      given type or used to be before being replaced by an OP of type OP_NULL.
    <p class="Pp">The negation of this macro,
        <span class="Li">&quot;OP_TYPE_ISNT_AND_WASNT&quot;</span> is also
        available as well as
        <span class="Li">&quot;OP_TYPE_IS_OR_WAS_NN&quot;</span> and
        <span class="Li">&quot;OP_TYPE_ISNT_AND_WASNT_NN&quot;</span> which
        elide the <span class="Li">&quot;NULL&quot;</span> pointer check.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    OP_TYPE_IS_OR_WAS(OP *o, Optype type)
    </pre>
  </dd>
  <dt>rv2cv_op_cv</dt>
  <dd>Examines an op, which is expected to identify a subroutine at runtime, and
      attempts to determine at compile time which subroutine it identifies. This
      is normally used during Perl compilation to determine whether a prototype
      can be applied to a function call.
      <span class="Li">&quot;cvop&quot;</span> is the op being considered,
      normally an <span class="Li">&quot;rv2cv&quot;</span> op. A pointer to the
      identified subroutine is returned, if it could be determined statically,
      and a null pointer is returned if it was not possible to determine
      statically.
    <p class="Pp">Currently, the subroutine can be identified statically if the
        RV that the <span class="Li">&quot;rv2cv&quot;</span> is to operate on
        is provided by a suitable <span class="Li">&quot;gv&quot;</span> or
        <span class="Li">&quot;const&quot;</span> op. A
        <span class="Li">&quot;gv&quot;</span> op is suitable if the GV's CV
        slot is populated. A <span class="Li">&quot;const&quot;</span> op is
        suitable if the constant value must be an RV pointing to a CV. Details
        of this process may change in future versions of Perl. If the
        <span class="Li">&quot;rv2cv&quot;</span> op has the
        <span class="Li">&quot;OPpENTERSUB_AMPER&quot;</span> flag set then no
        attempt is made to identify the subroutine statically: this flag is used
        to suppress compile-time magic on a subroutine call, forcing it to use
        default runtime behaviour.</p>
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> has the bit
        <span class="Li">&quot;RV2CVOPCV_MARK_EARLY&quot;</span> set, then the
        handling of a GV reference is modified. If a GV was examined and its CV
        slot was found to be empty, then the
        <span class="Li">&quot;gv&quot;</span> op has the
        <span class="Li">&quot;OPpEARLY_CV&quot;</span> flag set. If the op is
        not optimised away, and the CV slot is later populated with a subroutine
        having a prototype, that flag eventually triggers the warning
        &quot;called too early to check prototype&quot;.</p>
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> has the bit
        <span class="Li">&quot;RV2CVOPCV_RETURN_NAME_GV&quot;</span> set, then
        instead of returning a pointer to the subroutine it returns a pointer to
        the GV giving the most appropriate name for the subroutine in this
        context. Normally this is just the
        <span class="Li">&quot;CvGV&quot;</span> of the subroutine, but for an
        anonymous (<span class="Li">&quot;CvANON&quot;</span>) subroutine that
        is referenced through a GV it will be the referencing GV. The resulting
        <span class="Li">&quot;GV*&quot;</span> is cast to
        <span class="Li">&quot;CV*&quot;</span> to be returned. A null pointer
        is returned as usual if there is no statically-determinable
      subroutine.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV *    rv2cv_op_cv(OP *cvop, U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Pack_and_Unpack"><a class="permalink" href="#Pack_and_Unpack">Pack
  and Unpack</a></h1>
<dl class="Bl-tag">
  <dt>packlist</dt>
  <dd>The engine implementing <span class="Li">&quot;pack()&quot;</span> Perl
      function.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    packlist(SV *cat, const char *pat,
                         const char *patend, SV **beglist,
                         SV **endlist)
    </pre>
  </dd>
  <dt>unpackstring</dt>
  <dd>The engine implementing the <span class="Li">&quot;unpack()&quot;</span>
      Perl function.
    <p class="Pp">Using the template
        <span class="Li">&quot;pat..patend&quot;</span>, this function unpacks
        the string <span class="Li">&quot;s..strend&quot;</span> into a number
        of mortal SVs, which it pushes onto the perl argument
        (<span class="Li">@_</span>) stack (so you will need to issue a
        <span class="Li">&quot;PUTBACK&quot;</span> before and
        <span class="Li">&quot;SPAGAIN&quot;</span> after the call to this
        function). It returns the number of pushed elements.</p>
    <p class="Pp">The <span class="Li">&quot;strend&quot;</span> and
        <span class="Li">&quot;patend&quot;</span> pointers should point to the
        byte following the last character of each string.</p>
    <p class="Pp">Although this function returns its values on the perl argument
        stack, it doesn't take any parameters from that stack (and thus in
        particular there's no need to do a
        <span class="Li">&quot;PUSHMARK&quot;</span> before calling it, unlike
        &quot;call_pv&quot; for example).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t unpackstring(const char *pat,
                             const char *patend, const char *s,
                             const char *strend, U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Pad_Data_Structures"><a class="permalink" href="#Pad_Data_Structures">Pad
  Data Structures</a></h1>
<dl class="Bl-tag">
  <dt>CvPADLIST</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">CV's can have CvPADLIST(cv) set to point to a PADLIST. This is
        the CV's scratchpad, which stores lexical variables and opcode temporary
        and per-thread values.</p>
    <p class="Pp">For these purposes &quot;formats&quot; are a kind-of CV;
        eval&quot;&quot;s are too (except they're not callable at will and are
        always thrown away after the eval&quot;&quot; is done executing).
        Require'd files are simply evals without any outer lexical scope.</p>
    <p class="Pp">XSUBs do not have a
        <span class="Li">&quot;CvPADLIST&quot;</span>.
        <span class="Li">&quot;dXSTARG&quot;</span> fetches values from
        <span class="Li">&quot;PL_curpad&quot;</span>, but that is really the
        callers pad (a slot of which is allocated by every entersub). Do not get
        or set <span class="Li">&quot;CvPADLIST&quot;</span> if a CV is an XSUB
        (as determined by <span class="Li">&quot;CvISXSUB()&quot;</span>),
        <span class="Li">&quot;CvPADLIST&quot;</span> slot is reused for a
        different internal purpose in XSUBs.</p>
    <p class="Pp">The PADLIST has a C array where pads are stored.</p>
    <p class="Pp">The 0th entry of the PADLIST is a PADNAMELIST which represents
        the &quot;names&quot; or rather the &quot;static type information&quot;
        for lexicals. The individual elements of a PADNAMELIST are PADNAMEs.
        Future refactorings might stop the PADNAMELIST from being stored in the
        PADLIST's array, so don't rely on it. See &quot;PadlistNAMES&quot;.</p>
    <p class="Pp">The CvDEPTH'th entry of a PADLIST is a PAD (an AV) which is
        the stack frame at that depth of recursion into the CV. The 0th slot of
        a frame AV is an AV which is <span class="Li">@_</span>. Other entries
        are storage for variables and op targets.</p>
    <p class="Pp">Iterating over the PADNAMELIST iterates over all possible pad
        items. Pad slots for targets
        (<span class="Li">&quot;SVs_PADTMP&quot;</span>) and GVs end up having
        &amp;PL_padname_undef &quot;names&quot;, while slots for constants have
        <span class="Li">&amp;PL_padname_const</span> &quot;names&quot; (see
        <span class="Li">&quot;pad_alloc&quot;</span>). That
        <span class="Li">&amp;PL_padname_undef</span> and
        <span class="Li">&amp;PL_padname_const</span> are used is an
        implementation detail subject to change. To test for them, use
        <span class="Li">&quot;!PadnamePV(name)&quot;</span> and
        <span class="Li">&quot;PadnamePV(name)&#x00A0;&amp;&amp;&#x00A0;!PadnameLEN(name)&quot;</span>,
        respectively.</p>
    <p class="Pp">Only
        <span class="Li">&quot;my&quot;</span>/<span class="Li">&quot;our&quot;</span>
        variable slots get valid names. The rest are op targets/GVs/constants
        which are statically allocated or resolved at compile time. These don't
        have names by which they can be looked up from Perl code at run time
        through eval&quot;&quot; the way
        <span class="Li">&quot;my&quot;</span>/<span class="Li">&quot;our&quot;</span>
        variables can be. Since they can't be looked up by &quot;name&quot; but
        only by their index allocated at compile time (which is usually in
        <span class="Li">&quot;PL_op-&gt;op_targ&quot;</span>), wasting a name
        SV for them doesn't make sense.</p>
    <p class="Pp">The pad names in the PADNAMELIST have their PV holding the
        name of the variable. The
        <span class="Li">&quot;COP_SEQ_RANGE_LOW&quot;</span> and
        <span class="Li">&quot;_HIGH&quot;</span> fields form a range
        (low+1..high inclusive) of cop_seq numbers for which the name is valid.
        During compilation, these fields may hold the special value
        PERL_PADSEQ_INTRO to indicate various stages:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 COP_SEQ_RANGE_LOW        _HIGH
 -----------------        -----
 PERL_PADSEQ_INTRO            0   variable not yet introduced:
                                  { my ($x
 valid-seq#   PERL_PADSEQ_INTRO   variable in scope:
                                  { my ($x);
 valid-seq#          valid-seq#   compilation of scope complete:
                                  { my ($x); .... }
    </pre>
    <p class="Pp">When a lexical var hasn't yet been introduced, it already
        exists from the perspective of duplicate declarations, but not for
        variable lookups, e.g.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my ($x, $x); # '&quot;my&quot; variable $x masks earlier declaration'
    my $x = $x;  # equal to my $x = $::x;
    </pre>
    <p class="Pp">For typed lexicals
        <span class="Li">&quot;PadnameTYPE&quot;</span> points at the type
        stash. For <span class="Li">&quot;our&quot;</span> lexicals,
        <span class="Li">&quot;PadnameOURSTASH&quot;</span> points at the stash
        of the associated global (so that duplicate
        <span class="Li">&quot;our&quot;</span> declarations in the same package
        can be detected). <span class="Li">&quot;PadnameGEN&quot;</span> is
        sometimes used to store the generation number during compilation.</p>
    <p class="Pp">If <span class="Li">&quot;PadnameOUTER&quot;</span> is set on
        the pad name, then that slot in the frame AV is a REFCNT'ed reference to
        a lexical from &quot;outside&quot;. Such entries are sometimes referred
        to as 'fake'. In this case, the name does not use 'low' and 'high' to
        store a cop_seq range, since it is in scope throughout. Instead 'high'
        stores some flags containing info about the real lexical (is it declared
        in an anon, and is it capable of being instantiated multiple times?),
        and for fake ANONs, 'low' contains the index within the parent's pad
        where the lexical's value is stored, to make cloning quicker.</p>
    <p class="Pp">If the 'name' is <span class="Li">&quot;&amp;&quot;</span> the
        corresponding entry in the PAD is a CV representing a possible
      closure.</p>
    <p class="Pp">Note that formats are treated as anon subs, and are cloned
        each time write is called (if necessary).</p>
    <p class="Pp">The flag <span class="Li">&quot;SVs_PADSTALE&quot;</span> is
        cleared on lexicals each time the
        <span class="Li">&quot;my()&quot;</span> is executed, and set on scope
        exit. This allows the <span class="Li">&quot;Variable $x is not
        available&quot;</span> warning to be generated in evals, such as</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    { my $x = 1; sub f { eval '$x'} } f();
    </pre>
    <p class="Pp">For state vars,
        <span class="Li">&quot;SVs_PADSTALE&quot;</span> is overloaded to mean
        'not yet initialised', but this internal state is stored in a separate
        pad entry.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADLIST * CvPADLIST(CV *cv)
    </pre>
  </dd>
  <dt>pad_add_name_pvs</dt>
  <dd>Exactly like &quot;pad_add_name_pvn&quot;, but takes a literal string
      instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_add_name_pvs(&quot;literal string&quot; name,
                                   U32 flags, HV *typestash,
                                   HV *ourstash)
    </pre>
  </dd>
  <dt>PadARRAY</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The C array of pad entries.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV **   PadARRAY(PAD pad)
    </pre>
  </dd>
  <dt>pad_findmy_pvs</dt>
  <dd>Exactly like &quot;pad_findmy_pvn&quot;, but takes a literal string
      instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_findmy_pvs(&quot;literal string&quot; name,
                                 U32 flags)
    </pre>
  </dd>
  <dt>PadlistARRAY</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The C array of a padlist, containing the pads. Only subscript
        it with numbers &gt;= 1, as the 0th entry is not guaranteed to remain
        usable.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PAD **  PadlistARRAY(PADLIST padlist)
    </pre>
  </dd>
  <dt>PadlistMAX</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The index of the last allocated space in the padlist. Note
        that the last pad may be in an earlier slot. Any entries following it
        will be <span class="Li">&quot;NULL&quot;</span> in that case.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t PadlistMAX(PADLIST padlist)
    </pre>
  </dd>
  <dt>PadlistNAMES</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The names associated with pad entries.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADNAMELIST * PadlistNAMES(PADLIST padlist)
    </pre>
  </dd>
  <dt>PadlistNAMESARRAY</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The C array of pad names.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADNAME ** PadlistNAMESARRAY(PADLIST padlist)
    </pre>
  </dd>
  <dt>PadlistNAMESMAX</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The index of the last pad name.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t PadlistNAMESMAX(PADLIST padlist)
    </pre>
  </dd>
  <dt>PadlistREFCNT</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The reference count of the padlist. Currently this is always
        1.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     PadlistREFCNT(PADLIST padlist)
    </pre>
  </dd>
  <dt>PadMAX</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The index of the last pad entry.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t PadMAX(PAD pad)
    </pre>
  </dd>
  <dt>PadnameLEN</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The length of the name.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  PadnameLEN(PADNAME pn)
    </pre>
  </dd>
  <dt>PadnamelistARRAY</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The C array of pad names.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADNAME ** PadnamelistARRAY(PADNAMELIST pnl)
    </pre>
  </dd>
  <dt>PadnamelistMAX</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The index of the last pad name.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t PadnamelistMAX(PADNAMELIST pnl)
    </pre>
  </dd>
  <dt>PadnamelistREFCNT</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The reference count of the pad name list.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t PadnamelistREFCNT(PADNAMELIST pnl)
    </pre>
  </dd>
  <dt>PadnamelistREFCNT_dec</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Lowers the reference count of the pad name list.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PadnamelistREFCNT_dec(PADNAMELIST pnl)
    </pre>
  </dd>
  <dt>PadnamePV</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The name stored in the pad name struct. This returns
        <span class="Li">&quot;NULL&quot;</span> for a target slot.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char *  PadnamePV(PADNAME pn)
    </pre>
  </dd>
  <dt>PadnameREFCNT</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">The reference count of the pad name.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SSize_t PadnameREFCNT(PADNAME pn)
    </pre>
  </dd>
  <dt>PadnameREFCNT_dec</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Lowers the reference count of the pad name.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PadnameREFCNT_dec(PADNAME pn)
    </pre>
  </dd>
  <dt>PadnameSV</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Returns the pad name as a mortal SV.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    PadnameSV(PADNAME pn)
    </pre>
  </dd>
  <dt>PadnameUTF8</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Whether PadnamePV is in UTF-8. Currently, this is always
      true.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    PadnameUTF8(PADNAME pn)
    </pre>
  </dd>
  <dt>pad_new</dt>
  <dd>Create a new padlist, updating the global variables for the
      currently-compiling padlist to point to the new padlist. The following
      flags can be OR'ed together:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    padnew_CLONE        this pad is for a cloned CV
    padnew_SAVE         save old globals on the save stack
    padnew_SAVESUB      also save extra stuff for start of sub

        PADLIST * pad_new(int flags)
    </pre>
  </dd>
  <dt>PL_comppad</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">During compilation, this points to the array containing the
        values part of the pad for the currently-compiling code. (At runtime a
        CV may have many such value arrays; at compile time just one is
        constructed.) At runtime, this points to the array containing the
        currently-relevant values for the pad for the currently-executing
      code.</p>
  </dd>
  <dt>PL_comppad_name</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">During compilation, this points to the array containing the
        names part of the pad for the currently-compiling code.</p>
  </dd>
  <dt>PL_curpad</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Points directly to the body of the &quot;PL_comppad&quot;
        array. (I.e., this is
        <span class="Li">&quot;PadARRAY(PL_comppad)&quot;</span>.)</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Per-Interpreter_Variables"><a class="permalink" href="#Per-Interpreter_Variables">Per-Interpreter
  Variables</a></h1>
<dl class="Bl-tag">
  <dt>PL_modglobal</dt>
  <dd><span class="Li">&quot;PL_modglobal&quot;</span> is a general purpose,
      interpreter global HV for use by extensions that need to keep information
      on a per-interpreter basis. In a pinch, it can also be used as a symbol
      table for extensions to share data among each other. It is a good idea to
      use keys prefixed by the package name of the extension that owns the data.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     PL_modglobal
    </pre>
  </dd>
  <dt>PL_na</dt>
  <dd>A convenience variable which is typically used with
      <span class="Li">&quot;SvPV&quot;</span> when one doesn't care about the
      length of the string. It is usually more efficient to either declare a
      local variable and use that instead or to use the
      <span class="Li">&quot;SvPV_nolen&quot;</span> macro.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  PL_na
    </pre>
  </dd>
  <dt>PL_opfreehook</dt>
  <dd>When non-<span class="Li">&quot;NULL&quot;</span>, the function pointed by
      this variable will be called each time an OP is freed with the
      corresponding OP as the argument. This allows extensions to free any extra
      attribute they have locally attached to an OP. It is also assured to first
      fire for the parent OP and then for its kids.
    <p class="Pp">When you replace this variable, it is considered a good
        practice to store the possibly previously installed hook and that you
        recall it inside your own.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        Perl_ophook_t   PL_opfreehook
    </pre>
  </dd>
  <dt>PL_peepp</dt>
  <dd>Pointer to the per-subroutine peephole optimiser. This is a function that
      gets called at the end of compilation of a Perl subroutine (or
      equivalently independent piece of Perl code) to perform fixups of some ops
      and to perform small-scale optimisations. The function is called once for
      each subroutine that is compiled, and is passed, as sole parameter, a
      pointer to the op that is the entry point to the subroutine. It modifies
      the op tree in place.
    <p class="Pp">The peephole optimiser should never be completely replaced.
        Rather, add code to it by wrapping the existing optimiser. The basic way
        to do this can be seen in &quot;Compile pass 3: peephole
        optimization&quot; in perlguts. If the new code wishes to operate on ops
        throughout the subroutine's structure, rather than just at the top
        level, it is likely to be more convenient to wrap the
        &quot;PL_rpeepp&quot; hook.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        peep_t  PL_peepp
    </pre>
  </dd>
  <dt>PL_rpeepp</dt>
  <dd>Pointer to the recursive peephole optimiser. This is a function that gets
      called at the end of compilation of a Perl subroutine (or equivalently
      independent piece of Perl code) to perform fixups of some ops and to
      perform small-scale optimisations. The function is called once for each
      chain of ops linked through their
      <span class="Li">&quot;op_next&quot;</span> fields; it is recursively
      called to handle each side chain. It is passed, as sole parameter, a
      pointer to the op that is at the head of the chain. It modifies the op
      tree in place.
    <p class="Pp">The peephole optimiser should never be completely replaced.
        Rather, add code to it by wrapping the existing optimiser. The basic way
        to do this can be seen in &quot;Compile pass 3: peephole
        optimization&quot; in perlguts. If the new code wishes to operate only
        on ops at a subroutine's top level, rather than throughout the
        structure, it is likely to be more convenient to wrap the
        &quot;PL_peepp&quot; hook.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        peep_t  PL_rpeepp
    </pre>
  </dd>
  <dt>PL_sv_no</dt>
  <dd>This is the <span class="Li">&quot;false&quot;</span> SV. See
      <span class="Li">&quot;PL_sv_yes&quot;</span>. Always refer to this as
      <span class="Li">&amp;PL_sv_no</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV      PL_sv_no
    </pre>
  </dd>
  <dt>PL_sv_undef</dt>
  <dd>This is the <span class="Li">&quot;undef&quot;</span> SV. Always refer to
      this as <span class="Li">&amp;PL_sv_undef</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV      PL_sv_undef
    </pre>
  </dd>
  <dt>PL_sv_yes</dt>
  <dd>This is the <span class="Li">&quot;true&quot;</span> SV. See
      <span class="Li">&quot;PL_sv_no&quot;</span>. Always refer to this as
      <span class="Li">&amp;PL_sv_yes</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV      PL_sv_yes
    </pre>
  </dd>
  <dt>PL_sv_zero</dt>
  <dd>This readonly SV has a zero numeric value and a
      <span class="Li">&quot;0&quot;</span> string value. It's similar to
      <span class="Li">&quot;PL_sv_no&quot;</span> except for its string value.
      Can be used as a cheap alternative to <span class="Li">mXPUSHi(0)</span>
      for example. Always refer to this as
      <span class="Li">&amp;PL_sv_zero</span>. Introduced in 5.28.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV      PL_sv_zero
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="REGEXP_Functions"><a class="permalink" href="#REGEXP_Functions">REGEXP
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>SvRX</dt>
  <dd>Convenience macro to get the REGEXP from a SV. This is approximately
      equivalent to the following snippet:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    if (SvMAGICAL(sv))
        mg_get(sv);
    if (SvROK(sv))
        sv = MUTABLE_SV(SvRV(sv));
    if (SvTYPE(sv) == SVt_REGEXP)
        return (REGEXP*) sv;
    </pre>
    <p class="Pp"><span class="Li">&quot;NULL&quot;</span> will be returned if a
        REGEXP* is not found.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        REGEXP * SvRX(SV *sv)
    </pre>
  </dd>
  <dt>SvRXOK</dt>
  <dd>Returns a boolean indicating whether the SV (or the one it references) is
      a REGEXP.
    <p class="Pp">If you want to do something with the REGEXP* later use SvRX
        instead and check for NULL.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvRXOK(SV* sv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Stack_Manipulation_Macros"><a class="permalink" href="#Stack_Manipulation_Macros">Stack
  Manipulation Macros</a></h1>
<dl class="Bl-tag">
  <dt>dMARK</dt>
  <dd>Declare a stack marker variable, <span class="Li">&quot;mark&quot;</span>,
      for the XSUB. See <span class="Li">&quot;MARK&quot;</span> and
      <span class="Li">&quot;dORIGMARK&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dMARK;
    </pre>
  </dd>
  <dt>dORIGMARK</dt>
  <dd>Saves the original stack mark for the XSUB. See
      <span class="Li">&quot;ORIGMARK&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dORIGMARK;
    </pre>
  </dd>
  <dt>dSP</dt>
  <dd>Declares a local copy of perl's stack pointer for the XSUB, available via
      the <span class="Li">&quot;SP&quot;</span> macro. See
      <span class="Li">&quot;SP&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                dSP;
    </pre>
  </dd>
  <dt>EXTEND</dt>
  <dd>Used to extend the argument stack for an XSUB's return values. Once used,
      guarantees that there is room for at least
      <span class="Li">&quot;nitems&quot;</span> to be pushed onto the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    EXTEND(SP, SSize_t nitems)
    </pre>
  </dd>
  <dt>MARK</dt>
  <dd>Stack marker variable for the XSUB. See
      <span class="Li">&quot;dMARK&quot;</span>.</dd>
  <dt>mPUSHi</dt>
  <dd>Push an integer onto the stack. The stack must have room for this element.
      Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHi&quot;</span>,
      <span class="Li">&quot;mXPUSHi&quot;</span> and
      <span class="Li">&quot;XPUSHi&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mPUSHi(IV iv)
    </pre>
  </dd>
  <dt>mPUSHn</dt>
  <dd>Push a double onto the stack. The stack must have room for this element.
      Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHn&quot;</span>,
      <span class="Li">&quot;mXPUSHn&quot;</span> and
      <span class="Li">&quot;XPUSHn&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mPUSHn(NV nv)
    </pre>
  </dd>
  <dt>mPUSHp</dt>
  <dd>Push a string onto the stack. The stack must have room for this element.
      The <span class="Li">&quot;len&quot;</span> indicates the length of the
      string. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHp&quot;</span>,
      <span class="Li">&quot;mXPUSHp&quot;</span> and
      <span class="Li">&quot;XPUSHp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mPUSHp(char* str, STRLEN len)
    </pre>
  </dd>
  <dt>mPUSHs</dt>
  <dd>Push an SV onto the stack and mortalizes the SV. The stack must have room
      for this element. Does not use <span class="Li">&quot;TARG&quot;</span>.
      See also <span class="Li">&quot;PUSHs&quot;</span> and
      <span class="Li">&quot;mXPUSHs&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mPUSHs(SV* sv)
    </pre>
  </dd>
  <dt>mPUSHu</dt>
  <dd>Push an unsigned integer onto the stack. The stack must have room for this
      element. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHu&quot;</span>,
      <span class="Li">&quot;mXPUSHu&quot;</span> and
      <span class="Li">&quot;XPUSHu&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mPUSHu(UV uv)
    </pre>
  </dd>
  <dt>mXPUSHi</dt>
  <dd>Push an integer onto the stack, extending the stack if necessary. Does not
      use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHi&quot;</span>,
      <span class="Li">&quot;mPUSHi&quot;</span> and
      <span class="Li">&quot;PUSHi&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mXPUSHi(IV iv)
    </pre>
  </dd>
  <dt>mXPUSHn</dt>
  <dd>Push a double onto the stack, extending the stack if necessary. Does not
      use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHn&quot;</span>,
      <span class="Li">&quot;mPUSHn&quot;</span> and
      <span class="Li">&quot;PUSHn&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mXPUSHn(NV nv)
    </pre>
  </dd>
  <dt>mXPUSHp</dt>
  <dd>Push a string onto the stack, extending the stack if necessary. The
      <span class="Li">&quot;len&quot;</span> indicates the length of the
      string. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHp&quot;</span>,
      <span class="Li">&quot;mPUSHp&quot;</span> and
      <span class="Li">&quot;PUSHp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mXPUSHp(char* str, STRLEN len)
    </pre>
  </dd>
  <dt>mXPUSHs</dt>
  <dd>Push an SV onto the stack, extending the stack if necessary and mortalizes
      the SV. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHs&quot;</span> and
      <span class="Li">&quot;mPUSHs&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mXPUSHs(SV* sv)
    </pre>
  </dd>
  <dt>mXPUSHu</dt>
  <dd>Push an unsigned integer onto the stack, extending the stack if necessary.
      Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHu&quot;</span>,
      <span class="Li">&quot;mPUSHu&quot;</span> and
      <span class="Li">&quot;PUSHu&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mXPUSHu(UV uv)
    </pre>
  </dd>
  <dt>ORIGMARK</dt>
  <dd>The original stack mark for the XSUB. See
      <span class="Li">&quot;dORIGMARK&quot;</span>.</dd>
  <dt>POPi</dt>
  <dd>Pops an integer off the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      POPi
    </pre>
  </dd>
  <dt>POPl</dt>
  <dd>Pops a long off the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        long    POPl
    </pre>
  </dd>
  <dt>POPn</dt>
  <dd>Pops a double off the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      POPn
    </pre>
  </dd>
  <dt>POPp</dt>
  <dd>Pops a string off the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   POPp
    </pre>
  </dd>
  <dt>POPpbytex</dt>
  <dd>Pops a string off the stack which must consist of bytes i.e. characters
      &lt; 256.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   POPpbytex
    </pre>
  </dd>
  <dt>POPpx</dt>
  <dd>Pops a string off the stack. Identical to POPp. There are two names for
      historical reasons.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   POPpx
    </pre>
  </dd>
  <dt>POPs</dt>
  <dd>Pops an SV off the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     POPs
    </pre>
  </dd>
  <dt>POPu</dt>
  <dd>Pops an unsigned integer off the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      POPu
    </pre>
  </dd>
  <dt>POPul</dt>
  <dd>Pops an unsigned long off the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        long    POPul
    </pre>
  </dd>
  <dt>PUSHi</dt>
  <dd>Push an integer onto the stack. The stack must have room for this element.
      Handles 'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mPUSHi&quot;</span> instead. See also
      <span class="Li">&quot;XPUSHi&quot;</span> and
      <span class="Li">&quot;mXPUSHi&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHi(IV iv)
    </pre>
  </dd>
  <dt>PUSHMARK</dt>
  <dd>Opening bracket for arguments on a callback. See
      <span class="Li">&quot;PUTBACK&quot;</span> and perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHMARK(SP)
    </pre>
  </dd>
  <dt>PUSHmortal</dt>
  <dd>Push a new mortal SV onto the stack. The stack must have room for this
      element. Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHs&quot;</span>,
      <span class="Li">&quot;XPUSHmortal&quot;</span> and
      <span class="Li">&quot;XPUSHs&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHmortal()
    </pre>
  </dd>
  <dt>PUSHn</dt>
  <dd>Push a double onto the stack. The stack must have room for this element.
      Handles 'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mPUSHn&quot;</span> instead. See also
      <span class="Li">&quot;XPUSHn&quot;</span> and
      <span class="Li">&quot;mXPUSHn&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHn(NV nv)
    </pre>
  </dd>
  <dt>PUSHp</dt>
  <dd>Push a string onto the stack. The stack must have room for this element.
      The <span class="Li">&quot;len&quot;</span> indicates the length of the
      string. Handles 'set' magic. Uses
      <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mPUSHp&quot;</span> instead. See also
      <span class="Li">&quot;XPUSHp&quot;</span> and
      <span class="Li">&quot;mXPUSHp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHp(char* str, STRLEN len)
    </pre>
  </dd>
  <dt>PUSHs</dt>
  <dd>Push an SV onto the stack. The stack must have room for this element. Does
      not handle 'set' magic. Does not use
      <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;PUSHmortal&quot;</span>,
      <span class="Li">&quot;XPUSHs&quot;</span>, and
      <span class="Li">&quot;XPUSHmortal&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHs(SV* sv)
    </pre>
  </dd>
  <dt>PUSHu</dt>
  <dd>Push an unsigned integer onto the stack. The stack must have room for this
      element. Handles 'set' magic. Uses
      <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mPUSHu&quot;</span> instead. See also
      <span class="Li">&quot;XPUSHu&quot;</span> and
      <span class="Li">&quot;mXPUSHu&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PUSHu(UV uv)
    </pre>
  </dd>
  <dt>PUTBACK</dt>
  <dd>Closing bracket for XSUB arguments. This is usually handled by
      <span class="Li">&quot;xsubpp&quot;</span>. See
      <span class="Li">&quot;PUSHMARK&quot;</span> and perlcall for other uses.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                PUTBACK;
    </pre>
  </dd>
  <dt>SP</dt>
  <dd>Stack pointer. This is usually handled by
      <span class="Li">&quot;xsubpp&quot;</span>. See
      <span class="Li">&quot;dSP&quot;</span> and
      <span class="Li">&quot;SPAGAIN&quot;</span>.</dd>
  <dt>SPAGAIN</dt>
  <dd>Refetch the stack pointer. Used after a callback. See perlcall.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                SPAGAIN;
    </pre>
  </dd>
  <dt>XPUSHi</dt>
  <dd>Push an integer onto the stack, extending the stack if necessary. Handles
      'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mXPUSHi&quot;</span> instead. See also
      <span class="Li">&quot;PUSHi&quot;</span> and
      <span class="Li">&quot;mPUSHi&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XPUSHi(IV iv)
    </pre>
  </dd>
  <dt>XPUSHmortal</dt>
  <dd>Push a new mortal SV onto the stack, extending the stack if necessary.
      Does not use <span class="Li">&quot;TARG&quot;</span>. See also
      <span class="Li">&quot;XPUSHs&quot;</span>,
      <span class="Li">&quot;PUSHmortal&quot;</span> and
      <span class="Li">&quot;PUSHs&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XPUSHmortal()
    </pre>
  </dd>
  <dt>XPUSHn</dt>
  <dd>Push a double onto the stack, extending the stack if necessary. Handles
      'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mXPUSHn&quot;</span> instead. See also
      <span class="Li">&quot;PUSHn&quot;</span> and
      <span class="Li">&quot;mPUSHn&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XPUSHn(NV nv)
    </pre>
  </dd>
  <dt>XPUSHp</dt>
  <dd>Push a string onto the stack, extending the stack if necessary. The
      <span class="Li">&quot;len&quot;</span> indicates the length of the
      string. Handles 'set' magic. Uses
      <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mXPUSHp&quot;</span> instead. See also
      <span class="Li">&quot;PUSHp&quot;</span> and
      <span class="Li">&quot;mPUSHp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XPUSHp(char* str, STRLEN len)
    </pre>
  </dd>
  <dt>XPUSHs</dt>
  <dd>Push an SV onto the stack, extending the stack if necessary. Does not
      handle 'set' magic. Does not use <span class="Li">&quot;TARG&quot;</span>.
      See also <span class="Li">&quot;XPUSHmortal&quot;</span>,
      <span class="Li">&quot;PUSHs&quot;</span> and
      <span class="Li">&quot;PUSHmortal&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XPUSHs(SV* sv)
    </pre>
  </dd>
  <dt>XPUSHu</dt>
  <dd>Push an unsigned integer onto the stack, extending the stack if necessary.
      Handles 'set' magic. Uses <span class="Li">&quot;TARG&quot;</span>, so
      <span class="Li">&quot;dTARGET&quot;</span> or
      <span class="Li">&quot;dXSTARG&quot;</span> should be called to declare
      it. Do not call multiple <span class="Li">&quot;TARG&quot;</span>-oriented
      macros to return lists from XSUB's - see
      <span class="Li">&quot;mXPUSHu&quot;</span> instead. See also
      <span class="Li">&quot;PUSHu&quot;</span> and
      <span class="Li">&quot;mPUSHu&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XPUSHu(UV uv)
    </pre>
  </dd>
  <dt>XSRETURN</dt>
  <dd>Return from XSUB, indicating number of items on the stack. This is usually
      handled by <span class="Li">&quot;xsubpp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XSRETURN(int nitems)
    </pre>
  </dd>
  <dt>XSRETURN_EMPTY</dt>
  <dd>Return an empty list from an XSUB immediately.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XSRETURN_EMPTY;
    </pre>
  </dd>
  <dt>XSRETURN_IV</dt>
  <dd>Return an integer from an XSUB immediately. Uses
      <span class="Li">&quot;XST_mIV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XSRETURN_IV(IV iv)
    </pre>
  </dd>
  <dt>XSRETURN_NO</dt>
  <dd>Return <span class="Li">&amp;PL_sv_no</span> from an XSUB immediately.
      Uses <span class="Li">&quot;XST_mNO&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XSRETURN_NO;
    </pre>
  </dd>
  <dt>XSRETURN_NV</dt>
  <dd>Return a double from an XSUB immediately. Uses
      <span class="Li">&quot;XST_mNV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XSRETURN_NV(NV nv)
    </pre>
  </dd>
  <dt>XSRETURN_PV</dt>
  <dd>Return a copy of a string from an XSUB immediately. Uses
      <span class="Li">&quot;XST_mPV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XSRETURN_PV(char* str)
    </pre>
  </dd>
  <dt>XSRETURN_UNDEF</dt>
  <dd>Return <span class="Li">&amp;PL_sv_undef</span> from an XSUB immediately.
      Uses <span class="Li">&quot;XST_mUNDEF&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XSRETURN_UNDEF;
    </pre>
  </dd>
  <dt>XSRETURN_UV</dt>
  <dd>Return an integer from an XSUB immediately. Uses
      <span class="Li">&quot;XST_mUV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XSRETURN_UV(IV uv)
    </pre>
  </dd>
  <dt>XSRETURN_YES</dt>
  <dd>Return <span class="Li">&amp;PL_sv_yes</span> from an XSUB immediately.
      Uses <span class="Li">&quot;XST_mYES&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XSRETURN_YES;
    </pre>
  </dd>
  <dt>XST_mIV</dt>
  <dd>Place an integer into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack. The value is stored
      in a new mortal SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XST_mIV(int pos, IV iv)
    </pre>
  </dd>
  <dt>XST_mNO</dt>
  <dd>Place <span class="Li">&amp;PL_sv_no</span> into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XST_mNO(int pos)
    </pre>
  </dd>
  <dt>XST_mNV</dt>
  <dd>Place a double into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack. The value is stored
      in a new mortal SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XST_mNV(int pos, NV nv)
    </pre>
  </dd>
  <dt>XST_mPV</dt>
  <dd>Place a copy of a string into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack. The value is stored
      in a new mortal SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XST_mPV(int pos, char* str)
    </pre>
  </dd>
  <dt>XST_mUNDEF</dt>
  <dd>Place <span class="Li">&amp;PL_sv_undef</span> into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XST_mUNDEF(int pos)
    </pre>
  </dd>
  <dt>XST_mYES</dt>
  <dd>Place <span class="Li">&amp;PL_sv_yes</span> into the specified position
      <span class="Li">&quot;pos&quot;</span> on the stack.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    XST_mYES(int pos)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SV_Flags"><a class="permalink" href="#SV_Flags">SV
  Flags</a></h1>
<dl class="Bl-tag">
  <dt>SVt_INVLIST</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_IV</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_NULL</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_NV</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_PV</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVAV</dt>
  <dd>Type flag for arrays. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVCV</dt>
  <dd>Type flag for subroutines. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVFM</dt>
  <dd>Type flag for formats. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVGV</dt>
  <dd>Type flag for typeglobs. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVHV</dt>
  <dd>Type flag for hashes. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVIO</dt>
  <dd>Type flag for I/O objects. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVIV</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVLV</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVMG</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_PVNV</dt>
  <dd>Type flag for scalars. See &quot;svtype&quot;.</dd>
  <dt>SVt_REGEXP</dt>
  <dd>Type flag for regular expressions. See &quot;svtype&quot;.</dd>
  <dt>svtype</dt>
  <dd>An enum of flags for Perl types. These are found in the file <i>sv.h</i>
      in the <span class="Li">&quot;svtype&quot;</span> enum. Test these flags
      with the <span class="Li">&quot;SvTYPE&quot;</span> macro.
    <p class="Pp">The types are:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    SVt_NULL
    SVt_IV
    SVt_NV
    SVt_RV
    SVt_PV
    SVt_PVIV
    SVt_PVNV
    SVt_PVMG
    SVt_INVLIST
    SVt_REGEXP
    SVt_PVGV
    SVt_PVLV
    SVt_PVAV
    SVt_PVHV
    SVt_PVCV
    SVt_PVFM
    SVt_PVIO
    </pre>
    <p class="Pp">These are most easily explained from the bottom up.</p>
    <p class="Pp"><span class="Li">&quot;SVt_PVIO&quot;</span> is for I/O
        objects, <span class="Li">&quot;SVt_PVFM&quot;</span> for formats,
        <span class="Li">&quot;SVt_PVCV&quot;</span> for subroutines,
        <span class="Li">&quot;SVt_PVHV&quot;</span> for hashes and
        <span class="Li">&quot;SVt_PVAV&quot;</span> for arrays.</p>
    <p class="Pp">All the others are scalar types, that is, things that can be
        bound to a <span class="Li">&quot;$&quot;</span> variable. For these,
        the internal types are mostly orthogonal to types in the Perl
      language.</p>
    <p class="Pp">Hence, checking <span class="Li">&quot;SvTYPE(sv) &lt;
        SVt_PVAV&quot;</span> is the best way to see whether something is a
        scalar.</p>
    <p class="Pp"><span class="Li">&quot;SVt_PVGV&quot;</span> represents a
        typeglob. If <span class="Li">&quot;!SvFAKE(sv)&quot;</span>, then it is
        a real, incoercible typeglob. If
        <span class="Li">&quot;SvFAKE(sv)&quot;</span>, then it is a scalar to
        which a typeglob has been assigned. Assigning to it again will stop it
        from being a typeglob. <span class="Li">&quot;SVt_PVLV&quot;</span>
        represents a scalar that delegates to another scalar behind the scenes.
        It is used, e.g., for the return value of
        <span class="Li">&quot;substr&quot;</span> and for tied hash and array
        elements. It can hold any scalar value, including a typeglob.
        <span class="Li">&quot;SVt_REGEXP&quot;</span> is for regular
        expressions. <span class="Li">&quot;SVt_INVLIST&quot;</span> is for Perl
        core internal use only.</p>
    <p class="Pp"><span class="Li">&quot;SVt_PVMG&quot;</span> represents a
        &quot;normal&quot; scalar (not a typeglob, regular expression, or
        delegate). Since most scalars do not need all the internal fields of a
        PVMG, we save memory by allocating smaller structs when possible. All
        the other types are just simpler forms of
        <span class="Li">&quot;SVt_PVMG&quot;</span>, with fewer internal
        fields. <span class="Li">&quot;SVt_NULL&quot;</span> can only hold
        undef. <span class="Li">&quot;SVt_IV&quot;</span> can hold undef, an
        integer, or a reference. (<span class="Li">&quot;SVt_RV&quot;</span> is
        an alias for <span class="Li">&quot;SVt_IV&quot;</span>, which exists
        for backward compatibility.) <span class="Li">&quot;SVt_NV&quot;</span>
        can hold any of those or a double.
        <span class="Li">&quot;SVt_PV&quot;</span> can only hold
        <span class="Li">&quot;undef&quot;</span> or a string.
        <span class="Li">&quot;SVt_PVIV&quot;</span> is a superset of
        <span class="Li">&quot;SVt_PV&quot;</span> and
        <span class="Li">&quot;SVt_IV&quot;</span>.
        <span class="Li">&quot;SVt_PVNV&quot;</span> is similar.
        <span class="Li">&quot;SVt_PVMG&quot;</span> can hold anything
        <span class="Li">&quot;SVt_PVNV&quot;</span> can hold, but it can, but
        does not have to, be blessed or magical.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SV_Manipulation_Functions"><a class="permalink" href="#SV_Manipulation_Functions">SV
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>boolSV</dt>
  <dd>Returns a true SV if <span class="Li">&quot;b&quot;</span> is a true
      value, or a false SV if <span class="Li">&quot;b&quot;</span> is 0.
    <p class="Pp">See also <span class="Li">&quot;PL_sv_yes&quot;</span> and
        <span class="Li">&quot;PL_sv_no&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    boolSV(bool b)
    </pre>
  </dd>
  <dt>croak_xs_usage</dt>
  <dd>A specialised variant of <span class="Li">&quot;croak()&quot;</span> for
      emitting the usage message for xsubs
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    croak_xs_usage(cv, &quot;eee_yow&quot;);
    </pre>
    <p class="Pp">works out the package name and subroutine name from
        <span class="Li">&quot;cv&quot;</span>, and then calls
        <span class="Li">&quot;croak()&quot;</span>. Hence if
        <span class="Li">&quot;cv&quot;</span> is
        <span class="Li">&amp;ouch::awk</span>, it would call
        <span class="Li">&quot;croak&quot;</span> as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 Perl_croak(aTHX_ &quot;Usage: %&quot; SVf &quot;::%&quot; SVf &quot;(%s)&quot;, &quot;ouch&quot; &quot;awk&quot;,
                                                     &quot;eee_yow&quot;);

        void    croak_xs_usage(const CV *const cv,
                               const char *const params)
    </pre>
  </dd>
  <dt>get_sv</dt>
  <dd>Returns the SV of the specified Perl scalar.
      <span class="Li">&quot;flags&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchpv&quot;</span>. If
      <span class="Li">&quot;GV_ADD&quot;</span> is set and the Perl variable
      does not exist then it will be created. If
      <span class="Li">&quot;flags&quot;</span> is zero and the variable does
      not exist then NULL is returned.
    <p class="Pp">NOTE: the perl_ form of this function is deprecated.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     get_sv(const char *name, I32 flags)
    </pre>
  </dd>
  <dt>looks_like_number</dt>
  <dd>Test if the content of an SV looks like a number (or is a number).
      <span class="Li">&quot;Inf&quot;</span> and
      <span class="Li">&quot;Infinity&quot;</span> are treated as numbers (so
      will not issue a non-numeric warning), even if your
      <span class="Li">&quot;atof()&quot;</span> doesn't grok them. Get-magic is
      ignored.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     looks_like_number(SV *const sv)
    </pre>
  </dd>
  <dt>newRV_inc</dt>
  <dd>Creates an RV wrapper for an SV. The reference count for the original SV
      is incremented.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newRV_inc(SV* sv)
    </pre>
  </dd>
  <dt>newRV_noinc</dt>
  <dd>Creates an RV wrapper for an SV. The reference count for the original SV
      is <b>not</b> incremented.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newRV_noinc(SV *const tmpRef)
    </pre>
  </dd>
  <dt>newSV</dt>
  <dd>Creates a new SV. A non-zero <span class="Li">&quot;len&quot;</span>
      parameter indicates the number of bytes of preallocated string space the
      SV should have. An extra byte for a trailing
      <span class="Li">&quot;NUL&quot;</span> is also reserved.
      (<span class="Li">&quot;SvPOK&quot;</span> is not set for the SV even if
      string space is allocated.) The reference count for the new SV is set to
      1.
    <p class="Pp">In 5.9.3, <span class="Li">&quot;newSV()&quot;</span> replaces
        the older <span class="Li">&quot;NEWSV()&quot;</span> API, and drops the
        first parameter, <i>x</i>, a debug aid which allowed callers to identify
        themselves. This aid has been superseded by a new build option,
        <span class="Li">&quot;PERL_MEM_LOG&quot;</span> (see
        &quot;PERL_MEM_LOG&quot; in perlhacktips). The older API is still there
        for use in XS modules supporting older perls.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSV(const STRLEN len)
    </pre>
  </dd>
  <dt>newSVhek</dt>
  <dd>Creates a new SV from the hash key structure. It will generate scalars
      that point to the shared string table where possible. Returns a new
      (undefined) SV if <span class="Li">&quot;hek&quot;</span> is NULL.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVhek(const HEK *const hek)
    </pre>
  </dd>
  <dt>newSViv</dt>
  <dd>Creates a new SV and copies an integer into it. The reference count for
      the SV is set to 1.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSViv(const IV i)
    </pre>
  </dd>
  <dt>newSVnv</dt>
  <dd>Creates a new SV and copies a floating point value into it. The reference
      count for the SV is set to 1.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVnv(const NV n)
    </pre>
  </dd>
  <dt>newSVpadname</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Creates a new SV containing the pad name.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpadname(PADNAME *pn)
    </pre>
  </dd>
  <dt>newSVpv</dt>
  <dd>Creates a new SV and copies a string (which may contain
      <span class="Li">&quot;NUL&quot;</span>
      (<span class="Li">&quot;\0&quot;</span>) characters) into it. The
      reference count for the SV is set to 1. If
      <span class="Li">&quot;len&quot;</span> is zero, Perl will compute the
      length using <span class="Li">&quot;strlen()&quot;</span>, (which means if
      you use this option, that <span class="Li">&quot;s&quot;</span> can't have
      embedded <span class="Li">&quot;NUL&quot;</span> characters and has to
      have a terminating <span class="Li">&quot;NUL&quot;</span> byte).
    <p class="Pp">This function can cause reliability issues if you are likely
        to pass in empty strings that are not null terminated, because it will
        run strlen on the string and potentially run past valid memory.</p>
    <p class="Pp">Using &quot;newSVpvn&quot; is a safer alternative for non
        <span class="Li">&quot;NUL&quot;</span> terminated strings. For string
        literals use &quot;newSVpvs&quot; instead. This function will work fine
        for <span class="Li">&quot;NUL&quot;</span> terminated strings, but if
        you want to avoid the if statement on whether to call
        <span class="Li">&quot;strlen&quot;</span> use
        <span class="Li">&quot;newSVpvn&quot;</span> instead (calling
        <span class="Li">&quot;strlen&quot;</span> yourself).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpv(const char *const s, const STRLEN len)
    </pre>
  </dd>
  <dt>newSVpvf</dt>
  <dd>Creates a new SV and initializes it with the string formatted like
      <span class="Li">&quot;sv_catpvf&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvf(const char *const pat, ...)
    </pre>
  </dd>
  <dt>newSVpvn</dt>
  <dd>Creates a new SV and copies a string into it, which may contain
      <span class="Li">&quot;NUL&quot;</span> characters
      (<span class="Li">&quot;\0&quot;</span>) and other binary data. The
      reference count for the SV is set to 1. Note that if
      <span class="Li">&quot;len&quot;</span> is zero, Perl will create a zero
      length (Perl) string. You are responsible for ensuring that the source
      buffer is at least <span class="Li">&quot;len&quot;</span> bytes long. If
      the <span class="Li">&quot;buffer&quot;</span> argument is NULL the new SV
      will be undefined.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvn(const char *const buffer,
                         const STRLEN len)
    </pre>
  </dd>
  <dt>newSVpvn_flags</dt>
  <dd>Creates a new SV and copies a string (which may contain
      <span class="Li">&quot;NUL&quot;</span>
      (<span class="Li">&quot;\0&quot;</span>) characters) into it. The
      reference count for the SV is set to 1. Note that if
      <span class="Li">&quot;len&quot;</span> is zero, Perl will create a zero
      length string. You are responsible for ensuring that the source string is
      at least <span class="Li">&quot;len&quot;</span> bytes long. If the
      <span class="Li">&quot;s&quot;</span> argument is NULL the new SV will be
      undefined. Currently the only flag bits accepted are
      <span class="Li">&quot;SVf_UTF8&quot;</span> and
      <span class="Li">&quot;SVs_TEMP&quot;</span>. If
      <span class="Li">&quot;SVs_TEMP&quot;</span> is set, then
      <span class="Li">&quot;sv_2mortal()&quot;</span> is called on the result
      before returning. If <span class="Li">&quot;SVf_UTF8&quot;</span> is set,
      <span class="Li">&quot;s&quot;</span> is considered to be in UTF-8 and the
      <span class="Li">&quot;SVf_UTF8&quot;</span> flag will be set on the new
      SV. <span class="Li">&quot;newSVpvn_utf8()&quot;</span> is a convenience
      wrapper for this function, defined as
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    #define newSVpvn_utf8(s, len, u)                    \
        newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)

        SV*     newSVpvn_flags(const char *const s,
                               const STRLEN len,
                               const U32 flags)
    </pre>
  </dd>
  <dt>newSVpvn_share</dt>
  <dd>Creates a new SV with its <span class="Li">&quot;SvPVX_const&quot;</span>
      pointing to a shared string in the string table. If the string does not
      already exist in the table, it is created first. Turns on the
      <span class="Li">&quot;SvIsCOW&quot;</span> flag (or
      <span class="Li">&quot;READONLY&quot;</span> and
      <span class="Li">&quot;FAKE&quot;</span> in 5.16 and earlier). If the
      <span class="Li">&quot;hash&quot;</span> parameter is non-zero, that value
      is used; otherwise the hash is computed. The string's hash can later be
      retrieved from the SV with the
      <span class="Li">&quot;SvSHARED_HASH()&quot;</span> macro. The idea here
      is that as the string table is used for shared hash keys these strings
      will have <span class="Li">&quot;SvPVX_const == HeKEY&quot;</span> and
      hash lookup will avoid string compare.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvn_share(const char* s, I32 len, U32 hash)
    </pre>
  </dd>
  <dt>newSVpvn_utf8</dt>
  <dd>Creates a new SV and copies a string (which may contain
      <span class="Li">&quot;NUL&quot;</span>
      (<span class="Li">&quot;\0&quot;</span>) characters) into it. If
      <span class="Li">&quot;utf8&quot;</span> is true, calls
      <span class="Li">&quot;SvUTF8_on&quot;</span> on the new SV. Implemented
      as a wrapper around <span class="Li">&quot;newSVpvn_flags&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvn_utf8(const char* s, STRLEN len,
                              U32 utf8)
    </pre>
  </dd>
  <dt>newSVpvs</dt>
  <dd>Like <span class="Li">&quot;newSVpvn&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvs(&quot;literal string&quot; s)
    </pre>
  </dd>
  <dt>newSVpvs_flags</dt>
  <dd>Like <span class="Li">&quot;newSVpvn_flags&quot;</span>, but takes a
      literal string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvs_flags(&quot;literal string&quot; s, U32 flags)
    </pre>
  </dd>
  <dt>newSVpv_share</dt>
  <dd>Like <span class="Li">&quot;newSVpvn_share&quot;</span>, but takes a
      <span class="Li">&quot;NUL&quot;</span>-terminated string instead of a
      string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpv_share(const char* s, U32 hash)
    </pre>
  </dd>
  <dt>newSVpvs_share</dt>
  <dd>Like <span class="Li">&quot;newSVpvn_share&quot;</span>, but takes a
      literal string instead of a string/length pair and omits the hash
      parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVpvs_share(&quot;literal string&quot; s)
    </pre>
  </dd>
  <dt>newSVrv</dt>
  <dd>Creates a new SV for the existing RV,
      <span class="Li">&quot;rv&quot;</span>, to point to. If
      <span class="Li">&quot;rv&quot;</span> is not an RV then it will be
      upgraded to one. If <span class="Li">&quot;classname&quot;</span> is
      non-null then the new SV will be blessed in the specified package. The new
      SV is returned and its reference count is 1. The reference count 1 is
      owned by <span class="Li">&quot;rv&quot;</span>. See also
      <b>newRV_inc()</b> and <b>newRV_noinc()</b> for creating a new RV
      properly.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVrv(SV *const rv,
                        const char *const classname)
    </pre>
  </dd>
  <dt>newSVsv</dt>
  <dd>Creates a new SV which is an exact duplicate of the original SV. (Uses
      <span class="Li">&quot;sv_setsv&quot;</span>.)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVsv(SV *const old)
    </pre>
  </dd>
  <dt>newSVsv_nomg</dt>
  <dd>Like <span class="Li">&quot;newSVsv&quot;</span> but does not process get
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVsv_nomg(SV *const old)
    </pre>
  </dd>
  <dt>newSV_type</dt>
  <dd>Creates a new SV, of the type specified. The reference count for the new
      SV is set to 1.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSV_type(const svtype type)
    </pre>
  </dd>
  <dt>newSVuv</dt>
  <dd>Creates a new SV and copies an unsigned integer into it. The reference
      count for the SV is set to 1.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     newSVuv(const UV u)
    </pre>
  </dd>
  <dt>sv_2bool</dt>
  <dd>This macro is only used by <span class="Li">&quot;sv_true()&quot;</span>
      or its macro equivalent, and only if the latter's argument is neither
      <span class="Li">&quot;SvPOK&quot;</span>,
      <span class="Li">&quot;SvIOK&quot;</span> nor
      <span class="Li">&quot;SvNOK&quot;</span>. It calls
      <span class="Li">&quot;sv_2bool_flags&quot;</span> with the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> flag.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_2bool(SV *const sv)
    </pre>
  </dd>
  <dt>sv_2bool_flags</dt>
  <dd>This function is only used by
      <span class="Li">&quot;sv_true()&quot;</span> and friends, and only if the
      latter's argument is neither <span class="Li">&quot;SvPOK&quot;</span>,
      <span class="Li">&quot;SvIOK&quot;</span> nor
      <span class="Li">&quot;SvNOK&quot;</span>. If the flags contain
      <span class="Li">&quot;SV_GMAGIC&quot;</span>, then it does an
      <span class="Li">&quot;mg_get()&quot;</span> first.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_2bool_flags(SV *sv, I32 flags)
    </pre>
  </dd>
  <dt>sv_2cv</dt>
  <dd>Using various gambits, try to get a CV from an SV; in addition, try if
      possible to set <span class="Li">*st</span> and
      <span class="Li">*gvp</span> to the stash and GV associated with it. The
      flags in <span class="Li">&quot;lref&quot;</span> are passed to
      <span class="Li">&quot;gv_fetchsv&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        CV*     sv_2cv(SV* sv, HV **const st, GV **const gvp,
                       const I32 lref)
    </pre>
  </dd>
  <dt>sv_2io</dt>
  <dd>Using various gambits, try to get an IO from an SV: the IO slot if its a
      GV; or the recursive result if we're an RV; or the IO slot of the symbol
      named after the PV if we're a string.
    <p class="Pp">'Get' magic is ignored on the
        <span class="Li">&quot;sv&quot;</span> passed in, but will be called on
        <span class="Li">&quot;SvRV(sv)&quot;</span> if
        <span class="Li">&quot;sv&quot;</span> is an RV.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IO*     sv_2io(SV *const sv)
    </pre>
  </dd>
  <dt>sv_2iv_flags</dt>
  <dd>Return the integer value of an SV, doing any necessary string conversion.
      If <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, does an
      <span class="Li">&quot;mg_get()&quot;</span> first. Normally used via the
      <span class="Li">&quot;SvIV(sv)&quot;</span> and
      <span class="Li">&quot;SvIVx(sv)&quot;</span> macros.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      sv_2iv_flags(SV *const sv, const I32 flags)
    </pre>
  </dd>
  <dt>sv_2mortal</dt>
  <dd>Marks an existing SV as mortal. The SV will be destroyed &quot;soon&quot;,
      either by an explicit call to
      <span class="Li">&quot;FREETMPS&quot;</span>, or by an implicit call at
      places such as statement boundaries.
      <span class="Li">&quot;SvTEMP()&quot;</span> is turned on which means that
      the SV's string buffer can be &quot;stolen&quot; if this SV is copied. See
      also <span class="Li">&quot;sv_newmortal&quot;</span> and
      <span class="Li">&quot;sv_mortalcopy&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_2mortal(SV *const sv)
    </pre>
  </dd>
  <dt>sv_2nv_flags</dt>
  <dd>Return the num value of an SV, doing any necessary string or integer
      conversion. If <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, does an
      <span class="Li">&quot;mg_get()&quot;</span> first. Normally used via the
      <span class="Li">&quot;SvNV(sv)&quot;</span> and
      <span class="Li">&quot;SvNVx(sv)&quot;</span> macros.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      sv_2nv_flags(SV *const sv, const I32 flags)
    </pre>
  </dd>
  <dt>sv_2pvbyte</dt>
  <dd>Return a pointer to the byte-encoded representation of the SV, and set
      <span class="Li">*lp</span> to its length. May cause the SV to be
      downgraded from UTF-8 as a side-effect.
    <p class="Pp">Usually accessed via the
        <span class="Li">&quot;SvPVbyte&quot;</span> macro.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_2pvbyte(SV *sv, STRLEN *const lp)
    </pre>
  </dd>
  <dt>sv_2pvutf8</dt>
  <dd>Return a pointer to the UTF-8-encoded representation of the SV, and set
      <span class="Li">*lp</span> to its length. May cause the SV to be upgraded
      to UTF-8 as a side-effect.
    <p class="Pp">Usually accessed via the
        <span class="Li">&quot;SvPVutf8&quot;</span> macro.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_2pvutf8(SV *sv, STRLEN *const lp)
    </pre>
  </dd>
  <dt>sv_2pv_flags</dt>
  <dd>Returns a pointer to the string value of an SV, and sets
      <span class="Li">*lp</span> to its length. If flags has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, does an
      <span class="Li">&quot;mg_get()&quot;</span> first. Coerces
      <span class="Li">&quot;sv&quot;</span> to a string if necessary. Normally
      invoked via the <span class="Li">&quot;SvPV_flags&quot;</span> macro.
      <span class="Li">&quot;sv_2pv()&quot;</span> and
      <span class="Li">&quot;sv_2pv_nomg&quot;</span> usually end up here too.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_2pv_flags(SV *const sv, STRLEN *const lp,
                             const I32 flags)
    </pre>
  </dd>
  <dt>sv_2uv_flags</dt>
  <dd>Return the unsigned integer value of an SV, doing any necessary string
      conversion. If <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, does an
      <span class="Li">&quot;mg_get()&quot;</span> first. Normally used via the
      <span class="Li">&quot;SvUV(sv)&quot;</span> and
      <span class="Li">&quot;SvUVx(sv)&quot;</span> macros.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      sv_2uv_flags(SV *const sv, const I32 flags)
    </pre>
  </dd>
  <dt>sv_backoff</dt>
  <dd>Remove any string offset. You should normally use the
      <span class="Li">&quot;SvOOK_off&quot;</span> macro wrapper instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_backoff(SV *const sv)
    </pre>
  </dd>
  <dt>sv_bless</dt>
  <dd>Blesses an SV into a specified package. The SV must be an RV. The package
      must be designated by its stash (see
      <span class="Li">&quot;gv_stashpv&quot;</span>). The reference count of
      the SV is unaffected.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_bless(SV *const sv, HV *const stash)
    </pre>
  </dd>
  <dt>sv_catpv</dt>
  <dd>Concatenates the <span class="Li">&quot;NUL&quot;</span>-terminated string
      onto the end of the string which is in the SV. If the SV has the UTF-8
      status set, then the bytes appended should be valid UTF-8. Handles 'get'
      magic, but not 'set' magic. See
      <span class="Li">&quot;sv_catpv_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpv(SV *const sv, const char* ptr)
    </pre>
  </dd>
  <dt>sv_catpvf</dt>
  <dd>Processes its arguments like <span class="Li">&quot;sprintf&quot;</span>,
      and appends the formatted output to an SV. As with
      <span class="Li">&quot;sv_vcatpvfn&quot;</span> called with a non-null
      C-style variable argument list, argument reordering is not supported. If
      the appended data contains &quot;wide&quot; characters (including, but not
      limited to, SVs with a UTF-8 PV formatted with <span class="Li">%s</span>,
      and characters &gt;255 formatted with <span class="Li">%c</span>), the
      original SV might get upgraded to UTF-8. Handles 'get' magic, but not
      'set' magic. See <span class="Li">&quot;sv_catpvf_mg&quot;</span>. If the
      original SV was UTF-8, the pattern should be valid UTF-8; if the original
      SV was bytes, the pattern should be too.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvf(SV *const sv, const char *const pat,
                          ...)
    </pre>
  </dd>
  <dt>sv_catpvf_mg</dt>
  <dd>Like <span class="Li">&quot;sv_catpvf&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvf_mg(SV *const sv,
                             const char *const pat, ...)
    </pre>
  </dd>
  <dt>sv_catpvn</dt>
  <dd>Concatenates the string onto the end of the string which is in the SV.
      <span class="Li">&quot;len&quot;</span> indicates number of bytes to copy.
      If the SV has the UTF-8 status set, then the bytes appended should be
      valid UTF-8. Handles 'get' magic, but not 'set' magic. See
      <span class="Li">&quot;sv_catpvn_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvn(SV *dsv, const char *sstr, STRLEN len)
    </pre>
  </dd>
  <dt>sv_catpvn_flags</dt>
  <dd>Concatenates the string onto the end of the string which is in the SV. The
      <span class="Li">&quot;len&quot;</span> indicates number of bytes to copy.
    <p class="Pp">By default, the string appended is assumed to be valid UTF-8
        if the SV has the UTF-8 status set, and a string of bytes otherwise. One
        can force the appended string to be interpreted as UTF-8 by supplying
        the <span class="Li">&quot;SV_CATUTF8&quot;</span> flag, and as bytes by
        supplying the <span class="Li">&quot;SV_CATBYTES&quot;</span> flag; the
        SV or the string appended will be upgraded to UTF-8 if necessary.</p>
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> has the
        <span class="Li">&quot;SV_SMAGIC&quot;</span> bit set, will
        <span class="Li">&quot;mg_set&quot;</span> on
        <span class="Li">&quot;dsv&quot;</span> afterwards if appropriate.
        <span class="Li">&quot;sv_catpvn&quot;</span> and
        <span class="Li">&quot;sv_catpvn_nomg&quot;</span> are implemented in
        terms of this function.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvn_flags(SV *const dstr,
                                const char *sstr,
                                const STRLEN len,
                                const I32 flags)
    </pre>
  </dd>
  <dt>sv_catpvn_nomg</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn&quot;</span> but doesn't process
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvn_nomg(SV* sv, const char* ptr,
                               STRLEN len)
    </pre>
  </dd>
  <dt>sv_catpvs</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvs(SV* sv, &quot;literal string&quot; s)
    </pre>
  </dd>
  <dt>sv_catpvs_flags</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn_flags&quot;</span>, but takes a
      literal string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvs_flags(SV* sv, &quot;literal string&quot; s,
                                I32 flags)
    </pre>
  </dd>
  <dt>sv_catpvs_mg</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn_mg&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvs_mg(SV* sv, &quot;literal string&quot; s)
    </pre>
  </dd>
  <dt>sv_catpvs_nomg</dt>
  <dd>Like <span class="Li">&quot;sv_catpvn_nomg&quot;</span>, but takes a
      literal string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpvs_nomg(SV* sv, &quot;literal string&quot; s)
    </pre>
  </dd>
  <dt>sv_catpv_flags</dt>
  <dd>Concatenates the <span class="Li">&quot;NUL&quot;</span>-terminated string
      onto the end of the string which is in the SV. If the SV has the UTF-8
      status set, then the bytes appended should be valid UTF-8. If
      <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_SMAGIC&quot;</span> bit set, will
      <span class="Li">&quot;mg_set&quot;</span> on the modified SV if
      appropriate.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpv_flags(SV *dstr, const char *sstr,
                               const I32 flags)
    </pre>
  </dd>
  <dt>sv_catpv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_catpv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpv_mg(SV *const sv, const char *const ptr)
    </pre>
  </dd>
  <dt>sv_catpv_nomg</dt>
  <dd>Like <span class="Li">&quot;sv_catpv&quot;</span> but doesn't process
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catpv_nomg(SV* sv, const char* ptr)
    </pre>
  </dd>
  <dt>sv_catsv</dt>
  <dd>Concatenates the string from SV <span class="Li">&quot;ssv&quot;</span>
      onto the end of the string in SV <span class="Li">&quot;dsv&quot;</span>.
      If <span class="Li">&quot;ssv&quot;</span> is null, does nothing;
      otherwise modifies only <span class="Li">&quot;dsv&quot;</span>. Handles
      'get' magic on both SVs, but no 'set' magic. See
      <span class="Li">&quot;sv_catsv_mg&quot;</span> and
      <span class="Li">&quot;sv_catsv_nomg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catsv(SV *dstr, SV *sstr)
    </pre>
  </dd>
  <dt>sv_catsv_flags</dt>
  <dd>Concatenates the string from SV <span class="Li">&quot;ssv&quot;</span>
      onto the end of the string in SV <span class="Li">&quot;dsv&quot;</span>.
      If <span class="Li">&quot;ssv&quot;</span> is null, does nothing;
      otherwise modifies only <span class="Li">&quot;dsv&quot;</span>. If
      <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, will call
      <span class="Li">&quot;mg_get&quot;</span> on both SVs if appropriate. If
      <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_SMAGIC&quot;</span> bit set,
      <span class="Li">&quot;mg_set&quot;</span> will be called on the modified
      SV afterward, if appropriate.
      <span class="Li">&quot;sv_catsv&quot;</span>,
      <span class="Li">&quot;sv_catsv_nomg&quot;</span>, and
      <span class="Li">&quot;sv_catsv_mg&quot;</span> are implemented in terms
      of this function.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catsv_flags(SV *const dsv, SV *const ssv,
                               const I32 flags)
    </pre>
  </dd>
  <dt>sv_catsv_nomg</dt>
  <dd>Like <span class="Li">&quot;sv_catsv&quot;</span> but doesn't process
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_catsv_nomg(SV* dsv, SV* ssv)
    </pre>
  </dd>
  <dt>sv_chop</dt>
  <dd>Efficient removal of characters from the beginning of the string buffer.
      <span class="Li">&quot;SvPOK(sv)&quot;</span>, or at least
      <span class="Li">&quot;SvPOKp(sv)&quot;</span>, must be true and
      <span class="Li">&quot;ptr&quot;</span> must be a pointer to somewhere
      inside the string buffer. <span class="Li">&quot;ptr&quot;</span> becomes
      the first character of the adjusted string. Uses the
      <span class="Li">&quot;OOK&quot;</span> hack. On return, only
      <span class="Li">&quot;SvPOK(sv)&quot;</span> and
      <span class="Li">&quot;SvPOKp(sv)&quot;</span> among the
      <span class="Li">&quot;OK&quot;</span> flags will be true.
    <p class="Pp">Beware: after this function returns,
        <span class="Li">&quot;ptr&quot;</span> and SvPVX_const(sv) may no
        longer refer to the same chunk of data.</p>
    <p class="Pp">The unfortunate similarity of this function's name to that of
        Perl's <span class="Li">&quot;chop&quot;</span> operator is strictly
        coincidental. This function works from the left;
        <span class="Li">&quot;chop&quot;</span> works from the right.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_chop(SV *const sv, const char *const ptr)
    </pre>
  </dd>
  <dt>sv_clear</dt>
  <dd>Clear an SV: call any destructors, free up any memory used by the body,
      and free the body itself. The SV's head is <i>not</i> freed, although its
      type is set to all 1's so that it won't inadvertently be assumed to be
      live during global destruction etc. This function should only be called
      when <span class="Li">&quot;REFCNT&quot;</span> is zero. Most of the time
      you'll want to call <span class="Li">&quot;sv_free()&quot;</span> (or its
      macro wrapper <span class="Li">&quot;SvREFCNT_dec&quot;</span>) instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_clear(SV *const orig_sv)
    </pre>
  </dd>
  <dt>sv_cmp</dt>
  <dd>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether
      the string in <span class="Li">&quot;sv1&quot;</span> is less than, equal
      to, or greater than the string in <span class="Li">&quot;sv2&quot;</span>.
      Is UTF-8 and <span class="Li">'use&#x00A0;bytes'</span> aware, handles get
      magic, and will coerce its args to strings if necessary. See also
      <span class="Li">&quot;sv_cmp_locale&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_cmp(SV *const sv1, SV *const sv2)
    </pre>
  </dd>
  <dt>sv_cmp_flags</dt>
  <dd>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether
      the string in <span class="Li">&quot;sv1&quot;</span> is less than, equal
      to, or greater than the string in <span class="Li">&quot;sv2&quot;</span>.
      Is UTF-8 and <span class="Li">'use&#x00A0;bytes'</span> aware and will
      coerce its args to strings if necessary. If the flags has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, it handles get
      magic. See also <span class="Li">&quot;sv_cmp_locale_flags&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_cmp_flags(SV *const sv1, SV *const sv2,
                             const U32 flags)
    </pre>
  </dd>
  <dt>sv_cmp_locale</dt>
  <dd>Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and
      <span class="Li">'use&#x00A0;bytes'</span> aware, handles get magic, and
      will coerce its args to strings if necessary. See also
      <span class="Li">&quot;sv_cmp&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_cmp_locale(SV *const sv1, SV *const sv2)
    </pre>
  </dd>
  <dt>sv_cmp_locale_flags</dt>
  <dd>Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and
      <span class="Li">'use&#x00A0;bytes'</span> aware and will coerce its args
      to strings if necessary. If the flags contain
      <span class="Li">&quot;SV_GMAGIC&quot;</span>, it handles get magic. See
      also <span class="Li">&quot;sv_cmp_flags&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_cmp_locale_flags(SV *const sv1,
                                    SV *const sv2,
                                    const U32 flags)
    </pre>
  </dd>
  <dt>sv_collxfrm</dt>
  <dd>This calls <span class="Li">&quot;sv_collxfrm_flags&quot;</span> with the
      SV_GMAGIC flag. See <span class="Li">&quot;sv_collxfrm_flags&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_collxfrm(SV *const sv, STRLEN *const nxp)
    </pre>
  </dd>
  <dt>sv_collxfrm_flags</dt>
  <dd>Add Collate Transform magic to an SV if it doesn't already have it. If the
      flags contain <span class="Li">&quot;SV_GMAGIC&quot;</span>, it handles
      get-magic.
    <p class="Pp">Any scalar variable may carry
        <span class="Li">&quot;PERL_MAGIC_collxfrm&quot;</span> magic that
        contains the scalar data of the variable, but transformed to such a
        format that a normal memory comparison can be used to compare the data
        according to the locale settings.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_collxfrm_flags(SV *const sv,
                                  STRLEN *const nxp,
                                  I32 const flags)
    </pre>
  </dd>
  <dt>sv_copypv</dt>
  <dd>Copies a stringified representation of the source SV into the destination
      SV. Automatically performs any necessary
      <span class="Li">&quot;mg_get&quot;</span> and coercion of numeric values
      into strings. Guaranteed to preserve
      <span class="Li">&quot;UTF8&quot;</span> flag even from overloaded
      objects. Similar in nature to
      <span class="Li">&quot;sv_2pv[_flags]&quot;</span> but operates directly
      on an SV instead of just the string. Mostly uses
      <span class="Li">&quot;sv_2pv_flags&quot;</span> to do its work, except
      when that would lose the UTF-8'ness of the PV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_copypv(SV *const dsv, SV *const ssv)
    </pre>
  </dd>
  <dt>sv_copypv_flags</dt>
  <dd>Implementation of <span class="Li">&quot;sv_copypv&quot;</span> and
      <span class="Li">&quot;sv_copypv_nomg&quot;</span>. Calls get magic iff
      flags has the <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_copypv_flags(SV *const dsv, SV *const ssv,
                                const I32 flags)
    </pre>
  </dd>
  <dt>sv_copypv_nomg</dt>
  <dd>Like <span class="Li">&quot;sv_copypv&quot;</span>, but doesn't invoke get
      magic first.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_copypv_nomg(SV *const dsv, SV *const ssv)
    </pre>
  </dd>
  <dt>SvCUR</dt>
  <dd>Returns the length of the string which is in the SV. See
      <span class="Li">&quot;SvLEN&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  SvCUR(SV* sv)
    </pre>
  </dd>
  <dt>SvCUR_set</dt>
  <dd>Set the current length of the string which is in the SV. See
      <span class="Li">&quot;SvCUR&quot;</span> and
      <span class="Li">&quot;SvIV_set&quot;</span>&gt;.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvCUR_set(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>sv_dec</dt>
  <dd>Auto-decrement of the value in the SV, doing string to numeric conversion
      if necessary. Handles 'get' magic and operator overloading.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_dec(SV *const sv)
    </pre>
  </dd>
  <dt>sv_dec_nomg</dt>
  <dd>Auto-decrement of the value in the SV, doing string to numeric conversion
      if necessary. Handles operator overloading. Skips handling 'get' magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_dec_nomg(SV *const sv)
    </pre>
  </dd>
  <dt>sv_derived_from</dt>
  <dd>Exactly like &quot;sv_derived_from_pv&quot;, but doesn't take a
      <span class="Li">&quot;flags&quot;</span> parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_derived_from(SV* sv, const char *const name)
    </pre>
  </dd>
  <dt>sv_derived_from_pv</dt>
  <dd>Exactly like &quot;sv_derived_from_pvn&quot;, but takes a nul-terminated
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_derived_from_pv(SV* sv,
                                   const char *const name,
                                   U32 flags)
    </pre>
  </dd>
  <dt>sv_derived_from_pvn</dt>
  <dd>Returns a boolean indicating whether the SV is derived from the specified
      class <i>at the C level</i>. To check derivation at the Perl level, call
      <span class="Li">&quot;isa()&quot;</span> as a normal Perl method.
    <p class="Pp">Currently, the only significant value for
        <span class="Li">&quot;flags&quot;</span> is SVf_UTF8.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_derived_from_pvn(SV* sv,
                                    const char *const name,
                                    const STRLEN len, U32 flags)
    </pre>
  </dd>
  <dt>sv_derived_from_sv</dt>
  <dd>Exactly like &quot;sv_derived_from_pvn&quot;, but takes the name string in
      the form of an SV instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_derived_from_sv(SV* sv, SV *namesv,
                                   U32 flags)
    </pre>
  </dd>
  <dt>sv_does</dt>
  <dd>Like &quot;sv_does_pv&quot;, but doesn't take a
      <span class="Li">&quot;flags&quot;</span> parameter.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_does(SV* sv, const char *const name)
    </pre>
  </dd>
  <dt>sv_does_pv</dt>
  <dd>Like &quot;sv_does_sv&quot;, but takes a nul-terminated string instead of
      an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_does_pv(SV* sv, const char *const name,
                           U32 flags)
    </pre>
  </dd>
  <dt>sv_does_pvn</dt>
  <dd>Like &quot;sv_does_sv&quot;, but takes a string/length pair instead of an
      SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_does_pvn(SV* sv, const char *const name,
                            const STRLEN len, U32 flags)
    </pre>
  </dd>
  <dt>sv_does_sv</dt>
  <dd>Returns a boolean indicating whether the SV performs a specific, named
      role. The SV can be a Perl object or the name of a Perl class.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_does_sv(SV* sv, SV* namesv, U32 flags)
    </pre>
  </dd>
  <dt>SvEND</dt>
  <dd>Returns a pointer to the spot just after the last character in the string
      which is in the SV, where there is usually a trailing
      <span class="Li">&quot;NUL&quot;</span> character (even though Perl
      scalars do not strictly require it). See
      <span class="Li">&quot;SvCUR&quot;</span>. Access the character as
      <span class="Li">&quot;*(SvEND(sv))&quot;</span>.
    <p class="Pp">Warning: If <span class="Li">&quot;SvCUR&quot;</span> is equal
        to <span class="Li">&quot;SvLEN&quot;</span>, then
        <span class="Li">&quot;SvEND&quot;</span> points to unallocated
      memory.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvEND(SV* sv)
    </pre>
  </dd>
  <dt>sv_eq</dt>
  <dd>Returns a boolean indicating whether the strings in the two SVs are
      identical. Is UTF-8 and <span class="Li">'use&#x00A0;bytes'</span> aware,
      handles get magic, and will coerce its args to strings if necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_eq(SV* sv1, SV* sv2)
    </pre>
  </dd>
  <dt>sv_eq_flags</dt>
  <dd>Returns a boolean indicating whether the strings in the two SVs are
      identical. Is UTF-8 and <span class="Li">'use&#x00A0;bytes'</span> aware
      and coerces its args to strings if necessary. If the flags has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, it handles
      get-magic, too.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_eq_flags(SV* sv1, SV* sv2, const U32 flags)
    </pre>
  </dd>
  <dt>sv_force_normal_flags</dt>
  <dd>Undo various types of fakery on an SV, where fakery means &quot;more
      than&quot; a string: if the PV is a shared string, make a private copy; if
      we're a ref, stop refing; if we're a glob, downgrade to an
      <span class="Li">&quot;xpvmg&quot;</span>; if we're a copy-on-write
      scalar, this is the on-write time when we do the copy, and is also used
      locally; if this is a vstring, drop the vstring magic. If
      <span class="Li">&quot;SV_COW_DROP_PV&quot;</span> is set then a
      copy-on-write scalar drops its PV buffer (if any) and becomes
      <span class="Li">&quot;SvPOK_off&quot;</span> rather than making a copy.
      (Used where this scalar is about to be set to some other value.) In
      addition, the <span class="Li">&quot;flags&quot;</span> parameter gets
      passed to <span class="Li">&quot;sv_unref_flags()&quot;</span> when
      unreffing. <span class="Li">&quot;sv_force_normal&quot;</span> calls this
      function with flags set to 0.
    <p class="Pp">This function is expected to be used to signal to perl that
        this SV is about to be written to, and any extra book-keeping needs to
        be taken care of. Hence, it croaks on read-only values.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_force_normal_flags(SV *const sv,
                                      const U32 flags)
    </pre>
  </dd>
  <dt>sv_free</dt>
  <dd>Decrement an SV's reference count, and if it drops to zero, call
      <span class="Li">&quot;sv_clear&quot;</span> to invoke destructors and
      free up any memory used by the body; finally, deallocating the SV's head
      itself. Normally called via a wrapper macro
      <span class="Li">&quot;SvREFCNT_dec&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_free(SV *const sv)
    </pre>
  </dd>
  <dt>SvGAMAGIC</dt>
  <dd>Returns true if the SV has get magic or overloading. If either is true
      then the scalar is active data, and has the potential to return a new
      value every time it is accessed. Hence you must be careful to only read it
      once per user logical operation and work with that returned value. If
      neither is true then the scalar's value cannot change unless written to.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvGAMAGIC(SV* sv)
    </pre>
  </dd>
  <dt>sv_gets</dt>
  <dd>Get a line from the filehandle and store it into the SV, optionally
      appending to the currently-stored string. If
      <span class="Li">&quot;append&quot;</span> is not 0, the line is appended
      to the SV instead of overwriting it.
      <span class="Li">&quot;append&quot;</span> should be set to the byte
      offset that the appended string should start at in the SV (typically,
      <span class="Li">&quot;SvCUR(sv)&quot;</span> is a suitable choice).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_gets(SV *const sv, PerlIO *const fp,
                        I32 append)
    </pre>
  </dd>
  <dt>sv_get_backrefs</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">If <span class="Li">&quot;sv&quot;</span> is the target of a
        weak reference then it returns the back references structure associated
        with the sv; otherwise return
      <span class="Li">&quot;NULL&quot;</span>.</p>
    <p class="Pp">When returning a non-null result the type of the return is
        relevant. If it is an AV then the elements of the AV are the weak
        reference RVs which point at this item. If it is any other type then the
        item itself is the weak reference.</p>
    <p class="Pp">See also
        <span class="Li">&quot;Perl_sv_add_backref()&quot;</span>,
        <span class="Li">&quot;Perl_sv_del_backref()&quot;</span>,
        <span class="Li">&quot;Perl_sv_kill_backrefs()&quot;</span></p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_get_backrefs(SV *const sv)
    </pre>
  </dd>
  <dt>SvGROW</dt>
  <dd>Expands the character buffer in the SV so that it has room for the
      indicated number of bytes (remember to reserve space for an extra trailing
      <span class="Li">&quot;NUL&quot;</span> character). Calls
      <span class="Li">&quot;sv_grow&quot;</span> to perform the expansion if
      necessary. Returns a pointer to the character buffer. SV must be of type
      &gt;= <span class="Li">&quot;SVt_PV&quot;</span>. One alternative is to
      call <span class="Li">&quot;sv_grow&quot;</span> if you are not sure of
      the type of SV.
    <p class="Pp">You might mistakenly think that
        <span class="Li">&quot;len&quot;</span> is the number of bytes to add to
        the existing size, but instead it is the total size
        <span class="Li">&quot;sv&quot;</span> should be.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char *  SvGROW(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>sv_grow</dt>
  <dd>Expands the character buffer in the SV. If necessary, uses
      <span class="Li">&quot;sv_unref&quot;</span> and upgrades the SV to
      <span class="Li">&quot;SVt_PV&quot;</span>. Returns a pointer to the
      character buffer. Use the <span class="Li">&quot;SvGROW&quot;</span>
      wrapper instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_grow(SV *const sv, STRLEN newlen)
    </pre>
  </dd>
  <dt>sv_inc</dt>
  <dd>Auto-increment of the value in the SV, doing string to numeric conversion
      if necessary. Handles 'get' magic and operator overloading.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_inc(SV *const sv)
    </pre>
  </dd>
  <dt>sv_inc_nomg</dt>
  <dd>Auto-increment of the value in the SV, doing string to numeric conversion
      if necessary. Handles operator overloading. Skips handling 'get' magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_inc_nomg(SV *const sv)
    </pre>
  </dd>
  <dt>sv_insert</dt>
  <dd>Inserts and/or replaces a string at the specified offset/length within the
      SV. Similar to the Perl <span class="Li">&quot;substr()&quot;</span>
      function, with <span class="Li">&quot;littlelen&quot;</span> bytes
      starting at <span class="Li">&quot;little&quot;</span> replacing
      <span class="Li">&quot;len&quot;</span> bytes of the string in
      <span class="Li">&quot;bigstr&quot;</span> starting at
      <span class="Li">&quot;offset&quot;</span>. Handles get magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_insert(SV *const bigstr, const STRLEN offset,
                          const STRLEN len,
                          const char *const little,
                          const STRLEN littlelen)
    </pre>
  </dd>
  <dt>sv_insert_flags</dt>
  <dd>Same as <span class="Li">&quot;sv_insert&quot;</span>, but the extra
      <span class="Li">&quot;flags&quot;</span> are passed to the
      <span class="Li">&quot;SvPV_force_flags&quot;</span> that applies to
      <span class="Li">&quot;bigstr&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_insert_flags(SV *const bigstr,
                                const STRLEN offset,
                                const STRLEN len,
                                const char *little,
                                const STRLEN littlelen,
                                const U32 flags)
    </pre>
  </dd>
  <dt>SvIOK</dt>
  <dd>Returns a U32 value indicating whether the SV contains an integer.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvIOK(SV* sv)
    </pre>
  </dd>
  <dt>SvIOK_notUV</dt>
  <dd>Returns a boolean indicating whether the SV contains a signed integer.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvIOK_notUV(SV* sv)
    </pre>
  </dd>
  <dt>SvIOK_off</dt>
  <dd>Unsets the IV status of an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvIOK_off(SV* sv)
    </pre>
  </dd>
  <dt>SvIOK_on</dt>
  <dd>Tells an SV that it is an integer.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvIOK_on(SV* sv)
    </pre>
  </dd>
  <dt>SvIOK_only</dt>
  <dd>Tells an SV that it is an integer and disables all other
      <span class="Li">&quot;OK&quot;</span> bits.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvIOK_only(SV* sv)
    </pre>
  </dd>
  <dt>SvIOK_only_UV</dt>
  <dd>Tells an SV that it is an unsigned integer and disables all other
      <span class="Li">&quot;OK&quot;</span> bits.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvIOK_only_UV(SV* sv)
    </pre>
  </dd>
  <dt>SvIOKp</dt>
  <dd>Returns a U32 value indicating whether the SV contains an integer. Checks
      the <b>private</b> setting. Use <span class="Li">&quot;SvIOK&quot;</span>
      instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvIOKp(SV* sv)
    </pre>
  </dd>
  <dt>SvIOK_UV</dt>
  <dd>Returns a boolean indicating whether the SV contains an integer that must
      be interpreted as unsigned. A non-negative integer whose value is within
      the range of both an IV and a UV may be be flagged as either
      <span class="Li">&quot;SvUOK&quot;</span> or
      <span class="Li">&quot;SVIOK&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvIOK_UV(SV* sv)
    </pre>
  </dd>
  <dt>sv_isa</dt>
  <dd>Returns a boolean indicating whether the SV is blessed into the specified
      class. This does not check for subtypes; use
      <span class="Li">&quot;sv_derived_from&quot;</span> to verify an
      inheritance relationship.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     sv_isa(SV* sv, const char *const name)
    </pre>
  </dd>
  <dt>SvIsCOW</dt>
  <dd>Returns a U32 value indicating whether the SV is Copy-On-Write (either
      shared hash key scalars, or full Copy On Write scalars if 5.9.0 is
      configured for COW).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvIsCOW(SV* sv)
    </pre>
  </dd>
  <dt>SvIsCOW_shared_hash</dt>
  <dd>Returns a boolean indicating whether the SV is Copy-On-Write shared hash
      key scalar.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvIsCOW_shared_hash(SV* sv)
    </pre>
  </dd>
  <dt>sv_isobject</dt>
  <dd>Returns a boolean indicating whether the SV is an RV pointing to a blessed
      object. If the SV is not an RV, or if the object is not blessed, then this
      will return false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     sv_isobject(SV* sv)
    </pre>
  </dd>
  <dt>SvIV</dt>
  <dd>Coerces the given SV to IV and returns it. The returned value in many
      circumstances will get stored in <span class="Li">&quot;sv&quot;</span>'s
      IV slot, but not in all cases. (Use
      <span class="Li">&quot;sv_setiv&quot;</span> to make sure it does).
    <p class="Pp">See <span class="Li">&quot;SvIVx&quot;</span> for a version
        which guarantees to evaluate <span class="Li">&quot;sv&quot;</span> only
        once.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      SvIV(SV* sv)
    </pre>
  </dd>
  <dt>SvIV_nomg</dt>
  <dd>Like <span class="Li">&quot;SvIV&quot;</span> but doesn't process magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      SvIV_nomg(SV* sv)
    </pre>
  </dd>
  <dt>SvIV_set</dt>
  <dd>Set the value of the IV pointer in sv to val. It is possible to perform
      the same function of this macro with an lvalue assignment to
      <span class="Li">&quot;SvIVX&quot;</span>. With future Perls, however, it
      will be more efficient to use <span class="Li">&quot;SvIV_set&quot;</span>
      instead of the lvalue assignment to
      <span class="Li">&quot;SvIVX&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvIV_set(SV* sv, IV val)
    </pre>
  </dd>
  <dt>SvIVX</dt>
  <dd>Returns the raw value in the SV's IV slot, without checks or conversions.
      Only use when you are sure <span class="Li">&quot;SvIOK&quot;</span> is
      true. See also <span class="Li">&quot;SvIV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      SvIVX(SV* sv)
    </pre>
  </dd>
  <dt>SvIVx</dt>
  <dd>Coerces the given SV to IV and returns it. The returned value in many
      circumstances will get stored in <span class="Li">&quot;sv&quot;</span>'s
      IV slot, but not in all cases. (Use
      <span class="Li">&quot;sv_setiv&quot;</span> to make sure it does).
    <p class="Pp">This form guarantees to evaluate
        <span class="Li">&quot;sv&quot;</span> only once. Only use this if
        <span class="Li">&quot;sv&quot;</span> is an expression with side
        effects, otherwise use the more efficient
        <span class="Li">&quot;SvIV&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      SvIVx(SV* sv)
    </pre>
  </dd>
  <dt>SvLEN</dt>
  <dd>Returns the size of the string buffer in the SV, not including any part
      attributable to <span class="Li">&quot;SvOOK&quot;</span>. See
      <span class="Li">&quot;SvCUR&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  SvLEN(SV* sv)
    </pre>
  </dd>
  <dt>sv_len</dt>
  <dd>Returns the length of the string in the SV. Handles magic and type
      coercion and sets the UTF8 flag appropriately. See also
      <span class="Li">&quot;SvCUR&quot;</span>, which gives raw access to the
      <span class="Li">&quot;xpv_cur&quot;</span> slot.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_len(SV *const sv)
    </pre>
  </dd>
  <dt>SvLEN_set</dt>
  <dd>Set the size of the string buffer for the SV. See
      <span class="Li">&quot;SvLEN&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvLEN_set(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>sv_len_utf8</dt>
  <dd>Returns the number of characters in the string in an SV, counting wide
      UTF-8 bytes as a single character. Handles magic and type coercion.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_len_utf8(SV *const sv)
    </pre>
  </dd>
  <dt>sv_magic</dt>
  <dd>Adds magic to an SV. First upgrades <span class="Li">&quot;sv&quot;</span>
      to type <span class="Li">&quot;SVt_PVMG&quot;</span> if necessary, then
      adds a new magic item of type <span class="Li">&quot;how&quot;</span> to
      the head of the magic list.
    <p class="Pp">See <span class="Li">&quot;sv_magicext&quot;</span> (which
        <span class="Li">&quot;sv_magic&quot;</span> now calls) for a
        description of the handling of the
        <span class="Li">&quot;name&quot;</span> and
        <span class="Li">&quot;namlen&quot;</span> arguments.</p>
    <p class="Pp">You need to use
        <span class="Li">&quot;sv_magicext&quot;</span> to add magic to
        <span class="Li">&quot;SvREADONLY&quot;</span> SVs and also to add more
        than one instance of the same
      <span class="Li">&quot;how&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_magic(SV *const sv, SV *const obj,
                         const int how, const char *const name,
                         const I32 namlen)
    </pre>
  </dd>
  <dt>sv_magicext</dt>
  <dd>Adds magic to an SV, upgrading it if necessary. Applies the supplied
      <span class="Li">&quot;vtable&quot;</span> and returns a pointer to the
      magic added.
    <p class="Pp">Note that <span class="Li">&quot;sv_magicext&quot;</span> will
        allow things that <span class="Li">&quot;sv_magic&quot;</span> will not.
        In particular, you can add magic to
        <span class="Li">&quot;SvREADONLY&quot;</span> SVs, and add more than
        one instance of the same <span class="Li">&quot;how&quot;</span>.</p>
    <p class="Pp">If <span class="Li">&quot;namlen&quot;</span> is greater than
        zero then a <span class="Li">&quot;savepvn&quot;</span> <i>copy</i> of
        <span class="Li">&quot;name&quot;</span> is stored, if
        <span class="Li">&quot;namlen&quot;</span> is zero then
        <span class="Li">&quot;name&quot;</span> is stored as-is and - as
        another special case - if <span class="Li">&quot;(name &amp;&amp; namlen
        == HEf_SVKEY)&quot;</span> then <span class="Li">&quot;name&quot;</span>
        is assumed to contain an SV* and is stored as-is with its
        <span class="Li">&quot;REFCNT&quot;</span> incremented.</p>
    <p class="Pp">(This is now used as a subroutine by
        <span class="Li">&quot;sv_magic&quot;</span>.)</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        MAGIC * sv_magicext(SV *const sv, SV *const obj,
                            const int how,
                            const MGVTBL *const vtbl,
                            const char *const name,
                            const I32 namlen)
    </pre>
  </dd>
  <dt>SvMAGIC_set</dt>
  <dd>Set the value of the MAGIC pointer in
      <span class="Li">&quot;sv&quot;</span> to val. See
      <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvMAGIC_set(SV* sv, MAGIC* val)
    </pre>
  </dd>
  <dt>sv_mortalcopy</dt>
  <dd>Creates a new SV which is a copy of the original SV (using
      <span class="Li">&quot;sv_setsv&quot;</span>). The new SV is marked as
      mortal. It will be destroyed &quot;soon&quot;, either by an explicit call
      to <span class="Li">&quot;FREETMPS&quot;</span>, or by an implicit call at
      places such as statement boundaries. See also
      <span class="Li">&quot;sv_newmortal&quot;</span> and
      <span class="Li">&quot;sv_2mortal&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_mortalcopy(SV *const oldsv)
    </pre>
  </dd>
  <dt>sv_newmortal</dt>
  <dd>Creates a new null SV which is mortal. The reference count of the SV is
      set to 1. It will be destroyed &quot;soon&quot;, either by an explicit
      call to <span class="Li">&quot;FREETMPS&quot;</span>, or by an implicit
      call at places such as statement boundaries. See also
      <span class="Li">&quot;sv_mortalcopy&quot;</span> and
      <span class="Li">&quot;sv_2mortal&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_newmortal()
    </pre>
  </dd>
  <dt>sv_newref</dt>
  <dd>Increment an SV's reference count. Use the
      <span class="Li">&quot;SvREFCNT_inc()&quot;</span> wrapper instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_newref(SV *const sv)
    </pre>
  </dd>
  <dt>SvNIOK</dt>
  <dd>Returns a U32 value indicating whether the SV contains a number, integer
      or double.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvNIOK(SV* sv)
    </pre>
  </dd>
  <dt>SvNIOK_off</dt>
  <dd>Unsets the NV/IV status of an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvNIOK_off(SV* sv)
    </pre>
  </dd>
  <dt>SvNIOKp</dt>
  <dd>Returns a U32 value indicating whether the SV contains a number, integer
      or double. Checks the <b>private</b> setting. Use
      <span class="Li">&quot;SvNIOK&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvNIOKp(SV* sv)
    </pre>
  </dd>
  <dt>SvNOK</dt>
  <dd>Returns a U32 value indicating whether the SV contains a double.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvNOK(SV* sv)
    </pre>
  </dd>
  <dt>SvNOK_off</dt>
  <dd>Unsets the NV status of an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvNOK_off(SV* sv)
    </pre>
  </dd>
  <dt>SvNOK_on</dt>
  <dd>Tells an SV that it is a double.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvNOK_on(SV* sv)
    </pre>
  </dd>
  <dt>SvNOK_only</dt>
  <dd>Tells an SV that it is a double and disables all other OK bits.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvNOK_only(SV* sv)
    </pre>
  </dd>
  <dt>SvNOKp</dt>
  <dd>Returns a U32 value indicating whether the SV contains a double. Checks
      the <b>private</b> setting. Use <span class="Li">&quot;SvNOK&quot;</span>
      instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvNOKp(SV* sv)
    </pre>
  </dd>
  <dt>SvNV</dt>
  <dd>Coerces the given SV to NV and returns it. The returned value in many
      circumstances will get stored in <span class="Li">&quot;sv&quot;</span>'s
      NV slot, but not in all cases. (Use
      <span class="Li">&quot;sv_setnv&quot;</span> to make sure it does).
    <p class="Pp">See <span class="Li">&quot;SvNVx&quot;</span> for a version
        which guarantees to evaluate <span class="Li">&quot;sv&quot;</span> only
        once.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      SvNV(SV* sv)
    </pre>
  </dd>
  <dt>SvNV_nomg</dt>
  <dd>Like <span class="Li">&quot;SvNV&quot;</span> but doesn't process magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      SvNV_nomg(SV* sv)
    </pre>
  </dd>
  <dt>SvNV_set</dt>
  <dd>Set the value of the NV pointer in <span class="Li">&quot;sv&quot;</span>
      to val. See <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvNV_set(SV* sv, NV val)
    </pre>
  </dd>
  <dt>SvNVX</dt>
  <dd>Returns the raw value in the SV's NV slot, without checks or conversions.
      Only use when you are sure <span class="Li">&quot;SvNOK&quot;</span> is
      true. See also <span class="Li">&quot;SvNV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      SvNVX(SV* sv)
    </pre>
  </dd>
  <dt>SvNVx</dt>
  <dd>Coerces the given SV to NV and returns it. The returned value in many
      circumstances will get stored in <span class="Li">&quot;sv&quot;</span>'s
      NV slot, but not in all cases. (Use
      <span class="Li">&quot;sv_setnv&quot;</span> to make sure it does).
    <p class="Pp">This form guarantees to evaluate
        <span class="Li">&quot;sv&quot;</span> only once. Only use this if
        <span class="Li">&quot;sv&quot;</span> is an expression with side
        effects, otherwise use the more efficient
        <span class="Li">&quot;SvNV&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        NV      SvNVx(SV* sv)
    </pre>
  </dd>
  <dt>SvOK</dt>
  <dd>Returns a U32 value indicating whether the value is defined. This is only
      meaningful for scalars.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvOK(SV* sv)
    </pre>
  </dd>
  <dt>SvOOK</dt>
  <dd>Returns a U32 indicating whether the pointer to the string buffer is
      offset. This hack is used internally to speed up removal of characters
      from the beginning of a <span class="Li">&quot;SvPV&quot;</span>. When
      <span class="Li">&quot;SvOOK&quot;</span> is true, then the start of the
      allocated string buffer is actually
      <span class="Li">&quot;SvOOK_offset()&quot;</span> bytes before
      <span class="Li">&quot;SvPVX&quot;</span>. This offset used to be stored
      in <span class="Li">&quot;SvIVX&quot;</span>, but is now stored within the
      spare part of the buffer.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvOOK(SV* sv)
    </pre>
  </dd>
  <dt>SvOOK_offset</dt>
  <dd>Reads into <span class="Li">&quot;len&quot;</span> the offset from
      <span class="Li">&quot;SvPVX&quot;</span> back to the true start of the
      allocated buffer, which will be non-zero if
      <span class="Li">&quot;sv_chop&quot;</span> has been used to efficiently
      remove characters from start of the buffer. Implemented as a macro, which
      takes the address of <span class="Li">&quot;len&quot;</span>, which must
      be of type <span class="Li">&quot;STRLEN&quot;</span>. Evaluates
      <span class="Li">&quot;sv&quot;</span> more than once. Sets
      <span class="Li">&quot;len&quot;</span> to 0 if
      <span class="Li">&quot;SvOOK(sv)&quot;</span> is false.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvOOK_offset(SV*sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPOK</dt>
  <dd>Returns a U32 value indicating whether the SV contains a character string.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvPOK(SV* sv)
    </pre>
  </dd>
  <dt>SvPOK_off</dt>
  <dd>Unsets the PV status of an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvPOK_off(SV* sv)
    </pre>
  </dd>
  <dt>SvPOK_on</dt>
  <dd>Tells an SV that it is a string.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvPOK_on(SV* sv)
    </pre>
  </dd>
  <dt>SvPOK_only</dt>
  <dd>Tells an SV that it is a string and disables all other
      <span class="Li">&quot;OK&quot;</span> bits. Will also turn off the UTF-8
      status.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvPOK_only(SV* sv)
    </pre>
  </dd>
  <dt>SvPOK_only_UTF8</dt>
  <dd>Tells an SV that it is a string and disables all other
      <span class="Li">&quot;OK&quot;</span> bits, and leaves the UTF-8 status
      as it was.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvPOK_only_UTF8(SV* sv)
    </pre>
  </dd>
  <dt>SvPOKp</dt>
  <dd>Returns a U32 value indicating whether the SV contains a character string.
      Checks the <b>private</b> setting. Use
      <span class="Li">&quot;SvPOK&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvPOKp(SV* sv)
    </pre>
  </dd>
  <dt>sv_pos_b2u</dt>
  <dd>Converts the value pointed to by
      <span class="Li">&quot;offsetp&quot;</span> from a count of bytes from the
      start of the string, to a count of the equivalent number of UTF-8 chars.
      Handles magic and type coercion.
    <p class="Pp">Use <span class="Li">&quot;sv_pos_b2u_flags&quot;</span> in
        preference, which correctly handles strings longer than 2Gb.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_pos_b2u(SV *const sv, I32 *const offsetp)
    </pre>
  </dd>
  <dt>sv_pos_b2u_flags</dt>
  <dd>Converts <span class="Li">&quot;offset&quot;</span> from a count of bytes
      from the start of the string, to a count of the equivalent number of UTF-8
      chars. Handles type coercion. <span class="Li">&quot;flags&quot;</span> is
      passed to <span class="Li">&quot;SvPV_flags&quot;</span>, and usually
      should be <span class="Li">&quot;SV_GMAGIC|SV_CONST_RETURN&quot;</span> to
      handle magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_pos_b2u_flags(SV *const sv,
                                 STRLEN const offset, U32 flags)
    </pre>
  </dd>
  <dt>sv_pos_u2b</dt>
  <dd>Converts the value pointed to by
      <span class="Li">&quot;offsetp&quot;</span> from a count of UTF-8 chars
      from the start of the string, to a count of the equivalent number of
      bytes; if <span class="Li">&quot;lenp&quot;</span> is non-zero, it does
      the same to <span class="Li">&quot;lenp&quot;</span>, but this time
      starting from the offset, rather than from the start of the string.
      Handles magic and type coercion.
    <p class="Pp">Use <span class="Li">&quot;sv_pos_u2b_flags&quot;</span> in
        preference, which correctly handles strings longer than 2Gb.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_pos_u2b(SV *const sv, I32 *const offsetp,
                           I32 *const lenp)
    </pre>
  </dd>
  <dt>sv_pos_u2b_flags</dt>
  <dd>Converts the offset from a count of UTF-8 chars from the start of the
      string, to a count of the equivalent number of bytes; if
      <span class="Li">&quot;lenp&quot;</span> is non-zero, it does the same to
      <span class="Li">&quot;lenp&quot;</span>, but this time starting from
      <span class="Li">&quot;offset&quot;</span>, rather than from the start of
      the string. Handles type coercion.
      <span class="Li">&quot;flags&quot;</span> is passed to
      <span class="Li">&quot;SvPV_flags&quot;</span>, and usually should be
      <span class="Li">&quot;SV_GMAGIC|SV_CONST_RETURN&quot;</span> to handle
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_pos_u2b_flags(SV *const sv, STRLEN uoffset,
                                 STRLEN *const lenp, U32 flags)
    </pre>
  </dd>
  <dt>SvPV</dt>
  <dd>Returns a pointer to the string in the SV, or a stringified form of the SV
      if the SV does not contain a string. The SV may cache the stringified
      version becoming <span class="Li">&quot;SvPOK&quot;</span>. Handles 'get'
      magic. The <span class="Li">&quot;len&quot;</span> variable will be set to
      the length of the string (this is a macro, so don't use
      <span class="Li">&amp;len</span>). See also
      <span class="Li">&quot;SvPVx&quot;</span> for a version which guarantees
      to evaluate <span class="Li">&quot;sv&quot;</span> only once.
    <p class="Pp">Note that there is no guarantee that the return value of
        <span class="Li">&quot;SvPV()&quot;</span> is equal to
        <span class="Li">&quot;SvPVX(sv)&quot;</span>, or that
        <span class="Li">&quot;SvPVX(sv)&quot;</span> contains valid data, or
        that successive calls to <span class="Li">&quot;SvPV(sv)&quot;</span>
        will return the same pointer value each time. This is due to the way
        that things like overloading and Copy-On-Write are handled. In these
        cases, the return value may point to a temporary buffer or similar. If
        you absolutely need the <span class="Li">&quot;SvPVX&quot;</span> field
        to be valid (for example, if you intend to write to it), then see
        <span class="Li">&quot;SvPV_force&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPV(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVbyte</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to byte representation first if
      necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVbyte(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVbyte_force</dt>
  <dd>Like <span class="Li">&quot;SvPV_force&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to byte representation first if
      necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVbyte_force(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVbyte_nolen</dt>
  <dd>Like <span class="Li">&quot;SvPV_nolen&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to byte representation first if
      necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVbyte_nolen(SV* sv)
    </pre>
  </dd>
  <dt>sv_pvbyten_force</dt>
  <dd>The backend for the <span class="Li">&quot;SvPVbytex_force&quot;</span>
      macro. Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvbyten_force(SV *const sv, STRLEN *const lp)
    </pre>
  </dd>
  <dt>SvPVbytex</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to byte representation first if
      necessary. Guarantees to evaluate <span class="Li">&quot;sv&quot;</span>
      only once; use the more efficient
      <span class="Li">&quot;SvPVbyte&quot;</span> otherwise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVbytex(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVbytex_force</dt>
  <dd>Like <span class="Li">&quot;SvPV_force&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to byte representation first if
      necessary. Guarantees to evaluate <span class="Li">&quot;sv&quot;</span>
      only once; use the more efficient
      <span class="Li">&quot;SvPVbyte_force&quot;</span> otherwise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVbytex_force(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVCLEAR</dt>
  <dd>Ensures that sv is a SVt_PV and that its SvCUR is 0, and that it is
      properly null terminated. Equivalent to sv_setpvs(&quot;&quot;), but more
      efficient.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char *  SvPVCLEAR(SV* sv)
    </pre>
  </dd>
  <dt>SvPV_force</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span> but will force the SV into
      containing a string (<span class="Li">&quot;SvPOK&quot;</span>), and only
      a string (<span class="Li">&quot;SvPOK_only&quot;</span>), by hook or by
      crook. You need force if you are going to update the
      <span class="Li">&quot;SvPVX&quot;</span> directly. Processes get magic.
    <p class="Pp">Note that coercing an arbitrary scalar into a plain PV will
        potentially strip useful data from it. For example if the SV was
        <span class="Li">&quot;SvROK&quot;</span>, then the referent will have
        its reference count decremented, and the SV itself may be converted to
        an <span class="Li">&quot;SvPOK&quot;</span> scalar with a string buffer
        containing a value such as
        <span class="Li">&quot;ARRAY(0x1234)&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPV_force(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPV_force_nomg</dt>
  <dd>Like <span class="Li">&quot;SvPV_force&quot;</span>, but doesn't process
      get magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPV_force_nomg(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPV_nolen</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span> but doesn't set a length
      variable.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPV_nolen(SV* sv)
    </pre>
  </dd>
  <dt>SvPV_nomg</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span> but doesn't process magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPV_nomg(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPV_nomg_nolen</dt>
  <dd>Like <span class="Li">&quot;SvPV_nolen&quot;</span> but doesn't process
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPV_nomg_nolen(SV* sv)
    </pre>
  </dd>
  <dt>sv_pvn_force</dt>
  <dd>Get a sensible string out of the SV somehow. A private implementation of
      the <span class="Li">&quot;SvPV_force&quot;</span> macro for compilers
      which can't cope with complex macro expressions. Always use the macro
      instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvn_force(SV* sv, STRLEN* lp)
    </pre>
  </dd>
  <dt>sv_pvn_force_flags</dt>
  <dd>Get a sensible string out of the SV somehow. If
      <span class="Li">&quot;flags&quot;</span> has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, will
      <span class="Li">&quot;mg_get&quot;</span> on
      <span class="Li">&quot;sv&quot;</span> if appropriate, else not.
      <span class="Li">&quot;sv_pvn_force&quot;</span> and
      <span class="Li">&quot;sv_pvn_force_nomg&quot;</span> are implemented in
      terms of this function. You normally want to use the various wrapper
      macros instead: see <span class="Li">&quot;SvPV_force&quot;</span> and
      <span class="Li">&quot;SvPV_force_nomg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvn_force_flags(SV *const sv,
                                   STRLEN *const lp,
                                   const I32 flags)
    </pre>
  </dd>
  <dt>SvPV_set</dt>
  <dd>This is probably not what you want to use, you probably wanted
      &quot;sv_usepvn_flags&quot; or &quot;sv_setpvn&quot; or
      &quot;sv_setpvs&quot;.
    <p class="Pp">Set the value of the PV pointer in
        <span class="Li">&quot;sv&quot;</span> to the Perl allocated
        <span class="Li">&quot;NUL&quot;</span>-terminated string
        <span class="Li">&quot;val&quot;</span>. See also
        <span class="Li">&quot;SvIV_set&quot;</span>.</p>
    <p class="Pp">Remember to free the previous PV buffer. There are many things
        to check. Beware that the existing pointer may be involved in
        copy-on-write or other mischief, so do
        <span class="Li">&quot;SvOOK_off(sv)&quot;</span> and use
        <span class="Li">&quot;sv_force_normal&quot;</span> or
        <span class="Li">&quot;SvPV_force&quot;</span> (or check the
        <span class="Li">&quot;SvIsCOW&quot;</span> flag) first to make sure
        this modification is safe. Then finally, if it is not a COW, call
        <span class="Li">&quot;SvPV_free&quot;</span> to free the previous PV
        buffer.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvPV_set(SV* sv, char* val)
    </pre>
  </dd>
  <dt>SvPVutf8</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to UTF-8 first if necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVutf8(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>sv_pvutf8n_force</dt>
  <dd>The backend for the <span class="Li">&quot;SvPVutf8x_force&quot;</span>
      macro. Always use the macro instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_pvutf8n_force(SV *const sv, STRLEN *const lp)
    </pre>
  </dd>
  <dt>SvPVutf8x</dt>
  <dd>Like <span class="Li">&quot;SvPV&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to UTF-8 first if necessary.
      Guarantees to evaluate <span class="Li">&quot;sv&quot;</span> only once;
      use the more efficient <span class="Li">&quot;SvPVutf8&quot;</span>
      otherwise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVutf8x(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVutf8x_force</dt>
  <dd>Like <span class="Li">&quot;SvPV_force&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to UTF-8 first if necessary.
      Guarantees to evaluate <span class="Li">&quot;sv&quot;</span> only once;
      use the more efficient <span class="Li">&quot;SvPVutf8_force&quot;</span>
      otherwise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVutf8x_force(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVutf8_force</dt>
  <dd>Like <span class="Li">&quot;SvPV_force&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to UTF-8 first if necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVutf8_force(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvPVutf8_nolen</dt>
  <dd>Like <span class="Li">&quot;SvPV_nolen&quot;</span>, but converts
      <span class="Li">&quot;sv&quot;</span> to UTF-8 first if necessary.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVutf8_nolen(SV* sv)
    </pre>
  </dd>
  <dt>SvPVX</dt>
  <dd>Returns a pointer to the physical string in the SV. The SV must contain a
      string. Prior to 5.9.3 it is not safe to execute this macro unless the
      SV's type &gt;= <span class="Li">&quot;SVt_PV&quot;</span>.
    <p class="Pp">This is also used to store the name of an autoloaded
        subroutine in an XS AUTOLOAD routine. See &quot;Autoloading with
        XSUBs&quot; in perlguts.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVX(SV* sv)
    </pre>
  </dd>
  <dt>SvPVx</dt>
  <dd>A version of <span class="Li">&quot;SvPV&quot;</span> which guarantees to
      evaluate <span class="Li">&quot;sv&quot;</span> only once. Only use this
      if <span class="Li">&quot;sv&quot;</span> is an expression with side
      effects, otherwise use the more efficient
      <span class="Li">&quot;SvPV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   SvPVx(SV* sv, STRLEN len)
    </pre>
  </dd>
  <dt>SvREADONLY</dt>
  <dd>Returns true if the argument is readonly, otherwise returns false. Exposed
      to to perl code via <b>Internals::SvREADONLY()</b>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvREADONLY(SV* sv)
    </pre>
  </dd>
  <dt>SvREADONLY_off</dt>
  <dd>Mark an object as not-readonly. Exactly what this mean depends on the
      object type. Exposed to perl code via <b>Internals::SvREADONLY()</b>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvREADONLY_off(SV* sv)
    </pre>
  </dd>
  <dt>SvREADONLY_on</dt>
  <dd>Mark an object as readonly. Exactly what this means depends on the object
      type. Exposed to perl code via <b>Internals::SvREADONLY()</b>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvREADONLY_on(SV* sv)
    </pre>
  </dd>
  <dt>sv_ref</dt>
  <dd>Returns a SV describing what the SV passed in is a reference to.
    <p class="Pp">dst can be a SV to be set to the description or NULL, in which
        case a mortal SV is returned.</p>
    <p class="Pp">If ob is true and the SV is blessed, the description is the
        class name, otherwise it is the type of the SV, &quot;SCALAR&quot;,
        &quot;ARRAY&quot; etc.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_ref(SV *dst, const SV *const sv,
                       const int ob)
    </pre>
  </dd>
  <dt>SvREFCNT</dt>
  <dd>Returns the value of the object's reference count. Exposed to perl code
      via <b>Internals::SvREFCNT()</b>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvREFCNT(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_dec</dt>
  <dd>Decrements the reference count of the given SV.
      <span class="Li">&quot;sv&quot;</span> may be
      <span class="Li">&quot;NULL&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvREFCNT_dec(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_dec_NN</dt>
  <dd>Same as <span class="Li">&quot;SvREFCNT_dec&quot;</span>, but can only be
      used if you know <span class="Li">&quot;sv&quot;</span> is not
      <span class="Li">&quot;NULL&quot;</span>. Since we don't have to check the
      NULLness, it's faster and smaller.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvREFCNT_dec_NN(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc</dt>
  <dd>Increments the reference count of the given SV, returning the SV.
    <p class="Pp">All of the following
        <span class="Li">&quot;SvREFCNT_inc&quot;</span>* macros are optimized
        versions of <span class="Li">&quot;SvREFCNT_inc&quot;</span>, and can be
        replaced with <span class="Li">&quot;SvREFCNT_inc&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     SvREFCNT_inc(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_NN</dt>
  <dd>Same as <span class="Li">&quot;SvREFCNT_inc&quot;</span>, but can only be
      used if you know <span class="Li">&quot;sv&quot;</span> is not
      <span class="Li">&quot;NULL&quot;</span>. Since we don't have to check the
      NULLness, it's faster and smaller.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     SvREFCNT_inc_NN(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_simple</dt>
  <dd>Same as <span class="Li">&quot;SvREFCNT_inc&quot;</span>, but can only be
      used with expressions without side effects. Since we don't have to store a
      temporary value, it's faster.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     SvREFCNT_inc_simple(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_simple_NN</dt>
  <dd>Same as <span class="Li">&quot;SvREFCNT_inc_simple&quot;</span>, but can
      only be used if you know <span class="Li">&quot;sv&quot;</span> is not
      <span class="Li">&quot;NULL&quot;</span>. Since we don't have to check the
      NULLness, it's faster and smaller.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     SvREFCNT_inc_simple_NN(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_simple_void</dt>
  <dd>Same as <span class="Li">&quot;SvREFCNT_inc_simple&quot;</span>, but can
      only be used if you don't need the return value. The macro doesn't need to
      return a meaningful value.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvREFCNT_inc_simple_void(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_simple_void_NN</dt>
  <dd>Same as <span class="Li">&quot;SvREFCNT_inc&quot;</span>, but can only be
      used if you don't need the return value, and you know that
      <span class="Li">&quot;sv&quot;</span> is not
      <span class="Li">&quot;NULL&quot;</span>. The macro doesn't need to return
      a meaningful value, or check for NULLness, so it's smaller and faster.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvREFCNT_inc_simple_void_NN(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_void</dt>
  <dd>Same as <span class="Li">&quot;SvREFCNT_inc&quot;</span>, but can only be
      used if you don't need the return value. The macro doesn't need to return
      a meaningful value.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvREFCNT_inc_void(SV* sv)
    </pre>
  </dd>
  <dt>SvREFCNT_inc_void_NN</dt>
  <dd>Same as <span class="Li">&quot;SvREFCNT_inc&quot;</span>, but can only be
      used if you don't need the return value, and you know that
      <span class="Li">&quot;sv&quot;</span> is not
      <span class="Li">&quot;NULL&quot;</span>. The macro doesn't need to return
      a meaningful value, or check for NULLness, so it's smaller and faster.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvREFCNT_inc_void_NN(SV* sv)
    </pre>
  </dd>
  <dt>sv_reftype</dt>
  <dd>Returns a string describing what the SV is a reference to.
    <p class="Pp">If ob is true and the SV is blessed, the string is the class
        name, otherwise it is the type of the SV, &quot;SCALAR&quot;,
        &quot;ARRAY&quot; etc.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        const char* sv_reftype(const SV *const sv, const int ob)
    </pre>
  </dd>
  <dt>sv_replace</dt>
  <dd>Make the first argument a copy of the second, then delete the original.
      The target SV physically takes over ownership of the body of the source SV
      and inherits its flags; however, the target keeps any magic it owns, and
      any magic in the source is discarded. Note that this is a rather
      specialist SV copying operation; most of the time you'll want to use
      <span class="Li">&quot;sv_setsv&quot;</span> or one of its many macro
      front-ends.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_replace(SV *const sv, SV *const nsv)
    </pre>
  </dd>
  <dt>sv_report_used</dt>
  <dd>Dump the contents of all SVs not yet freed (debugging aid).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_report_used()
    </pre>
  </dd>
  <dt>sv_reset</dt>
  <dd>Underlying implementation for the
      <span class="Li">&quot;reset&quot;</span> Perl function. Note that the
      perl-level function is vaguely deprecated.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_reset(const char* s, HV *const stash)
    </pre>
  </dd>
  <dt>SvROK</dt>
  <dd>Tests if the SV is an RV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvROK(SV* sv)
    </pre>
  </dd>
  <dt>SvROK_off</dt>
  <dd>Unsets the RV status of an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvROK_off(SV* sv)
    </pre>
  </dd>
  <dt>SvROK_on</dt>
  <dd>Tells an SV that it is an RV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvROK_on(SV* sv)
    </pre>
  </dd>
  <dt>SvRV</dt>
  <dd>Dereferences an RV to return the SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     SvRV(SV* sv)
    </pre>
  </dd>
  <dt>SvRV_set</dt>
  <dd>Set the value of the RV pointer in <span class="Li">&quot;sv&quot;</span>
      to val. See <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvRV_set(SV* sv, SV* val)
    </pre>
  </dd>
  <dt>sv_rvunweaken</dt>
  <dd>Unweaken a reference: Clear the
      <span class="Li">&quot;SvWEAKREF&quot;</span> flag on this RV; remove the
      backreference to this RV from the array of backreferences associated with
      the target SV, increment the refcount of the target. Silently ignores
      <span class="Li">&quot;undef&quot;</span> and warns on non-weak
      references.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_rvunweaken(SV *const sv)
    </pre>
  </dd>
  <dt>sv_rvweaken</dt>
  <dd>Weaken a reference: set the <span class="Li">&quot;SvWEAKREF&quot;</span>
      flag on this RV; give the referred-to SV
      <span class="Li">&quot;PERL_MAGIC_backref&quot;</span> magic if it hasn't
      already; and push a back-reference to this RV onto the array of
      backreferences associated with that magic. If the RV is magical, set magic
      will be called after the RV is cleared. Silently ignores
      <span class="Li">&quot;undef&quot;</span> and warns on already-weak
      references.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_rvweaken(SV *const sv)
    </pre>
  </dd>
  <dt>sv_setiv</dt>
  <dd>Copies an integer into the given SV, upgrading first if necessary. Does
      not handle 'set' magic. See also
      <span class="Li">&quot;sv_setiv_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setiv(SV *const sv, const IV num)
    </pre>
  </dd>
  <dt>sv_setiv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setiv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setiv_mg(SV *const sv, const IV i)
    </pre>
  </dd>
  <dt>sv_setnv</dt>
  <dd>Copies a double into the given SV, upgrading first if necessary. Does not
      handle 'set' magic. See also
      <span class="Li">&quot;sv_setnv_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setnv(SV *const sv, const NV num)
    </pre>
  </dd>
  <dt>sv_setnv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setnv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setnv_mg(SV *const sv, const NV num)
    </pre>
  </dd>
  <dt>sv_setpv</dt>
  <dd>Copies a string into an SV. The string must be terminated with a
      <span class="Li">&quot;NUL&quot;</span> character, and not contain embeded
      <span class="Li">&quot;NUL&quot;</span>'s. Does not handle 'set' magic.
      See <span class="Li">&quot;sv_setpv_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpv(SV *const sv, const char *const ptr)
    </pre>
  </dd>
  <dt>sv_setpvf</dt>
  <dd>Works like <span class="Li">&quot;sv_catpvf&quot;</span> but copies the
      text into the SV instead of appending it. Does not handle 'set' magic. See
      <span class="Li">&quot;sv_setpvf_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpvf(SV *const sv, const char *const pat,
                          ...)
    </pre>
  </dd>
  <dt>sv_setpvf_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setpvf&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpvf_mg(SV *const sv,
                             const char *const pat, ...)
    </pre>
  </dd>
  <dt>sv_setpviv</dt>
  <dd>Copies an integer into the given SV, also updating its string value. Does
      not handle 'set' magic. See
      <span class="Li">&quot;sv_setpviv_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpviv(SV *const sv, const IV num)
    </pre>
  </dd>
  <dt>sv_setpviv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setpviv&quot;</span>, but also handles
      'set' magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpviv_mg(SV *const sv, const IV iv)
    </pre>
  </dd>
  <dt>sv_setpvn</dt>
  <dd>Copies a string (possibly containing embedded
      <span class="Li">&quot;NUL&quot;</span> characters) into an SV. The
      <span class="Li">&quot;len&quot;</span> parameter indicates the number of
      bytes to be copied. If the <span class="Li">&quot;ptr&quot;</span>
      argument is NULL the SV will become undefined. Does not handle 'set'
      magic. See <span class="Li">&quot;sv_setpvn_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpvn(SV *const sv, const char *const ptr,
                          const STRLEN len)
    </pre>
  </dd>
  <dt>sv_setpvn_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setpvn&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpvn_mg(SV *const sv,
                             const char *const ptr,
                             const STRLEN len)
    </pre>
  </dd>
  <dt>sv_setpvs</dt>
  <dd>Like <span class="Li">&quot;sv_setpvn&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpvs(SV* sv, &quot;literal string&quot; s)
    </pre>
  </dd>
  <dt>sv_setpvs_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setpvn_mg&quot;</span>, but takes a literal
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpvs_mg(SV* sv, &quot;literal string&quot; s)
    </pre>
  </dd>
  <dt>sv_setpv_bufsize</dt>
  <dd>Sets the SV to be a string of cur bytes length, with at least len bytes
      available. Ensures that there is a null byte at SvEND. Returns a char *
      pointer to the SvPV buffer.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char  * sv_setpv_bufsize(SV *const sv, const STRLEN cur,
                                 const STRLEN len)
    </pre>
  </dd>
  <dt>sv_setpv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setpv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setpv_mg(SV *const sv, const char *const ptr)
    </pre>
  </dd>
  <dt>sv_setref_iv</dt>
  <dd>Copies an integer into a new SV, optionally blessing the SV. The
      <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an RV.
      That RV will be modified to point to the new SV. The
      <span class="Li">&quot;classname&quot;</span> argument indicates the
      package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_setref_iv(SV *const rv,
                             const char *const classname,
                             const IV iv)
    </pre>
  </dd>
  <dt>sv_setref_nv</dt>
  <dd>Copies a double into a new SV, optionally blessing the SV. The
      <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an RV.
      That RV will be modified to point to the new SV. The
      <span class="Li">&quot;classname&quot;</span> argument indicates the
      package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_setref_nv(SV *const rv,
                             const char *const classname,
                             const NV nv)
    </pre>
  </dd>
  <dt>sv_setref_pv</dt>
  <dd>Copies a pointer into a new SV, optionally blessing the SV. The
      <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an RV.
      That RV will be modified to point to the new SV. If the
      <span class="Li">&quot;pv&quot;</span> argument is
      <span class="Li">&quot;NULL&quot;</span>, then
      <span class="Li">&quot;PL_sv_undef&quot;</span> will be placed into the
      SV. The <span class="Li">&quot;classname&quot;</span> argument indicates
      the package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.
    <p class="Pp">Do not use with other Perl types such as HV, AV, SV, CV,
        because those objects will become corrupted by the pointer copy
      process.</p>
    <p class="Pp">Note that <span class="Li">&quot;sv_setref_pvn&quot;</span>
        copies the string while this copies the pointer.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_setref_pv(SV *const rv,
                             const char *const classname,
                             void *const pv)
    </pre>
  </dd>
  <dt>sv_setref_pvn</dt>
  <dd>Copies a string into a new SV, optionally blessing the SV. The length of
      the string must be specified with <span class="Li">&quot;n&quot;</span>.
      The <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an
      RV. That RV will be modified to point to the new SV. The
      <span class="Li">&quot;classname&quot;</span> argument indicates the
      package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.
    <p class="Pp">Note that <span class="Li">&quot;sv_setref_pv&quot;</span>
        copies the pointer while this copies the string.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_setref_pvn(SV *const rv,
                              const char *const classname,
                              const char *const pv,
                              const STRLEN n)
    </pre>
  </dd>
  <dt>sv_setref_pvs</dt>
  <dd>Like <span class="Li">&quot;sv_setref_pvn&quot;</span>, but takes a
      literal string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    sv_setref_pvs(&quot;literal string&quot; s)
    </pre>
  </dd>
  <dt>sv_setref_uv</dt>
  <dd>Copies an unsigned integer into a new SV, optionally blessing the SV. The
      <span class="Li">&quot;rv&quot;</span> argument will be upgraded to an RV.
      That RV will be modified to point to the new SV. The
      <span class="Li">&quot;classname&quot;</span> argument indicates the
      package for the blessing. Set
      <span class="Li">&quot;classname&quot;</span> to
      <span class="Li">&quot;NULL&quot;</span> to avoid the blessing. The new SV
      will have a reference count of 1, and the RV will be returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_setref_uv(SV *const rv,
                             const char *const classname,
                             const UV uv)
    </pre>
  </dd>
  <dt>sv_setsv</dt>
  <dd>Copies the contents of the source SV
      <span class="Li">&quot;ssv&quot;</span> into the destination SV
      <span class="Li">&quot;dsv&quot;</span>. The source SV may be destroyed if
      it is mortal, so don't use this function if the source SV needs to be
      reused. Does not handle 'set' magic on destination SV. Calls 'get' magic
      on source SV. Loosely speaking, it performs a copy-by-value, obliterating
      any previous content of the destination.
    <p class="Pp">You probably want to use one of the assortment of wrappers,
        such as <span class="Li">&quot;SvSetSV&quot;</span>,
        <span class="Li">&quot;SvSetSV_nosteal&quot;</span>,
        <span class="Li">&quot;SvSetMagicSV&quot;</span> and
        <span class="Li">&quot;SvSetMagicSV_nosteal&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setsv(SV *dstr, SV *sstr)
    </pre>
  </dd>
  <dt>sv_setsv_flags</dt>
  <dd>Copies the contents of the source SV
      <span class="Li">&quot;ssv&quot;</span> into the destination SV
      <span class="Li">&quot;dsv&quot;</span>. The source SV may be destroyed if
      it is mortal, so don't use this function if the source SV needs to be
      reused. Does not handle 'set' magic. Loosely speaking, it performs a
      copy-by-value, obliterating any previous content of the destination. If
      the <span class="Li">&quot;flags&quot;</span> parameter has the
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, will
      <span class="Li">&quot;mg_get&quot;</span> on
      <span class="Li">&quot;ssv&quot;</span> if appropriate, else not. If the
      <span class="Li">&quot;flags&quot;</span> parameter has the
      <span class="Li">&quot;SV_NOSTEAL&quot;</span> bit set then the buffers of
      temps will not be stolen. <span class="Li">&quot;sv_setsv&quot;</span> and
      <span class="Li">&quot;sv_setsv_nomg&quot;</span> are implemented in terms
      of this function.
    <p class="Pp">You probably want to use one of the assortment of wrappers,
        such as <span class="Li">&quot;SvSetSV&quot;</span>,
        <span class="Li">&quot;SvSetSV_nosteal&quot;</span>,
        <span class="Li">&quot;SvSetMagicSV&quot;</span> and
        <span class="Li">&quot;SvSetMagicSV_nosteal&quot;</span>.</p>
    <p class="Pp">This is the primary function for copying scalars, and most
        other copy-ish functions and macros use this underneath.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setsv_flags(SV *dstr, SV *sstr,
                               const I32 flags)
    </pre>
  </dd>
  <dt>sv_setsv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setsv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setsv_mg(SV *const dstr, SV *const sstr)
    </pre>
  </dd>
  <dt>sv_setsv_nomg</dt>
  <dd>Like <span class="Li">&quot;sv_setsv&quot;</span> but doesn't process
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setsv_nomg(SV* dsv, SV* ssv)
    </pre>
  </dd>
  <dt>sv_setuv</dt>
  <dd>Copies an unsigned integer into the given SV, upgrading first if
      necessary. Does not handle 'set' magic. See also
      <span class="Li">&quot;sv_setuv_mg&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setuv(SV *const sv, const UV num)
    </pre>
  </dd>
  <dt>sv_setuv_mg</dt>
  <dd>Like <span class="Li">&quot;sv_setuv&quot;</span>, but also handles 'set'
      magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_setuv_mg(SV *const sv, const UV u)
    </pre>
  </dd>
  <dt>sv_set_undef</dt>
  <dd>Equivalent to <span class="Li">&quot;sv_setsv(sv,
      &amp;PL_sv_undef)&quot;</span>, but more efficient. Doesn't handle set
      magic.
    <p class="Pp">The perl equivalent is <span class="Li">&quot;$sv =
        undef;&quot;</span>. Note that it doesn't free any string buffer, unlike
        <span class="Li">&quot;undef $sv&quot;</span>.</p>
    <p class="Pp">Introduced in perl 5.25.12.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_set_undef(SV *sv)
    </pre>
  </dd>
  <dt>SvSTASH</dt>
  <dd>Returns the stash of the SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV*     SvSTASH(SV* sv)
    </pre>
  </dd>
  <dt>SvSTASH_set</dt>
  <dd>Set the value of the STASH pointer in
      <span class="Li">&quot;sv&quot;</span> to val. See
      <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvSTASH_set(SV* sv, HV* val)
    </pre>
  </dd>
  <dt>SvTAINT</dt>
  <dd>Taints an SV if tainting is enabled, and if some input to the current
      expression is tainted--usually a variable, but possibly also implicit
      inputs such as locale settings.
      <span class="Li">&quot;SvTAINT&quot;</span> propagates that taintedness to
      the outputs of an expression in a pessimistic fashion; i.e., without
      paying attention to precisely which outputs are influenced by which
      inputs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvTAINT(SV* sv)
    </pre>
  </dd>
  <dt>SvTAINTED</dt>
  <dd>Checks to see if an SV is tainted. Returns TRUE if it is, FALSE if not.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvTAINTED(SV* sv)
    </pre>
  </dd>
  <dt>sv_tainted</dt>
  <dd>Test an SV for taintedness. Use
      <span class="Li">&quot;SvTAINTED&quot;</span> instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_tainted(SV *const sv)
    </pre>
  </dd>
  <dt>SvTAINTED_off</dt>
  <dd>Untaints an SV. Be <i>very</i> careful with this routine, as it
      short-circuits some of Perl's fundamental security features. XS module
      authors should not use this function unless they fully understand all the
      implications of unconditionally untainting the value. Untainting should be
      done in the standard perl fashion, via a carefully crafted regexp, rather
      than directly untainting variables.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvTAINTED_off(SV* sv)
    </pre>
  </dd>
  <dt>SvTAINTED_on</dt>
  <dd>Marks an SV as tainted if tainting is enabled.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvTAINTED_on(SV* sv)
    </pre>
  </dd>
  <dt>SvTRUE</dt>
  <dd>Returns a boolean indicating whether Perl would evaluate the SV as true or
      false. See <span class="Li">&quot;SvOK&quot;</span> for a
      defined/undefined test. Handles 'get' magic unless the scalar is already
      <span class="Li">&quot;SvPOK&quot;</span>,
      <span class="Li">&quot;SvIOK&quot;</span> or
      <span class="Li">&quot;SvNOK&quot;</span> (the public, not the private
      flags).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvTRUE(SV* sv)
    </pre>
  </dd>
  <dt>sv_true</dt>
  <dd>Returns true if the SV has a true value by Perl's rules. Use the
      <span class="Li">&quot;SvTRUE&quot;</span> macro instead, which may call
      <span class="Li">&quot;sv_true()&quot;</span> or may instead use an
      in-line version.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_true(SV *const sv)
    </pre>
  </dd>
  <dt>SvTRUE_nomg</dt>
  <dd>Returns a boolean indicating whether Perl would evaluate the SV as true or
      false. See <span class="Li">&quot;SvOK&quot;</span> for a
      defined/undefined test. Does not handle 'get' magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvTRUE_nomg(SV* sv)
    </pre>
  </dd>
  <dt>SvTYPE</dt>
  <dd>Returns the type of the SV. See
      <span class="Li">&quot;svtype&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        svtype  SvTYPE(SV* sv)
    </pre>
  </dd>
  <dt>sv_unmagic</dt>
  <dd>Removes all magic of type <span class="Li">&quot;type&quot;</span> from an
      SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     sv_unmagic(SV *const sv, const int type)
    </pre>
  </dd>
  <dt>sv_unmagicext</dt>
  <dd>Removes all magic of type <span class="Li">&quot;type&quot;</span> with
      the specified <span class="Li">&quot;vtbl&quot;</span> from an SV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     sv_unmagicext(SV *const sv, const int type,
                              MGVTBL *vtbl)
    </pre>
  </dd>
  <dt>sv_unref_flags</dt>
  <dd>Unsets the RV status of the SV, and decrements the reference count of
      whatever was being referenced by the RV. This can almost be thought of as
      a reversal of <span class="Li">&quot;newSVrv&quot;</span>. The
      <span class="Li">&quot;cflags&quot;</span> argument can contain
      <span class="Li">&quot;SV_IMMEDIATE_UNREF&quot;</span> to force the
      reference count to be decremented (otherwise the decrementing is
      conditional on the reference count being different from one or the
      reference being a readonly SV). See
      <span class="Li">&quot;SvROK_off&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_unref_flags(SV *const ref, const U32 flags)
    </pre>
  </dd>
  <dt>sv_untaint</dt>
  <dd>Untaint an SV. Use <span class="Li">&quot;SvTAINTED_off&quot;</span>
      instead.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_untaint(SV *const sv)
    </pre>
  </dd>
  <dt>SvUOK</dt>
  <dd>Returns a boolean indicating whether the SV contains an integer that must
      be interpreted as unsigned. A non-negative integer whose value is within
      the range of both an IV and a UV may be be flagged as either
      <span class="Li">&quot;SvUOK&quot;</span> or
      <span class="Li">&quot;SVIOK&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvUOK(SV* sv)
    </pre>
  </dd>
  <dt>SvUPGRADE</dt>
  <dd>Used to upgrade an SV to a more complex form. Uses
      <span class="Li">&quot;sv_upgrade&quot;</span> to perform the upgrade if
      necessary. See <span class="Li">&quot;svtype&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvUPGRADE(SV* sv, svtype type)
    </pre>
  </dd>
  <dt>sv_upgrade</dt>
  <dd>Upgrade an SV to a more complex form. Generally adds a new body type to
      the SV, then copies across as much information as possible from the old
      body. It croaks if the SV is already in a more complex form than
      requested. You generally want to use the
      <span class="Li">&quot;SvUPGRADE&quot;</span> macro wrapper, which checks
      the type before calling <span class="Li">&quot;sv_upgrade&quot;</span>,
      and hence does not croak. See also
      <span class="Li">&quot;svtype&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_upgrade(SV *const sv, svtype new_type)
    </pre>
  </dd>
  <dt>sv_usepvn_flags</dt>
  <dd>Tells an SV to use <span class="Li">&quot;ptr&quot;</span> to find its
      string value. Normally the string is stored inside the SV, but sv_usepvn
      allows the SV to use an outside string.
      <span class="Li">&quot;ptr&quot;</span> should point to memory that was
      allocated by <span class="Li">&quot;Newx&quot;</span>. It must be the
      start of a <span class="Li">&quot;Newx&quot;</span>-ed block of memory,
      and not a pointer to the middle of it (beware of
      <span class="Li">&quot;OOK&quot;</span> and copy-on-write), and not be
      from a non-<span class="Li">&quot;Newx&quot;</span> memory allocator like
      <span class="Li">&quot;malloc&quot;</span>. The string length,
      <span class="Li">&quot;len&quot;</span>, must be supplied. By default this
      function will <span class="Li">&quot;Renew&quot;</span> (i.e. realloc,
      move) the memory pointed to by <span class="Li">&quot;ptr&quot;</span>, so
      that pointer should not be freed or used by the programmer after giving it
      to <span class="Li">&quot;sv_usepvn&quot;</span>, and neither should any
      pointers from &quot;behind&quot; that pointer (e.g. ptr + 1) be used.
    <p class="Pp">If
        <span class="Li">&quot;flags&#x00A0;&amp;&#x00A0;SV_SMAGIC&quot;</span>
        is true, will call <span class="Li">&quot;SvSETMAGIC&quot;</span>. If
        <span class="Li">&quot;flags&#x00A0;&amp;&#x00A0;SV_HAS_TRAILING_NUL&quot;</span>
        is true, then <span class="Li">&quot;ptr[len]&quot;</span> must be
        <span class="Li">&quot;NUL&quot;</span>, and the realloc will be skipped
        (i.e. the buffer is actually at least 1 byte longer than
        <span class="Li">&quot;len&quot;</span>, and already meets the
        requirements for storing in
      <span class="Li">&quot;SvPVX&quot;</span>).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_usepvn_flags(SV *const sv, char* ptr,
                                const STRLEN len,
                                const U32 flags)
    </pre>
  </dd>
  <dt>SvUTF8</dt>
  <dd>Returns a U32 value indicating the UTF-8 status of an SV. If things are
      set-up properly, this indicates whether or not the SV contains UTF-8
      encoded data. You should use this <i>after</i> a call to
      <span class="Li">&quot;SvPV()&quot;</span> or one of its variants, in case
      any call to string overloading updates the internal flag.
    <p class="Pp">If you want to take into account the bytes pragma, use
        <span class="Li">&quot;DO_UTF8&quot;</span> instead.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvUTF8(SV* sv)
    </pre>
  </dd>
  <dt>sv_utf8_decode</dt>
  <dd>If the PV of the SV is an octet sequence in Perl's extended UTF-8 and
      contains a multiple-byte character, the
      <span class="Li">&quot;SvUTF8&quot;</span> flag is turned on so that it
      looks like a character. If the PV contains only single-byte characters,
      the <span class="Li">&quot;SvUTF8&quot;</span> flag stays off. Scans PV
      for validity and returns FALSE if the PV is invalid UTF-8.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_utf8_decode(SV *const sv)
    </pre>
  </dd>
  <dt>sv_utf8_downgrade</dt>
  <dd>Attempts to convert the PV of an SV from characters to bytes. If the PV
      contains a character that cannot fit in a byte, this conversion will fail;
      in this case, either returns false or, if
      <span class="Li">&quot;fail_ok&quot;</span> is not true, croaks.
    <p class="Pp">This is not a general purpose Unicode to byte encoding
        interface: use the <span class="Li">&quot;Encode&quot;</span> extension
        for that.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_utf8_downgrade(SV *const sv,
                                  const bool fail_ok)
    </pre>
  </dd>
  <dt>sv_utf8_encode</dt>
  <dd>Converts the PV of an SV to UTF-8, but then turns the
      <span class="Li">&quot;SvUTF8&quot;</span> flag off so that it looks like
      octets again.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_utf8_encode(SV *const sv)
    </pre>
  </dd>
  <dt>sv_utf8_upgrade</dt>
  <dd>Converts the PV of an SV to its UTF-8-encoded form. Forces the SV to
      string form if it is not already. Will
      <span class="Li">&quot;mg_get&quot;</span> on
      <span class="Li">&quot;sv&quot;</span> if appropriate. Always sets the
      <span class="Li">&quot;SvUTF8&quot;</span> flag to avoid future validity
      checks even if the whole string is the same in UTF-8 as not. Returns the
      number of bytes in the converted string
    <p class="Pp">This is not a general purpose byte encoding to Unicode
        interface: use the Encode extension for that.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_utf8_upgrade(SV *sv)
    </pre>
  </dd>
  <dt>sv_utf8_upgrade_flags</dt>
  <dd>Converts the PV of an SV to its UTF-8-encoded form. Forces the SV to
      string form if it is not already. Always sets the SvUTF8 flag to avoid
      future validity checks even if all the bytes are invariant in UTF-8. If
      <span class="Li">&quot;flags&quot;</span> has
      <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set, will
      <span class="Li">&quot;mg_get&quot;</span> on
      <span class="Li">&quot;sv&quot;</span> if appropriate, else not.
    <p class="Pp">The <span class="Li">&quot;SV_FORCE_UTF8_UPGRADE&quot;</span>
        flag is now ignored.</p>
    <p class="Pp">Returns the number of bytes in the converted string.</p>
    <p class="Pp">This is not a general purpose byte encoding to Unicode
        interface: use the Encode extension for that.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_utf8_upgrade_flags(SV *const sv,
                                      const I32 flags)
    </pre>
  </dd>
  <dt>sv_utf8_upgrade_flags_grow</dt>
  <dd>Like <span class="Li">&quot;sv_utf8_upgrade_flags&quot;</span>, but has an
      additional parameter <span class="Li">&quot;extra&quot;</span>, which is
      the number of unused bytes the string of
      <span class="Li">&quot;sv&quot;</span> is guaranteed to have free after it
      upon return. This allows the caller to reserve extra space that it intends
      to fill, to avoid extra grows.
    <p class="Pp"><span class="Li">&quot;sv_utf8_upgrade&quot;</span>,
        <span class="Li">&quot;sv_utf8_upgrade_nomg&quot;</span>, and
        <span class="Li">&quot;sv_utf8_upgrade_flags&quot;</span> are
        implemented in terms of this function.</p>
    <p class="Pp">Returns the number of bytes in the converted string (not
        including the spares).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_utf8_upgrade_flags_grow(SV *const sv,
                                           const I32 flags,
                                           STRLEN extra)
    </pre>
  </dd>
  <dt>sv_utf8_upgrade_nomg</dt>
  <dd>Like <span class="Li">&quot;sv_utf8_upgrade&quot;</span>, but doesn't do
      magic on <span class="Li">&quot;sv&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  sv_utf8_upgrade_nomg(SV *sv)
    </pre>
  </dd>
  <dt>SvUTF8_off</dt>
  <dd>Unsets the UTF-8 status of an SV (the data is not changed, just the flag).
      Do not use frivolously.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvUTF8_off(SV *sv)
    </pre>
  </dd>
  <dt>SvUTF8_on</dt>
  <dd>Turn on the UTF-8 status of an SV (the data is not changed, just the
      flag). Do not use frivolously.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvUTF8_on(SV *sv)
    </pre>
  </dd>
  <dt>SvUV</dt>
  <dd>Coerces the given SV to UV and returns it. The returned value in many
      circumstances will get stored in <span class="Li">&quot;sv&quot;</span>'s
      UV slot, but not in all cases. (Use
      <span class="Li">&quot;sv_setuv&quot;</span> to make sure it does).
    <p class="Pp">See <span class="Li">&quot;SvUVx&quot;</span> for a version
        which guarantees to evaluate <span class="Li">&quot;sv&quot;</span> only
        once.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      SvUV(SV* sv)
    </pre>
  </dd>
  <dt>SvUV_nomg</dt>
  <dd>Like <span class="Li">&quot;SvUV&quot;</span> but doesn't process magic.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      SvUV_nomg(SV* sv)
    </pre>
  </dd>
  <dt>SvUV_set</dt>
  <dd>Set the value of the UV pointer in <span class="Li">&quot;sv&quot;</span>
      to val. See <span class="Li">&quot;SvIV_set&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SvUV_set(SV* sv, UV val)
    </pre>
  </dd>
  <dt>SvUVX</dt>
  <dd>Returns the raw value in the SV's UV slot, without checks or conversions.
      Only use when you are sure <span class="Li">&quot;SvIOK&quot;</span> is
      true. See also <span class="Li">&quot;SvUV&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      SvUVX(SV* sv)
    </pre>
  </dd>
  <dt>SvUVx</dt>
  <dd>Coerces the given SV to UV and returns it. The returned value in many
      circumstances will get stored in <span class="Li">&quot;sv&quot;</span>'s
      UV slot, but not in all cases. (Use
      <span class="Li">&quot;sv_setuv&quot;</span> to make sure it does).
    <p class="Pp">This form guarantees to evaluate
        <span class="Li">&quot;sv&quot;</span> only once. Only use this if
        <span class="Li">&quot;sv&quot;</span> is an expression with side
        effects, otherwise use the more efficient
        <span class="Li">&quot;SvUV&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      SvUVx(SV* sv)
    </pre>
  </dd>
  <dt>sv_vcatpvf</dt>
  <dd>Processes its arguments like
      <span class="Li">&quot;sv_vcatpvfn&quot;</span> called with a non-null
      C-style variable argument list, and appends the formatted output to an SV.
      Does not handle 'set' magic. See
      <span class="Li">&quot;sv_vcatpvf_mg&quot;</span>.
    <p class="Pp">Usually used via its frontend
        <span class="Li">&quot;sv_catpvf&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_vcatpvf(SV *const sv, const char *const pat,
                           va_list *const args)
    </pre>
  </dd>
  <dt>sv_vcatpvfn</dt>
  <dd><span class="Li"></span>
    <pre>
        void    sv_vcatpvfn(SV *const sv, const char *const pat,
                            const STRLEN patlen,
                            va_list *const args,
                            SV **const svargs,
                            const Size_t sv_count,
                            bool *const maybe_tainted)
    </pre>
  </dd>
  <dt>sv_vcatpvfn_flags</dt>
  <dd>Processes its arguments like <span class="Li">&quot;vsprintf&quot;</span>
      and appends the formatted output to an SV. Uses an array of SVs if the
      C-style variable argument list is missing
      (<span class="Li">&quot;NULL&quot;</span>). Argument reordering (using
      format specifiers like <span class="Li">&quot;%2$d&quot;</span> or
      <span class="Li">&quot;%*2$d&quot;</span>) is supported only when using an
      array of SVs; using a C-style <span class="Li">&quot;va_list&quot;</span>
      argument list with a format string that uses argument reordering will
      yield an exception.
    <p class="Pp">When running with taint checks enabled, indicates via
        <span class="Li">&quot;maybe_tainted&quot;</span> if results are
        untrustworthy (often due to the use of locales).</p>
    <p class="Pp">If called as <span class="Li">&quot;sv_vcatpvfn&quot;</span>
        or flags has the <span class="Li">&quot;SV_GMAGIC&quot;</span> bit set,
        calls get magic.</p>
    <p class="Pp">It assumes that pat has the same utf8-ness as sv. It's the
        caller's responsibility to ensure that this is so.</p>
    <p class="Pp">Usually used via one of its frontends
        <span class="Li">&quot;sv_vcatpvf&quot;</span> and
        <span class="Li">&quot;sv_vcatpvf_mg&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_vcatpvfn_flags(SV *const sv,
                                  const char *const pat,
                                  const STRLEN patlen,
                                  va_list *const args,
                                  SV **const svargs,
                                  const Size_t sv_count,
                                  bool *const maybe_tainted,
                                  const U32 flags)
    </pre>
  </dd>
  <dt>sv_vcatpvf_mg</dt>
  <dd>Like <span class="Li">&quot;sv_vcatpvf&quot;</span>, but also handles
      'set' magic.
    <p class="Pp">Usually used via its frontend
        <span class="Li">&quot;sv_catpvf_mg&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_vcatpvf_mg(SV *const sv,
                              const char *const pat,
                              va_list *const args)
    </pre>
  </dd>
  <dt>SvVOK</dt>
  <dd>Returns a boolean indicating whether the SV contains a v-string.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    SvVOK(SV* sv)
    </pre>
  </dd>
  <dt>sv_vsetpvf</dt>
  <dd>Works like <span class="Li">&quot;sv_vcatpvf&quot;</span> but copies the
      text into the SV instead of appending it. Does not handle 'set' magic. See
      <span class="Li">&quot;sv_vsetpvf_mg&quot;</span>.
    <p class="Pp">Usually used via its frontend
        <span class="Li">&quot;sv_setpvf&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_vsetpvf(SV *const sv, const char *const pat,
                           va_list *const args)
    </pre>
  </dd>
  <dt>sv_vsetpvfn</dt>
  <dd>Works like <span class="Li">&quot;sv_vcatpvfn&quot;</span> but copies the
      text into the SV instead of appending it.
    <p class="Pp">Usually used via one of its frontends
        <span class="Li">&quot;sv_vsetpvf&quot;</span> and
        <span class="Li">&quot;sv_vsetpvf_mg&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_vsetpvfn(SV *const sv, const char *const pat,
                            const STRLEN patlen,
                            va_list *const args,
                            SV **const svargs,
                            const Size_t sv_count,
                            bool *const maybe_tainted)
    </pre>
  </dd>
  <dt>sv_vsetpvf_mg</dt>
  <dd>Like <span class="Li">&quot;sv_vsetpvf&quot;</span>, but also handles
      'set' magic.
    <p class="Pp">Usually used via its frontend
        <span class="Li">&quot;sv_setpvf_mg&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_vsetpvf_mg(SV *const sv,
                              const char *const pat,
                              va_list *const args)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Unicode_Support"><a class="permalink" href="#Unicode_Support">Unicode
  Support</a></h1>
&quot;Unicode Support&quot; in perlguts has an introduction to this API.
<p class="Pp">See also &quot;Character classification&quot;, and &quot;Character
    case changing&quot;. Various functions outside this section also work
    specially with Unicode. Search for the string &quot;utf8&quot; in this
    document.</p>
<dl class="Bl-tag">
  <dt>BOM_UTF8</dt>
  <dd>This is a macro that evaluates to a string constant of the UTF-8 bytes
      that define the Unicode BYTE ORDER MARK (U+FEFF) for the platform that
      perl is compiled on. This allows code to use a mnemonic for this character
      that works on both ASCII and EBCDIC platforms.
      <span class="Li">&quot;sizeof(BOM_UTF8)&#x00A0;-&#x00A0;1&quot;</span> can
      be used to get its length in bytes.</dd>
  <dt>bytes_cmp_utf8</dt>
  <dd>Compares the sequence of characters (stored as octets) in
      <span class="Li">&quot;b&quot;</span>,
      <span class="Li">&quot;blen&quot;</span> with the sequence of characters
      (stored as UTF-8) in <span class="Li">&quot;u&quot;</span>,
      <span class="Li">&quot;ulen&quot;</span>. Returns 0 if they are equal, -1
      or -2 if the first string is less than the second string, +1 or +2 if the
      first string is greater than the second string.
    <p class="Pp">-1 or +1 is returned if the shorter string was identical to
        the start of the longer string. -2 or +2 is returned if there was a
        difference between characters within the strings.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     bytes_cmp_utf8(const U8 *b, STRLEN blen,
                               const U8 *u, STRLEN ulen)
    </pre>
  </dd>
  <dt>bytes_from_utf8</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Converts a potentially UTF-8 encoded string
        <span class="Li">&quot;s&quot;</span> of length
        <span class="Li">*lenp</span> into native byte encoding. On input, the
        boolean <span class="Li">*is_utf8p</span> gives whether or not
        <span class="Li">&quot;s&quot;</span> is actually encoded in UTF-8.</p>
    <p class="Pp">Unlike &quot;utf8_to_bytes&quot; but like
        &quot;bytes_to_utf8&quot;, this is non-destructive of the input
      string.</p>
    <p class="Pp">Do nothing if <span class="Li">*is_utf8p</span> is 0, or if
        there are code points in the string not expressible in native byte
        encoding. In these cases, <span class="Li">*is_utf8p</span> and
        <span class="Li">*lenp</span> are unchanged, and the return value is the
        original <span class="Li">&quot;s&quot;</span>.</p>
    <p class="Pp">Otherwise, <span class="Li">*is_utf8p</span> is set to 0, and
        the return value is a pointer to a newly created string containing a
        downgraded copy of <span class="Li">&quot;s&quot;</span>, and whose
        length is returned in <span class="Li">*lenp</span>, updated. The new
        string is <span class="Li">&quot;NUL&quot;</span>-terminated. The caller
        is responsible for arranging for the memory used by this string to get
        freed.</p>
    <p class="Pp">Upon successful return, the number of variants in the string
        can be computed by having saved the value of
        <span class="Li">*lenp</span> before the call, and subtracting the
        after-call value of <span class="Li">*lenp</span> from it.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     bytes_from_utf8(const U8 *s, STRLEN *lenp,
                                bool *is_utf8p)
    </pre>
  </dd>
  <dt>bytes_to_utf8</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Converts a string <span class="Li">&quot;s&quot;</span> of
        length <span class="Li">*lenp</span> bytes from the native encoding into
        UTF-8. Returns a pointer to the newly-created string, and sets
        <span class="Li">*lenp</span> to reflect the new length in bytes. The
        caller is responsible for arranging for the memory used by this string
        to get freed.</p>
    <p class="Pp">Upon successful return, the number of variants in the string
        can be computed by having saved the value of
        <span class="Li">*lenp</span> before the call, and subtracting it from
        the after-call value of <span class="Li">*lenp</span>.</p>
    <p class="Pp">A <span class="Li">&quot;NUL&quot;</span> character will be
        written after the end of the string.</p>
    <p class="Pp">If you want to convert to UTF-8 from encodings other than the
        native (Latin1 or EBCDIC), see &quot;sv_recode_to_utf8&quot;().</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     bytes_to_utf8(const U8 *s, STRLEN *lenp)
    </pre>
  </dd>
  <dt>DO_UTF8</dt>
  <dd>Returns a bool giving whether or not the PV in
      <span class="Li">&quot;sv&quot;</span> is to be treated as being encoded
      in UTF-8.
    <p class="Pp">You should use this <i>after</i> a call to
        <span class="Li">&quot;SvPV()&quot;</span> or one of its variants, in
        case any call to string overloading updates the internal UTF-8 encoding
        flag.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    DO_UTF8(SV* sv)
    </pre>
  </dd>
  <dt>foldEQ_utf8</dt>
  <dd>Returns true if the leading portions of the strings
      <span class="Li">&quot;s1&quot;</span> and
      <span class="Li">&quot;s2&quot;</span> (either or both of which may be in
      UTF-8) are the same case-insensitively; false otherwise. How far into the
      strings to compare is determined by other input parameters.
    <p class="Pp">If <span class="Li">&quot;u1&quot;</span> is true, the string
        <span class="Li">&quot;s1&quot;</span> is assumed to be in UTF-8-encoded
        Unicode; otherwise it is assumed to be in native 8-bit encoding.
        Correspondingly for <span class="Li">&quot;u2&quot;</span> with respect
        to <span class="Li">&quot;s2&quot;</span>.</p>
    <p class="Pp">If the byte length <span class="Li">&quot;l1&quot;</span> is
        non-zero, it says how far into <span class="Li">&quot;s1&quot;</span> to
        check for fold equality. In other words,
        <span class="Li">&quot;s1&quot;</span>+<span class="Li">&quot;l1&quot;</span>
        will be used as a goal to reach. The scan will not be considered to be a
        match unless the goal is reached, and scanning won't continue past that
        goal. Correspondingly for <span class="Li">&quot;l2&quot;</span> with
        respect to <span class="Li">&quot;s2&quot;</span>.</p>
    <p class="Pp">If <span class="Li">&quot;pe1&quot;</span> is
        non-<span class="Li">&quot;NULL&quot;</span> and the pointer it points
        to is not <span class="Li">&quot;NULL&quot;</span>, that pointer is
        considered an end pointer to the position 1 byte past the maximum point
        in <span class="Li">&quot;s1&quot;</span> beyond which scanning will not
        continue under any circumstances. (This routine assumes that UTF-8
        encoded input strings are not malformed; malformed input can cause it to
        read past <span class="Li">&quot;pe1&quot;</span>). This means that if
        both <span class="Li">&quot;l1&quot;</span> and
        <span class="Li">&quot;pe1&quot;</span> are specified, and
        <span class="Li">&quot;pe1&quot;</span> is less than
        <span class="Li">&quot;s1&quot;</span>+<span class="Li">&quot;l1&quot;</span>,
        the match will never be successful because it can never get as far as
        its goal (and in fact is asserted against). Correspondingly for
        <span class="Li">&quot;pe2&quot;</span> with respect to
        <span class="Li">&quot;s2&quot;</span>.</p>
    <p class="Pp">At least one of <span class="Li">&quot;s1&quot;</span> and
        <span class="Li">&quot;s2&quot;</span> must have a goal (at least one of
        <span class="Li">&quot;l1&quot;</span> and
        <span class="Li">&quot;l2&quot;</span> must be non-zero), and if both
        do, both have to be reached for a successful match. Also, if the fold of
        a character is multiple characters, all of them must be matched (see
        tr21 reference below for 'folding').</p>
    <p class="Pp">Upon a successful match, if
        <span class="Li">&quot;pe1&quot;</span> is
        non-<span class="Li">&quot;NULL&quot;</span>, it will be set to point to
        the beginning of the <i>next</i> character of
        <span class="Li">&quot;s1&quot;</span> beyond what was matched.
        Correspondingly for <span class="Li">&quot;pe2&quot;</span> and
        <span class="Li">&quot;s2&quot;</span>.</p>
    <p class="Pp">For case-insensitiveness, the &quot;casefolding&quot; of
        Unicode is used instead of upper/lowercasing both the characters, see
        &lt;http://www.unicode.org/unicode/reports/tr21/&gt; (Case
      Mappings).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     foldEQ_utf8(const char *s1, char **pe1, UV l1,
                            bool u1, const char *s2, char **pe2,
                            UV l2, bool u2)
    </pre>
  </dd>
  <dt>is_ascii_string</dt>
  <dd>This is a misleadingly-named synonym for
      &quot;is_utf8_invariant_string&quot;. On ASCII-ish platforms, the name
      isn't misleading: the ASCII-range characters are exactly the UTF-8
      invariants. But EBCDIC machines have more invariants than just the ASCII
      characters, so
      <span class="Li">&quot;is_utf8_invariant_string&quot;</span> is preferred.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_ascii_string(const U8* const s, STRLEN len)
    </pre>
  </dd>
  <dt>is_c9strict_utf8_string</dt>
  <dd>Returns TRUE if the first <span class="Li">&quot;len&quot;</span> bytes of
      string <span class="Li">&quot;s&quot;</span> form a valid UTF-8-encoded
      string that conforms to Unicode Corrigendum #9
      &lt;http://www.unicode.org/versions/corrigendum9.html&gt;; otherwise it
      returns FALSE. If <span class="Li">&quot;len&quot;</span> is 0, it will be
      calculated using <span class="Li">strlen(s)</span> (which means if you use
      this option, that <span class="Li">&quot;s&quot;</span> can't have
      embedded <span class="Li">&quot;NUL&quot;</span> characters and has to
      have a terminating <span class="Li">&quot;NUL&quot;</span> byte). Note
      that all characters being ASCII constitute 'a valid UTF-8 string'.
    <p class="Pp">This function returns FALSE for strings containing any code
        points above the Unicode max of 0x10FFFF or surrogate code points, but
        accepts non-character code points per Corrigendum #9
        &lt;http://www.unicode.org/versions/corrigendum9.html&gt;.</p>
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_invariant_string&quot;</span>,
        <span class="Li">&quot;is_utf8_invariant_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string&quot;</span>,
        <span class="Li">&quot;is_utf8_string_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_c9strict_utf8_string_loclen&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_c9strict_utf8_string(const U8 *s, STRLEN len)
    </pre>
  </dd>
  <dt>is_c9strict_utf8_string_loc</dt>
  <dd>Like <span class="Li">&quot;is_c9strict_utf8_string&quot;</span> but
      stores the location of the failure (in the case of &quot;utf8ness
      failure&quot;) or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_c9strict_utf8_string_loclen&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_c9strict_utf8_string_loc(const U8 *s,
                                            STRLEN len,
                                            const U8 **ep)
    </pre>
  </dd>
  <dt>is_c9strict_utf8_string_loclen</dt>
  <dd>Like <span class="Li">&quot;is_c9strict_utf8_string&quot;</span> but
      stores the location of the failure (in the case of &quot;utf8ness
      failure&quot;) or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer, and the number of UTF-8
      encoded characters in the <span class="Li">&quot;el&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_c9strict_utf8_string_loc&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_c9strict_utf8_string_loclen(const U8 *s,
                                               STRLEN len,
                                               const U8 **ep,
                                               STRLEN *el)
    </pre>
  </dd>
  <dt>isC9_STRICT_UTF8_CHAR</dt>
  <dd>Evaluates to non-zero if the first few bytes of the string starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are well-formed
      UTF-8 that represents some Unicode non-surrogate code point; otherwise it
      evaluates to 0. If non-zero, the value gives how many bytes starting at
      <span class="Li">&quot;s&quot;</span> comprise the code point's
      representation. Any bytes remaining before
      <span class="Li">&quot;e&quot;</span>, but beyond the ones needed to form
      the first code point in <span class="Li">&quot;s&quot;</span>, are not
      examined.
    <p class="Pp">The largest acceptable code point is the Unicode maximum
        0x10FFFF. This differs from
        <span class="Li">&quot;isSTRICT_UTF8_CHAR&quot;</span> only in that it
        accepts non-character code points. This corresponds to Unicode
        Corrigendum #9
        &lt;http://www.unicode.org/versions/corrigendum9.html&gt;. which said
        that non-character code points are merely discouraged rather than
        completely forbidden in open interchange. See &quot;Noncharacter code
        points&quot; in perlunicode.</p>
    <p class="Pp">Use <span class="Li">&quot;isUTF8_CHAR&quot;</span> to check
        for Perl's extended UTF-8; and
        <span class="Li">&quot;isUTF8_CHAR_flags&quot;</span> for a more
        customized definition.</p>
    <p class="Pp">Use
        <span class="Li">&quot;is_c9strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_c9strict_utf8_string_loclen&quot;</span> to
        check entire strings.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  isC9_STRICT_UTF8_CHAR(const U8 *s, const U8 *e)
    </pre>
  </dd>
  <dt>is_invariant_string</dt>
  <dd>This is a somewhat misleadingly-named synonym for
      &quot;is_utf8_invariant_string&quot;.
      <span class="Li">&quot;is_utf8_invariant_string&quot;</span> is preferred,
      as it indicates under what conditions the string is invariant.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_invariant_string(const U8* const s,
                                    STRLEN len)
    </pre>
  </dd>
  <dt>isSTRICT_UTF8_CHAR</dt>
  <dd>Evaluates to non-zero if the first few bytes of the string starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are well-formed
      UTF-8 that represents some Unicode code point completely acceptable for
      open interchange between all applications; otherwise it evaluates to 0. If
      non-zero, the value gives how many bytes starting at
      <span class="Li">&quot;s&quot;</span> comprise the code point's
      representation. Any bytes remaining before
      <span class="Li">&quot;e&quot;</span>, but beyond the ones needed to form
      the first code point in <span class="Li">&quot;s&quot;</span>, are not
      examined.
    <p class="Pp">The largest acceptable code point is the Unicode maximum
        0x10FFFF, and must not be a surrogate nor a non-character code point.
        Thus this excludes any code point from Perl's extended UTF-8.</p>
    <p class="Pp">This is used to efficiently decide if the next few bytes in
        <span class="Li">&quot;s&quot;</span> is legal Unicode-acceptable UTF-8
        for a single character.</p>
    <p class="Pp">Use <span class="Li">&quot;isC9_STRICT_UTF8_CHAR&quot;</span>
        to use the Unicode Corrigendum #9
        &lt;http://www.unicode.org/versions/corrigendum9.html&gt; definition of
        allowable code points; <span class="Li">&quot;isUTF8_CHAR&quot;</span>
        to check for Perl's extended UTF-8; and
        <span class="Li">&quot;isUTF8_CHAR_flags&quot;</span> for a more
        customized definition.</p>
    <p class="Pp">Use <span class="Li">&quot;is_strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_strict_utf8_string_loclen&quot;</span> to
        check entire strings.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        Size_t  isSTRICT_UTF8_CHAR(const U8 * const s0,
                                   const U8 * const e)
    </pre>
  </dd>
  <dt>is_strict_utf8_string</dt>
  <dd>Returns TRUE if the first <span class="Li">&quot;len&quot;</span> bytes of
      string <span class="Li">&quot;s&quot;</span> form a valid UTF-8-encoded
      string that is fully interchangeable by any application using Unicode
      rules; otherwise it returns FALSE. If
      <span class="Li">&quot;len&quot;</span> is 0, it will be calculated using
      <span class="Li">strlen(s)</span> (which means if you use this option,
      that <span class="Li">&quot;s&quot;</span> can't have embedded
      <span class="Li">&quot;NUL&quot;</span> characters and has to have a
      terminating <span class="Li">&quot;NUL&quot;</span> byte). Note that all
      characters being ASCII constitute 'a valid UTF-8 string'.
    <p class="Pp">This function returns FALSE for strings containing any code
        points above the Unicode max of 0x10FFFF, surrogate code points, or
        non-character code points.</p>
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_invariant_string&quot;</span>,
        <span class="Li">&quot;is_utf8_invariant_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string&quot;</span>,
        <span class="Li">&quot;is_utf8_string_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_c9strict_utf8_string_loclen&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_strict_utf8_string(const U8 *s, STRLEN len)
    </pre>
  </dd>
  <dt>is_strict_utf8_string_loc</dt>
  <dd>Like <span class="Li">&quot;is_strict_utf8_string&quot;</span> but stores
      the location of the failure (in the case of &quot;utf8ness failure&quot;)
      or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_strict_utf8_string_loclen&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_strict_utf8_string_loc(const U8 *s,
                                          STRLEN len,
                                          const U8 **ep)
    </pre>
  </dd>
  <dt>is_strict_utf8_string_loclen</dt>
  <dd>Like <span class="Li">&quot;is_strict_utf8_string&quot;</span> but stores
      the location of the failure (in the case of &quot;utf8ness failure&quot;)
      or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer, and the number of UTF-8
      encoded characters in the <span class="Li">&quot;el&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_strict_utf8_string_loc&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_strict_utf8_string_loclen(const U8 *s,
                                             STRLEN len,
                                             const U8 **ep,
                                             STRLEN *el)
    </pre>
  </dd>
  <dt>is_utf8_fixed_width_buf_flags</dt>
  <dd>Returns TRUE if the fixed-width buffer starting at
      <span class="Li">&quot;s&quot;</span> with length
      <span class="Li">&quot;len&quot;</span> is entirely valid UTF-8, subject
      to the restrictions given by <span class="Li">&quot;flags&quot;</span>;
      otherwise it returns FALSE.
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> is 0, any
        well-formed UTF-8, as extended by Perl, is accepted without restriction.
        If the final few bytes of the buffer do not form a complete code point,
        this will return TRUE anyway, provided that
        <span class="Li">&quot;is_utf8_valid_partial_char_flags&quot;</span>
        returns TRUE for them.</p>
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> in non-zero, it
        can be any combination of the
        <span class="Li">&quot;UTF8_DISALLOW_</span>
        <i>foo</i><span class="Li">&quot;</span> flags accepted by
        <span class="Li">&quot;utf8n_to_uvchr&quot;</span>, and with the same
        meanings.</p>
    <p class="Pp">This function differs from
        <span class="Li">&quot;is_utf8_string_flags&quot;</span> only in that
        the latter returns FALSE if the final few bytes of the string don't form
        a complete code point.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_fixed_width_buf_flags(
                    const U8 * const s, STRLEN len,
                    const U32 flags
                )
    </pre>
  </dd>
  <dt>is_utf8_fixed_width_buf_loclen_flags</dt>
  <dd>Like <span class="Li">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</span>
      but stores the number of complete, valid characters found in the
      <span class="Li">&quot;el&quot;</span> pointer.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_fixed_width_buf_loclen_flags(
                    const U8 * const s, STRLEN len,
                    const U8 **ep, STRLEN *el, const U32 flags
                )
    </pre>
  </dd>
  <dt>is_utf8_fixed_width_buf_loc_flags</dt>
  <dd>Like <span class="Li">&quot;is_utf8_fixed_width_buf_flags&quot;</span> but
      stores the location of the failure in the
      <span class="Li">&quot;ep&quot;</span> pointer. If the function returns
      TRUE, <span class="Li">*ep</span> will point to the beginning of any
      partial character at the end of the buffer; if there is no partial
      character <span class="Li">*ep</span> will contain
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>.
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_fixed_width_buf_loc_flags(
                    const U8 * const s, STRLEN len,
                    const U8 **ep, const U32 flags
                )
    </pre>
  </dd>
  <dt>is_utf8_invariant_string</dt>
  <dd>Returns TRUE if the first <span class="Li">&quot;len&quot;</span> bytes of
      the string <span class="Li">&quot;s&quot;</span> are the same regardless
      of the UTF-8 encoding of the string (or UTF-EBCDIC encoding on EBCDIC
      machines); otherwise it returns FALSE. That is, it returns TRUE if they
      are UTF-8 invariant. On ASCII-ish machines, all the ASCII characters and
      only the ASCII characters fit this definition. On EBCDIC machines, the
      ASCII-range characters are invariant, but so also are the C1 controls.
    <p class="Pp">If <span class="Li">&quot;len&quot;</span> is 0, it will be
        calculated using <span class="Li">strlen(s)</span>, (which means if you
        use this option, that <span class="Li">&quot;s&quot;</span> can't have
        embedded <span class="Li">&quot;NUL&quot;</span> characters and has to
        have a terminating <span class="Li">&quot;NUL&quot;</span> byte).</p>
    <p class="Pp">See also <span class="Li">&quot;is_utf8_string&quot;</span>,
        <span class="Li">&quot;is_utf8_string_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_c9strict_utf8_string_loclen&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_invariant_string(const U8* const s,
                                         STRLEN len)
    </pre>
  </dd>
  <dt>is_utf8_invariant_string_loc</dt>
  <dd>Like <span class="Li">&quot;is_utf8_invariant_string&quot;</span> but upon
      failure, stores the location of the first UTF-8 variant character in the
      <span class="Li">&quot;ep&quot;</span> pointer; if all characters are
      UTF-8 invariant, this function does not change the contents of
      <span class="Li">*ep</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_invariant_string_loc(const U8* const s,
                                             STRLEN len,
                                             const U8 ** ep)
    </pre>
  </dd>
  <dt>is_utf8_string</dt>
  <dd>Returns TRUE if the first <span class="Li">&quot;len&quot;</span> bytes of
      string <span class="Li">&quot;s&quot;</span> form a valid
      Perl-extended-UTF-8 string; returns FALSE otherwise. If
      <span class="Li">&quot;len&quot;</span> is 0, it will be calculated using
      <span class="Li">strlen(s)</span> (which means if you use this option,
      that <span class="Li">&quot;s&quot;</span> can't have embedded
      <span class="Li">&quot;NUL&quot;</span> characters and has to have a
      terminating <span class="Li">&quot;NUL&quot;</span> byte). Note that all
      characters being ASCII constitute 'a valid UTF-8 string'.
    <p class="Pp">This function considers Perl's extended UTF-8 to be valid.
        That means that code points above Unicode, surrogates, and non-character
        code points are considered valid by this function. Use
        <span class="Li">&quot;is_strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string&quot;</span>, or
        <span class="Li">&quot;is_utf8_string_flags&quot;</span> to restrict
        what code points are considered valid.</p>
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_invariant_string&quot;</span>,
        <span class="Li">&quot;is_utf8_invariant_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</span>,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_string(const U8 *s, STRLEN len)
    </pre>
  </dd>
  <dt>is_utf8_string_flags</dt>
  <dd>Returns TRUE if the first <span class="Li">&quot;len&quot;</span> bytes of
      string <span class="Li">&quot;s&quot;</span> form a valid UTF-8 string,
      subject to the restrictions imposed by
      <span class="Li">&quot;flags&quot;</span>; returns FALSE otherwise. If
      <span class="Li">&quot;len&quot;</span> is 0, it will be calculated using
      <span class="Li">strlen(s)</span> (which means if you use this option,
      that <span class="Li">&quot;s&quot;</span> can't have embedded
      <span class="Li">&quot;NUL&quot;</span> characters and has to have a
      terminating <span class="Li">&quot;NUL&quot;</span> byte). Note that all
      characters being ASCII constitute 'a valid UTF-8 string'.
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> is 0, this gives
        the same results as <span class="Li">&quot;is_utf8_string&quot;</span>;
        if <span class="Li">&quot;flags&quot;</span> is
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&quot;</span>,
        this gives the same results as
        <span class="Li">&quot;is_strict_utf8_string&quot;</span>; and if
        <span class="Li">&quot;flags&quot;</span> is
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&quot;</span>,
        this gives the same results as
        <span class="Li">&quot;is_c9strict_utf8_string&quot;</span>. Otherwise
        <span class="Li">&quot;flags&quot;</span> may be any combination of the
        <span class="Li">&quot;UTF8_DISALLOW_</span><i>foo</i><span class="Li">&quot;</span>
        flags understood by <span class="Li">&quot;utf8n_to_uvchr&quot;</span>,
        with the same meanings.</p>
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_invariant_string&quot;</span>,
        <span class="Li">&quot;is_utf8_invariant_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loc_flags&quot;</span>,
        <span class="Li">&quot;is_utf8_fixed_width_buf_loclen_flags&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loc&quot;</span>,
        <span class="Li">&quot;is_strict_utf8_string_loclen&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string&quot;</span>,
        <span class="Li">&quot;is_c9strict_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_c9strict_utf8_string_loclen&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_string_flags(const U8 *s, STRLEN len,
                                     const U32 flags)
    </pre>
  </dd>
  <dt>is_utf8_string_loc</dt>
  <dd>Like <span class="Li">&quot;is_utf8_string&quot;</span> but stores the
      location of the failure (in the case of &quot;utf8ness failure&quot;) or
      the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_string_loc(const U8 *s,
                                   const STRLEN len,
                                   const U8 **ep)
    </pre>
  </dd>
  <dt>is_utf8_string_loclen</dt>
  <dd>Like <span class="Li">&quot;is_utf8_string&quot;</span> but stores the
      location of the failure (in the case of &quot;utf8ness failure&quot;) or
      the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer, and the number of UTF-8
      encoded characters in the <span class="Li">&quot;el&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_string_loclen(const U8 *s, STRLEN len,
                                      const U8 **ep, STRLEN *el)
    </pre>
  </dd>
  <dt>is_utf8_string_loclen_flags</dt>
  <dd>Like <span class="Li">&quot;is_utf8_string_flags&quot;</span> but stores
      the location of the failure (in the case of &quot;utf8ness failure&quot;)
      or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer, and the number of UTF-8
      encoded characters in the <span class="Li">&quot;el&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_string_loc_flags&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_string_loclen_flags(const U8 *s,
                                            STRLEN len,
                                            const U8 **ep,
                                            STRLEN *el,
                                            const U32 flags)
    </pre>
  </dd>
  <dt>is_utf8_string_loc_flags</dt>
  <dd>Like <span class="Li">&quot;is_utf8_string_flags&quot;</span> but stores
      the location of the failure (in the case of &quot;utf8ness failure&quot;)
      or the location
      <span class="Li">&quot;s&quot;</span>+<span class="Li">&quot;len&quot;</span>
      (in the case of &quot;utf8ness success&quot;) in the
      <span class="Li">&quot;ep&quot;</span> pointer.
    <p class="Pp">See also
        <span class="Li">&quot;is_utf8_string_loclen_flags&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_string_loc_flags(const U8 *s,
                                         STRLEN len,
                                         const U8 **ep,
                                         const U32 flags)
    </pre>
  </dd>
  <dt>is_utf8_valid_partial_char</dt>
  <dd>Returns 0 if the sequence of bytes starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> is the UTF-8
      encoding, as extended by Perl, for one or more code points. Otherwise, it
      returns 1 if there exists at least one non-empty sequence of bytes that
      when appended to sequence <span class="Li">&quot;s&quot;</span>, starting
      at position <span class="Li">&quot;e&quot;</span> causes the entire
      sequence to be the well-formed UTF-8 of some code point; otherwise returns
      0.
    <p class="Pp">In other words this returns TRUE if
        <span class="Li">&quot;s&quot;</span> points to a partial UTF-8-encoded
        code point.</p>
    <p class="Pp">This is useful when a fixed-length buffer is being tested for
        being well-formed UTF-8, but the final few bytes in it don't comprise a
        full character; that is, it is split somewhere in the middle of the
        final code point's UTF-8 representation. (Presumably when the buffer is
        refreshed with the next chunk of data, the new first bytes will complete
        the partial code point.) This function is used to verify that the final
        bytes in the current buffer are in fact the legal beginning of some code
        point, so that if they aren't, the failure can be signalled without
        having to wait for the next read.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_valid_partial_char(const U8 * const s,
                                           const U8 * const e)
    </pre>
  </dd>
  <dt>is_utf8_valid_partial_char_flags</dt>
  <dd>Like <span class="Li">&quot;is_utf8_valid_partial_char&quot;</span>, it
      returns a boolean giving whether or not the input is a valid UTF-8 encoded
      partial character, but it takes an extra parameter,
      <span class="Li">&quot;flags&quot;</span>, which can further restrict
      which code points are considered valid.
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> is 0, this
        behaves identically to
        <span class="Li">&quot;is_utf8_valid_partial_char&quot;</span>.
        Otherwise <span class="Li">&quot;flags&quot;</span> can be any
        combination of the
        <span class="Li">&quot;UTF8_DISALLOW_</span><i>foo</i>
        <span class="Li">&quot;</span> flags accepted by
        <span class="Li">&quot;utf8n_to_uvchr&quot;</span>. If there is any
        sequence of bytes that can complete the input partial character in such
        a way that a non-prohibited character is formed, the function returns
        TRUE; otherwise FALSE. Non character code points cannot be determined
        based on partial character input. But many of the other possible
        excluded types can be determined from just the first one or two
      bytes.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    is_utf8_valid_partial_char_flags(
                    const U8 * const s, const U8 * const e,
                    const U32 flags
                )
    </pre>
  </dd>
  <dt>isUTF8_CHAR</dt>
  <dd>Evaluates to non-zero if the first few bytes of the string starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are well-formed
      UTF-8, as extended by Perl, that represents some code point; otherwise it
      evaluates to 0. If non-zero, the value gives how many bytes starting at
      <span class="Li">&quot;s&quot;</span> comprise the code point's
      representation. Any bytes remaining before
      <span class="Li">&quot;e&quot;</span>, but beyond the ones needed to form
      the first code point in <span class="Li">&quot;s&quot;</span>, are not
      examined.
    <p class="Pp">The code point can be any that will fit in an IV on this
        machine, using Perl's extension to official UTF-8 to represent those
        higher than the Unicode maximum of 0x10FFFF. That means that this macro
        is used to efficiently decide if the next few bytes in
        <span class="Li">&quot;s&quot;</span> is legal UTF-8 for a single
        character.</p>
    <p class="Pp">Use <span class="Li">&quot;isSTRICT_UTF8_CHAR&quot;</span> to
        restrict the acceptable code points to those defined by Unicode to be
        fully interchangeable across applications;
        <span class="Li">&quot;isC9_STRICT_UTF8_CHAR&quot;</span> to use the
        Unicode Corrigendum #9
        &lt;http://www.unicode.org/versions/corrigendum9.html&gt; definition of
        allowable code points; and
        <span class="Li">&quot;isUTF8_CHAR_flags&quot;</span> for a more
        customized definition.</p>
    <p class="Pp">Use <span class="Li">&quot;is_utf8_string&quot;</span>,
        <span class="Li">&quot;is_utf8_string_loc&quot;</span>, and
        <span class="Li">&quot;is_utf8_string_loclen&quot;</span> to check
        entire strings.</p>
    <p class="Pp">Note also that a UTF-8 &quot;invariant&quot; character (i.e.
        ASCII on non-EBCDIC machines) is a valid UTF-8 character.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  isUTF8_CHAR(const U8 *s, const U8 *e)
    </pre>
  </dd>
  <dt>isUTF8_CHAR_flags</dt>
  <dd>Evaluates to non-zero if the first few bytes of the string starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are well-formed
      UTF-8, as extended by Perl, that represents some code point, subject to
      the restrictions given by <span class="Li">&quot;flags&quot;</span>;
      otherwise it evaluates to 0. If non-zero, the value gives how many bytes
      starting at <span class="Li">&quot;s&quot;</span> comprise the code
      point's representation. Any bytes remaining before
      <span class="Li">&quot;e&quot;</span>, but beyond the ones needed to form
      the first code point in <span class="Li">&quot;s&quot;</span>, are not
      examined.
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> is 0, this gives
        the same results as <span class="Li">&quot;isUTF8_CHAR&quot;</span>; if
        <span class="Li">&quot;flags&quot;</span> is
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&quot;</span>,
        this gives the same results as
        <span class="Li">&quot;isSTRICT_UTF8_CHAR&quot;</span>; and if
        <span class="Li">&quot;flags&quot;</span> is
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&quot;</span>,
        this gives the same results as
        <span class="Li">&quot;isC9_STRICT_UTF8_CHAR&quot;</span>. Otherwise
        <span class="Li">&quot;flags&quot;</span> may be any combination of the
        <span class="Li">&quot;UTF8_DISALLOW_</span><i>foo</i><span class="Li">&quot;</span>
        flags understood by <span class="Li">&quot;utf8n_to_uvchr&quot;</span>,
        with the same meanings.</p>
    <p class="Pp">The three alternative macros are for the most commonly needed
        validations; they are likely to run somewhat faster than this more
        general one, as they can be inlined into your code.</p>
    <p class="Pp">Use &quot;is_utf8_string_flags&quot;,
        &quot;is_utf8_string_loc_flags&quot;, and
        &quot;is_utf8_string_loclen_flags&quot; to check entire strings.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  isUTF8_CHAR_flags(const U8 *s, const U8 *e,
                                   const U32 flags)
    </pre>
  </dd>
  <dt>pv_uni_display</dt>
  <dd>Build to the scalar <span class="Li">&quot;dsv&quot;</span> a displayable
      version of the string <span class="Li">&quot;spv&quot;</span>, length
      <span class="Li">&quot;len&quot;</span>, the displayable version being at
      most <span class="Li">&quot;pvlim&quot;</span> bytes long (if longer, the
      rest is truncated and <span class="Li">&quot;...&quot;</span> will be
      appended).
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> argument can
        have <span class="Li">&quot;UNI_DISPLAY_ISPRINT&quot;</span> set to
        display <span class="Li">&quot;isPRINT()&quot;</span>able characters as
        themselves, <span class="Li">&quot;UNI_DISPLAY_BACKSLASH&quot;</span> to
        display the <span class="Li">&quot;\\[nrfta\\]&quot;</span> as the
        backslashed versions (like <span class="Li">&quot;\n&quot;</span>)
        (<span class="Li">&quot;UNI_DISPLAY_BACKSLASH&quot;</span> is preferred
        over <span class="Li">&quot;UNI_DISPLAY_ISPRINT&quot;</span> for
        <span class="Li">&quot;\\&quot;</span>).
        <span class="Li">&quot;UNI_DISPLAY_QQ&quot;</span> (and its alias
        <span class="Li">&quot;UNI_DISPLAY_REGEX&quot;</span>) have both
        <span class="Li">&quot;UNI_DISPLAY_BACKSLASH&quot;</span> and
        <span class="Li">&quot;UNI_DISPLAY_ISPRINT&quot;</span> turned on.</p>
    <p class="Pp">The pointer to the PV of the
        <span class="Li">&quot;dsv&quot;</span> is returned.</p>
    <p class="Pp">See also &quot;sv_uni_display&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   pv_uni_display(SV *dsv, const U8 *spv,
                               STRLEN len, STRLEN pvlim,
                               UV flags)
    </pre>
  </dd>
  <dt>REPLACEMENT_CHARACTER_UTF8</dt>
  <dd>This is a macro that evaluates to a string constant of the UTF-8 bytes
      that define the Unicode REPLACEMENT CHARACTER (U+FFFD) for the platform
      that perl is compiled on. This allows code to use a mnemonic for this
      character that works on both ASCII and EBCDIC platforms.
      <span class="Li">&quot;sizeof(REPLACEMENT_CHARACTER_UTF8)&#x00A0;-&#x00A0;1&quot;</span>
      can be used to get its length in bytes.</dd>
  <dt>sv_cat_decode</dt>
  <dd><span class="Li">&quot;encoding&quot;</span> is assumed to be an
      <span class="Li">&quot;Encode&quot;</span> object, the PV of
      <span class="Li">&quot;ssv&quot;</span> is assumed to be octets in that
      encoding and decoding the input starts from the position which
      <span class="Li">&quot;(PV&#x00A0;+&#x00A0;*offset)&quot;</span> pointed
      to. <span class="Li">&quot;dsv&quot;</span> will be concatenated with the
      decoded UTF-8 string from <span class="Li">&quot;ssv&quot;</span>.
      Decoding will terminate when the string
      <span class="Li">&quot;tstr&quot;</span> appears in decoding output or the
      input ends on the PV of <span class="Li">&quot;ssv&quot;</span>. The value
      which <span class="Li">&quot;offset&quot;</span> points will be modified
      to the last input position on <span class="Li">&quot;ssv&quot;</span>.
    <p class="Pp">Returns TRUE if the terminator was found, else returns
      FALSE.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    sv_cat_decode(SV* dsv, SV *encoding, SV *ssv,
                              int *offset, char* tstr, int tlen)
    </pre>
  </dd>
  <dt>sv_recode_to_utf8</dt>
  <dd><span class="Li">&quot;encoding&quot;</span> is assumed to be an
      <span class="Li">&quot;Encode&quot;</span> object, on entry the PV of
      <span class="Li">&quot;sv&quot;</span> is assumed to be octets in that
      encoding, and <span class="Li">&quot;sv&quot;</span> will be converted
      into Unicode (and UTF-8).
    <p class="Pp">If <span class="Li">&quot;sv&quot;</span> already is UTF-8 (or
        if it is not <span class="Li">&quot;POK&quot;</span>), or if
        <span class="Li">&quot;encoding&quot;</span> is not a reference, nothing
        is done to <span class="Li">&quot;sv&quot;</span>. If
        <span class="Li">&quot;encoding&quot;</span> is not an
        <span class="Li">&quot;Encode::XS&quot;</span> Encoding object, bad
        things will happen. (See <i>cpan/Encode/encoding.pm</i> and Encode.)</p>
    <p class="Pp">The PV of <span class="Li">&quot;sv&quot;</span> is
      returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_recode_to_utf8(SV* sv, SV *encoding)
    </pre>
  </dd>
  <dt>sv_uni_display</dt>
  <dd>Build to the scalar <span class="Li">&quot;dsv&quot;</span> a displayable
      version of the scalar <span class="Li">&quot;sv&quot;</span>, the
      displayable version being at most
      <span class="Li">&quot;pvlim&quot;</span> bytes long (if longer, the rest
      is truncated and &quot;...&quot; will be appended).
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> argument is as
        in &quot;pv_uni_display&quot;().</p>
    <p class="Pp">The pointer to the PV of the
        <span class="Li">&quot;dsv&quot;</span> is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char*   sv_uni_display(SV *dsv, SV *ssv, STRLEN pvlim,
                               UV flags)
    </pre>
  </dd>
  <dt>to_utf8_fold</dt>
  <dd>DEPRECATED! It is planned to remove this function from a future release of
      Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Instead use &quot;toFOLD_utf8_safe&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      to_utf8_fold(const U8 *p, U8* ustrp,
                             STRLEN *lenp)
    </pre>
  </dd>
  <dt>to_utf8_lower</dt>
  <dd>DEPRECATED! It is planned to remove this function from a future release of
      Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Instead use &quot;toLOWER_utf8_safe&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      to_utf8_lower(const U8 *p, U8* ustrp,
                              STRLEN *lenp)
    </pre>
  </dd>
  <dt>to_utf8_title</dt>
  <dd>DEPRECATED! It is planned to remove this function from a future release of
      Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Instead use &quot;toTITLE_utf8_safe&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      to_utf8_title(const U8 *p, U8* ustrp,
                              STRLEN *lenp)
    </pre>
  </dd>
  <dt>to_utf8_upper</dt>
  <dd>DEPRECATED! It is planned to remove this function from a future release of
      Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Instead use &quot;toUPPER_utf8_safe&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      to_utf8_upper(const U8 *p, U8* ustrp,
                              STRLEN *lenp)
    </pre>
  </dd>
  <dt>utf8n_to_uvchr</dt>
  <dd>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most
      code should use &quot;utf8_to_uvchr_buf&quot;() rather than call this
      directly.
    <p class="Pp">Bottom level UTF-8 decode routine. Returns the native code
        point value of the first character in the string
        <span class="Li">&quot;s&quot;</span>, which is assumed to be in UTF-8
        (or UTF-EBCDIC) encoding, and no longer than
        <span class="Li">&quot;curlen&quot;</span> bytes;
        <span class="Li">*retlen</span> (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) will be set to
        the length, in bytes, of that character.</p>
    <p class="Pp">The value of <span class="Li">&quot;flags&quot;</span>
        determines the behavior when <span class="Li">&quot;s&quot;</span> does
        not point to a well-formed UTF-8 character. If
        <span class="Li">&quot;flags&quot;</span> is 0, encountering a
        malformation causes zero to be returned and
        <span class="Li">*retlen</span> is set so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. Also, if UTF-8 warnings
        haven't been lexically disabled, a warning is raised. Some UTF-8 input
        sequences may contain multiple malformations. This function tries to
        find every possible one in each call, so multiple warnings can be raised
        for the same sequence.</p>
    <p class="Pp">Various ALLOW flags can be set in
        <span class="Li">&quot;flags&quot;</span> to allow (and not warn on)
        individual types of malformations, such as the sequence being overlong
        (that is, when there is a shorter sequence that can express the same
        code point; overlong sequences are expressly forbidden in the UTF-8
        standard due to potential security issues). Another malformation example
        is the first byte of a character not being a legal first byte. See
        <i>utf8.h</i> for the list of such flags. Even if allowed, this function
        generally returns the Unicode REPLACEMENT CHARACTER when it encounters a
        malformation. There are flags in <i>utf8.h</i> to override this behavior
        for the overlong malformations, but don't do that except for very
        specialized purposes.</p>
    <p class="Pp">The <span class="Li">&quot;UTF8_CHECK_ONLY&quot;</span> flag
        overrides the behavior when a non-allowed (by other flags) malformation
        is found. If this flag is set, the routine assumes that the caller will
        raise a warning, and this function will silently just set
        <span class="Li">&quot;retlen&quot;</span> to
        <span class="Li">&quot;-1&quot;</span> (cast to
        <span class="Li">&quot;STRLEN&quot;</span>) and return zero.</p>
    <p class="Pp">Note that this API requires disambiguation between successful
        decoding a <span class="Li">&quot;NUL&quot;</span> character, and an
        error return (unless the
        <span class="Li">&quot;UTF8_CHECK_ONLY&quot;</span> flag is set), as in
        both cases, 0 is returned, and, depending on the malformation,
        <span class="Li">&quot;retlen&quot;</span> may be set to 1. To
        disambiguate, upon a zero return, see if the first byte of
        <span class="Li">&quot;s&quot;</span> is 0 as well. If so, the input was
        a <span class="Li">&quot;NUL&quot;</span>; if not, the input had an
        error. Or you can use
        <span class="Li">&quot;utf8n_to_uvchr_error&quot;</span>.</p>
    <p class="Pp">Certain code points are considered problematic. These are
        Unicode surrogates, Unicode non-characters, and code points above the
        Unicode maximum of 0x10FFFF. By default these are considered regular
        code points, but certain situations warrant special handling for them,
        which can be specified using the
        <span class="Li">&quot;flags&quot;</span> parameter. If
        <span class="Li">&quot;flags&quot;</span> contains
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&quot;</span>,
        all three classes are treated as malformations and handled as such. The
        flags <span class="Li">&quot;UTF8_DISALLOW_SURROGATE&quot;</span>,
        <span class="Li">&quot;UTF8_DISALLOW_NONCHAR&quot;</span>, and
        <span class="Li">&quot;UTF8_DISALLOW_SUPER&quot;</span> (meaning above
        the legal Unicode maximum) can be set to disallow these categories
        individually.
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&quot;</span>
        restricts the allowed inputs to the strict UTF-8 traditionally defined
        by Unicode. Use
        <span class="Li">&quot;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&quot;</span>
        to use the strictness definition given by Unicode Corrigendum #9
        &lt;http://www.unicode.org/versions/corrigendum9.html&gt;. The
        difference between traditional strictness and C9 strictness is that the
        latter does not forbid non-character code points. (They are still
        discouraged, however.) For more discussion see &quot;Noncharacter code
        points&quot; in perlunicode.</p>
    <p class="Pp">The flags
        <span class="Li">&quot;UTF8_WARN_ILLEGAL_INTERCHANGE&quot;</span>,
        <span class="Li">&quot;UTF8_WARN_ILLEGAL_C9_INTERCHANGE&quot;</span>,
        <span class="Li">&quot;UTF8_WARN_SURROGATE&quot;</span>,
        <span class="Li">&quot;UTF8_WARN_NONCHAR&quot;</span>, and
        <span class="Li">&quot;UTF8_WARN_SUPER&quot;</span> will cause warning
        messages to be raised for their respective categories, but otherwise the
        code points are considered valid (not malformations). To get a category
        to both be treated as a malformation and raise a warning, specify both
        the WARN and DISALLOW flags. (But note that warnings are not raised if
        lexically disabled nor if
        <span class="Li">&quot;UTF8_CHECK_ONLY&quot;</span> is also
      specified.)</p>
    <p class="Pp">Extremely high code points were never specified in any
        standard, and require an extension to UTF-8 to express, which Perl does.
        It is likely that programs written in something other than Perl would
        not be able to read files that contain these; nor would Perl understand
        files written by something that uses a different extension. For these
        reasons, there is a separate set of flags that can warn and/or disallow
        these extremely high code points, even if other above-Unicode ones are
        accepted. They are the
        <span class="Li">&quot;UTF8_WARN_PERL_EXTENDED&quot;</span> and
        <span class="Li">&quot;UTF8_DISALLOW_PERL_EXTENDED&quot;</span> flags.
        For more information see
        &quot;<span class="Li">&quot;UTF8_GOT_PERL_EXTENDED&quot;</span>&quot;.
        Of course <span class="Li">&quot;UTF8_DISALLOW_SUPER&quot;</span> will
        treat all above-Unicode code points, including these, as malformations.
        (Note that the Unicode standard considers anything above 0x10FFFF to be
        illegal, but there are standards predating it that allow up to
        0x7FFF_FFFF (2**31 -1))</p>
    <p class="Pp">A somewhat misleadingly named synonym for
        <span class="Li">&quot;UTF8_WARN_PERL_EXTENDED&quot;</span> is retained
        for backward compatibility:
        <span class="Li">&quot;UTF8_WARN_ABOVE_31_BIT&quot;</span>. Similarly,
        <span class="Li">&quot;UTF8_DISALLOW_ABOVE_31_BIT&quot;</span> is usable
        instead of the more accurately named
        <span class="Li">&quot;UTF8_DISALLOW_PERL_EXTENDED&quot;</span>. The
        names are misleading because these flags can apply to code points that
        actually do fit in 31 bits. This happens on EBCDIC platforms, and
        sometimes when the overlong malformation is also present. The new names
        accurately describe the situation in all cases.</p>
    <p class="Pp">All other code points corresponding to Unicode characters,
        including private use and those yet to be assigned, are never considered
        malformed and never warn.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      utf8n_to_uvchr(const U8 *s, STRLEN curlen,
                               STRLEN *retlen, const U32 flags)
    </pre>
  </dd>
  <dt>utf8n_to_uvchr_error</dt>
  <dd>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most
      code should use &quot;utf8_to_uvchr_buf&quot;() rather than call this
      directly.
    <p class="Pp">This function is for code that needs to know what the precise
        malformation(s) are when an error is found. If you also need to know the
        generated warning messages, use &quot;utf8n_to_uvchr_msgs&quot;()
        instead.</p>
    <p class="Pp">It is like <span class="Li">&quot;utf8n_to_uvchr&quot;</span>
        but it takes an extra parameter placed after all the others,
        <span class="Li">&quot;errors&quot;</span>. If this parameter is 0, this
        function behaves identically to
        <span class="Li">&quot;utf8n_to_uvchr&quot;</span>. Otherwise,
        <span class="Li">&quot;errors&quot;</span> should be a pointer to a
        <span class="Li">&quot;U32&quot;</span> variable, which this function
        sets to indicate any errors found. Upon return, if
        <span class="Li">*errors</span> is 0, there were no errors found.
        Otherwise, <span class="Li">*errors</span> is the bit-wise
        <span class="Li">&quot;OR&quot;</span> of the bits described in the list
        below. Some of these bits will be set if a malformation is found, even
        if the input <span class="Li">&quot;flags&quot;</span> parameter
        indicates that the given malformation is allowed; those exceptions are
        noted:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;UTF8_GOT_PERL_EXTENDED&quot;</dt>
  <dd>The input sequence is not standard UTF-8, but a Perl extension. This bit
      is set only if the input <span class="Li">&quot;flags&quot;</span>
      parameter contains either the
      <span class="Li">&quot;UTF8_DISALLOW_PERL_EXTENDED&quot;</span> or the
      <span class="Li">&quot;UTF8_WARN_PERL_EXTENDED&quot;</span> flags.
    <p class="Pp">Code points above 0x7FFF_FFFF (2**31 - 1) were never specified
        in any standard, and so some extension must be used to express them.
        Perl uses a natural extension to UTF-8 to represent the ones up to
        2**36-1, and invented a further extension to represent even higher ones,
        so that any code point that fits in a 64-bit word can be represented.
        Text using these extensions is not likely to be portable to non-Perl
        code. We lump both of these extensions together and refer to them as
        Perl extended UTF-8. There exist other extensions that people have
        invented, incompatible with Perl's.</p>
    <p class="Pp">On EBCDIC platforms starting in Perl v5.24, the Perl extension
        for representing extremely high code points kicks in at 0x3FFF_FFFF
        (2**30 -1), which is lower than on ASCII. Prior to that, code points
        2**31 and higher were simply unrepresentable, and a different,
        incompatible method was used to represent code points between 2**30 and
        2**31 - 1.</p>
    <p class="Pp">On both platforms, ASCII and EBCDIC,
        <span class="Li">&quot;UTF8_GOT_PERL_EXTENDED&quot;</span> is set if
        Perl extended UTF-8 is used.</p>
    <p class="Pp">In earlier Perls, this bit was named
        <span class="Li">&quot;UTF8_GOT_ABOVE_31_BIT&quot;</span>, which you
        still may use for backward compatibility. That name is misleading, as
        this flag may be set when the code point actually does fit in 31 bits.
        This happens on EBCDIC platforms, and sometimes when the overlong
        malformation is also present. The new name accurately describes the
        situation in all cases.</p>
  </dd>
  <dt>&quot;UTF8_GOT_CONTINUATION&quot;</dt>
  <dd>The input sequence was malformed in that the first byte was a a UTF-8
      continuation byte.</dd>
  <dt>&quot;UTF8_GOT_EMPTY&quot;</dt>
  <dd>The input <span class="Li">&quot;curlen&quot;</span> parameter was 0.</dd>
  <dt>&quot;UTF8_GOT_LONG&quot;</dt>
  <dd>The input sequence was malformed in that there is some other sequence that
      evaluates to the same code point, but that sequence is shorter than this
      one.
    <p class="Pp">Until Unicode 3.1, it was legal for programs to accept this
        malformation, but it was discovered that this created security
      issues.</p>
  </dd>
  <dt>&quot;UTF8_GOT_NONCHAR&quot;</dt>
  <dd>The code point represented by the input UTF-8 sequence is for a Unicode
      non-character code point. This bit is set only if the input
      <span class="Li">&quot;flags&quot;</span> parameter contains either the
      <span class="Li">&quot;UTF8_DISALLOW_NONCHAR&quot;</span> or the
      <span class="Li">&quot;UTF8_WARN_NONCHAR&quot;</span> flags.</dd>
  <dt>&quot;UTF8_GOT_NON_CONTINUATION&quot;</dt>
  <dd>The input sequence was malformed in that a non-continuation type byte was
      found in a position where only a continuation type one should be. See also
      &quot;<span class="Li">&quot;UTF8_GOT_SHORT&quot;</span>&quot;.</dd>
  <dt>&quot;UTF8_GOT_OVERFLOW&quot;</dt>
  <dd>The input sequence was malformed in that it is for a code point that is
      not representable in the number of bits available in an IV on the current
      platform.</dd>
  <dt>&quot;UTF8_GOT_SHORT&quot;</dt>
  <dd>The input sequence was malformed in that
      <span class="Li">&quot;curlen&quot;</span> is smaller than required for a
      complete sequence. In other words, the input is for a partial character
      sequence.
    <p class="Pp"><span class="Li">&quot;UTF8_GOT_SHORT&quot;</span> and
        <span class="Li">&quot;UTF8_GOT_NON_CONTINUATION&quot;</span> both
        indicate a too short sequence. The difference is that
        <span class="Li">&quot;UTF8_GOT_NON_CONTINUATION&quot;</span> indicates
        always that there is an error, while
        <span class="Li">&quot;UTF8_GOT_SHORT&quot;</span> means that an
        incomplete sequence was looked at. If no other flags are present, it
        means that the sequence was valid as far as it went. Depending on the
        application, this could mean one of three things:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>The <span class="Li">&quot;curlen&quot;</span> length parameter passed in
      was too small, and the function was prevented from examining all the
      necessary bytes.</li>
  <li>The buffer being looked at is based on reading data, and the data received
      so far stopped in the middle of a character, so that the next read will
      read the remainder of this character. (It is up to the caller to deal with
      the split bytes somehow.)</li>
  <li>This is a real error, and the partial sequence is all we're going to
    get.</li>
</ul>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;UTF8_GOT_SUPER&quot;</dt>
  <dd>The input sequence was malformed in that it is for a non-Unicode code
      point; that is, one above the legal Unicode maximum. This bit is set only
      if the input <span class="Li">&quot;flags&quot;</span> parameter contains
      either the <span class="Li">&quot;UTF8_DISALLOW_SUPER&quot;</span> or the
      <span class="Li">&quot;UTF8_WARN_SUPER&quot;</span> flags.</dd>
  <dt>&quot;UTF8_GOT_SURROGATE&quot;</dt>
  <dd>The input sequence was malformed in that it is for a -Unicode UTF-16
      surrogate code point. This bit is set only if the input
      <span class="Li">&quot;flags&quot;</span> parameter contains either the
      <span class="Li">&quot;UTF8_DISALLOW_SURROGATE&quot;</span> or the
      <span class="Li">&quot;UTF8_WARN_SURROGATE&quot;</span> flags.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">To do your own error handling, call this function with the
    <span class="Li">&quot;UTF8_CHECK_ONLY&quot;</span> flag to suppress any
    warnings, and then examine the <span class="Li">*errors</span> return.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        UV      utf8n_to_uvchr_error(const U8 *s, STRLEN curlen,
                                     STRLEN *retlen,
                                     const U32 flags,
                                     U32 * errors)
</pre>
</div>
<dl class="Bl-tag">
  <dt>utf8n_to_uvchr_msgs</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED
        CIRCUMSTANCES. Most code should use &quot;utf8_to_uvchr_buf&quot;()
        rather than call this directly.</p>
    <p class="Pp">This function is for code that needs to know what the precise
        malformation(s) are when an error is found, and wants the corresponding
        warning and/or error messages to be returned to the caller rather than
        be displayed. All messages that would have been displayed if all lexcial
        warnings are enabled will be returned.</p>
    <p class="Pp">It is just like
        <span class="Li">&quot;utf8n_to_uvchr_error&quot;</span> but it takes an
        extra parameter placed after all the others,
        <span class="Li">&quot;msgs&quot;</span>. If this parameter is 0, this
        function behaves identically to
        <span class="Li">&quot;utf8n_to_uvchr_error&quot;</span>. Otherwise,
        <span class="Li">&quot;msgs&quot;</span> should be a pointer to an
        <span class="Li">&quot;AV *&quot;</span> variable, in which this
        function creates a new AV to contain any appropriate messages. The
        elements of the array are ordered so that the first message that would
        have been displayed is in the 0th element, and so on. Each element is a
        hash with three key-value pairs, as follows:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;text&quot;</dt>
  <dd>The text of the message as a
    <span class="Li">&quot;SVpv&quot;</span>.</dd>
  <dt>&quot;warn_categories&quot;</dt>
  <dd>The warning category (or categories) packed into a
      <span class="Li">&quot;SVuv&quot;</span>.</dd>
  <dt>&quot;flag&quot;</dt>
  <dd>A single flag bit associated with this message, in a
      <span class="Li">&quot;SVuv&quot;</span>. The bit corresponds to some bit
      in the <span class="Li">*errors</span> return value, such as
      <span class="Li">&quot;UTF8_GOT_LONG&quot;</span>.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">It's important to note that specifying this parameter as non-null
    will cause any warnings this function would otherwise generate to be
    suppressed, and instead be placed in <span class="Li">*msgs</span>. The
    caller can check the lexical warnings state (or not) when choosing what to
    do with the returned messages.</p>
<p class="Pp">If the flag <span class="Li">&quot;UTF8_CHECK_ONLY&quot;</span> is
    passed, no warnings are generated, and hence no AV is created.</p>
<p class="Pp">The caller, of course, is responsible for freeing any returned
  AV.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        UV      utf8n_to_uvchr_msgs(const U8 *s, STRLEN curlen,
                                    STRLEN *retlen,
                                    const U32 flags,
                                    U32 * errors, AV ** msgs)
</pre>
</div>
<dl class="Bl-tag">
  <dt>utf8n_to_uvuni</dt>
  <dd>Instead use &quot;utf8_to_uvchr_buf&quot;, or rarely,
      &quot;utf8n_to_uvchr&quot;.
    <p class="Pp">This function was useful for code that wanted to handle both
        EBCDIC and ASCII platforms with Unicode properties, but starting in Perl
        v5.20, the distinctions between the platforms have mostly been made
        invisible to most code, so this function is quite unlikely to be what
        you want. If you do need this precise functionality, use instead
        <span class="Li">&quot;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&quot;</span>
        or
        <span class="Li">&quot;NATIVE_TO_UNI(utf8n_to_uvchr(...))&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      utf8n_to_uvuni(const U8 *s, STRLEN curlen,
                               STRLEN *retlen, U32 flags)
    </pre>
  </dd>
  <dt>UTF8SKIP</dt>
  <dd>returns the number of bytes in the UTF-8 encoded character whose first
      (perhaps only) byte is pointed to by
      <span class="Li">&quot;s&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  UTF8SKIP(char* s)
    </pre>
  </dd>
  <dt>utf8_distance</dt>
  <dd>Returns the number of UTF-8 characters between the UTF-8 pointers
      <span class="Li">&quot;a&quot;</span> and
      <span class="Li">&quot;b&quot;</span>.
    <p class="Pp">WARNING: use only if you *know* that the pointers point inside
        the same UTF-8 buffer.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        IV      utf8_distance(const U8 *a, const U8 *b)
    </pre>
  </dd>
  <dt>utf8_hop</dt>
  <dd>Return the UTF-8 pointer <span class="Li">&quot;s&quot;</span> displaced
      by <span class="Li">&quot;off&quot;</span> characters, either forward or
      backward.
    <p class="Pp">WARNING: do not use the following unless you *know*
        <span class="Li">&quot;off&quot;</span> is within the UTF-8 data pointed
        to by <span class="Li">&quot;s&quot;</span> *and* that on entry
        <span class="Li">&quot;s&quot;</span> is aligned on the first byte of
        character or just after the last byte of a character.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     utf8_hop(const U8 *s, SSize_t off)
    </pre>
  </dd>
  <dt>utf8_hop_back</dt>
  <dd>Return the UTF-8 pointer <span class="Li">&quot;s&quot;</span> displaced
      by up to <span class="Li">&quot;off&quot;</span> characters, backward.
    <p class="Pp"><span class="Li">&quot;off&quot;</span> must be
      non-positive.</p>
    <p class="Pp"><span class="Li">&quot;s&quot;</span> must be after or equal
        to <span class="Li">&quot;start&quot;</span>.</p>
    <p class="Pp">When moving backward it will not move before
        <span class="Li">&quot;start&quot;</span>.</p>
    <p class="Pp">Will not exceed this limit even if the string is not valid
        &quot;UTF-8&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     utf8_hop_back(const U8 *s, SSize_t off,
                              const U8 *start)
    </pre>
  </dd>
  <dt>utf8_hop_forward</dt>
  <dd>Return the UTF-8 pointer <span class="Li">&quot;s&quot;</span> displaced
      by up to <span class="Li">&quot;off&quot;</span> characters, forward.
    <p class="Pp"><span class="Li">&quot;off&quot;</span> must be
      non-negative.</p>
    <p class="Pp"><span class="Li">&quot;s&quot;</span> must be before or equal
        to <span class="Li">&quot;end&quot;</span>.</p>
    <p class="Pp">When moving forward it will not move beyond
        <span class="Li">&quot;end&quot;</span>.</p>
    <p class="Pp">Will not exceed this limit even if the string is not valid
        &quot;UTF-8&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     utf8_hop_forward(const U8 *s, SSize_t off,
                                 const U8 *end)
    </pre>
  </dd>
  <dt>utf8_hop_safe</dt>
  <dd>Return the UTF-8 pointer <span class="Li">&quot;s&quot;</span> displaced
      by up to <span class="Li">&quot;off&quot;</span> characters, either
      forward or backward.
    <p class="Pp">When moving backward it will not move before
        <span class="Li">&quot;start&quot;</span>.</p>
    <p class="Pp">When moving forward it will not move beyond
        <span class="Li">&quot;end&quot;</span>.</p>
    <p class="Pp">Will not exceed those limits even if the string is not valid
        &quot;UTF-8&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     utf8_hop_safe(const U8 *s, SSize_t off,
                              const U8 *start, const U8 *end)
    </pre>
  </dd>
  <dt>UTF8_IS_INVARIANT</dt>
  <dd>Evaluates to 1 if the byte <span class="Li">&quot;c&quot;</span>
      represents the same character when encoded in UTF-8 as when not; otherwise
      evaluates to 0. UTF-8 invariant characters can be copied as-is when
      converting to/from UTF-8, saving time.
    <p class="Pp">In spite of the name, this macro gives the correct result if
        the input string from which <span class="Li">&quot;c&quot;</span> comes
        is not encoded in UTF-8.</p>
    <p class="Pp">See <span class="Li">&quot;UVCHR_IS_INVARIANT&quot;</span> for
        checking if a UV is invariant.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    UTF8_IS_INVARIANT(char c)
    </pre>
  </dd>
  <dt>UTF8_IS_NONCHAR</dt>
  <dd>Evaluates to non-zero if the first few bytes of the string starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are well-formed
      UTF-8 that represents one of the Unicode non-character code points;
      otherwise it evaluates to 0. If non-zero, the value gives how many bytes
      starting at <span class="Li">&quot;s&quot;</span> comprise the code
      point's representation.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    UTF8_IS_NONCHAR(const U8 *s, const U8 *e)
    </pre>
  </dd>
  <dt>UTF8_IS_SUPER</dt>
  <dd>Recall that Perl recognizes an extension to UTF-8 that can encode code
      points larger than the ones defined by Unicode, which are 0..0x10FFFF.
    <p class="Pp">This macro evaluates to non-zero if the first few bytes of the
        string starting at <span class="Li">&quot;s&quot;</span> and looking no
        further than <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are
        from this UTF-8 extension; otherwise it evaluates to 0. If non-zero, the
        value gives how many bytes starting at
        <span class="Li">&quot;s&quot;</span> comprise the code point's
        representation.</p>
    <p class="Pp">0 is returned if the bytes are not well-formed extended UTF-8,
        or if they represent a code point that cannot fit in a UV on the current
        platform. Hence this macro can give different results when run on a
        64-bit word machine than on one with a 32-bit word size.</p>
    <p class="Pp">Note that it is illegal to have code points that are larger
        than what can fit in an IV on the current machine.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    UTF8_IS_SUPER(const U8 *s, const U8 *e)
    </pre>
  </dd>
  <dt>UTF8_IS_SURROGATE</dt>
  <dd>Evaluates to non-zero if the first few bytes of the string starting at
      <span class="Li">&quot;s&quot;</span> and looking no further than
      <span class="Li">&quot;e&#x00A0;-&#x00A0;1&quot;</span> are well-formed
      UTF-8 that represents one of the Unicode surrogate code points; otherwise
      it evaluates to 0. If non-zero, the value gives how many bytes starting at
      <span class="Li">&quot;s&quot;</span> comprise the code point's
      representation.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    UTF8_IS_SURROGATE(const U8 *s, const U8 *e)
    </pre>
  </dd>
  <dt>utf8_length</dt>
  <dd>Returns the number of characters in the sequence of UTF-8-encoded bytes
      starting at <span class="Li">&quot;s&quot;</span> and ending at the byte
      just before <span class="Li">&quot;e&quot;</span>. If &lt;s&gt; and
      &lt;e&gt; point to the same place, it returns 0 with no warning raised.
    <p class="Pp">If <span class="Li">&quot;e &lt; s&quot;</span> or if the scan
        would end up past <span class="Li">&quot;e&quot;</span>, it raises a
        UTF8 warning and returns the number of valid characters.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  utf8_length(const U8* s, const U8 *e)
    </pre>
  </dd>
  <dt>UTF8_SAFE_SKIP</dt>
  <dd>returns 0 if <span class="Li">&quot;s&#x00A0;&gt;=&#x00A0;e&quot;</span>;
      otherwise returns the number of bytes in the UTF-8 encoded character whose
      first byte is pointed to by <span class="Li">&quot;s&quot;</span>. But it
      never returns beyond <span class="Li">&quot;e&quot;</span>. On DEBUGGING
      builds, it asserts that
      <span class="Li">&quot;s&#x00A0;&lt;=&#x00A0;e&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  UTF8_SAFE_SKIP(char* s, char* e)
    </pre>
  </dd>
  <dt>utf8_to_bytes</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">Converts a string <span class="Li">&quot;s&quot;</span> of
        length <span class="Li">*lenp</span> from UTF-8 into native byte
        encoding. Unlike &quot;bytes_to_utf8&quot;, this over-writes the
        original string, and updates <span class="Li">*lenp</span> to contain
        the new length. Returns zero on failure (leaving
        <span class="Li">&quot;s&quot;</span> unchanged) setting
        <span class="Li">*lenp</span> to -1.</p>
    <p class="Pp">Upon successful return, the number of variants in the string
        can be computed by having saved the value of
        <span class="Li">*lenp</span> before the call, and subtracting the
        after-call value of <span class="Li">*lenp</span> from it.</p>
    <p class="Pp">If you need a copy of the string, see
        &quot;bytes_from_utf8&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     utf8_to_bytes(U8 *s, STRLEN *lenp)
    </pre>
  </dd>
  <dt>utf8_to_uvchr</dt>
  <dd>DEPRECATED! It is planned to remove this function from a future release of
      Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Returns the native code point of the first character in the
        string <span class="Li">&quot;s&quot;</span> which is assumed to be in
        UTF-8 encoding; <span class="Li">&quot;retlen&quot;</span> will be set
        to the length, in bytes, of that character.</p>
    <p class="Pp">Some, but not all, UTF-8 malformations are detected, and in
        fact, some malformed input could cause reading beyond the end of the
        input buffer, which is why this function is deprecated. Use
        &quot;utf8_to_uvchr_buf&quot; instead.</p>
    <p class="Pp">If <span class="Li">&quot;s&quot;</span> points to one of the
        detected malformations, and UTF8 warnings are enabled, zero is returned
        and <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't
        <span class="Li">&quot;NULL&quot;</span>) to -1. If those warnings are
        off, the computed value if well-defined (or the Unicode REPLACEMENT
        CHARACTER, if not) is silently returned, and
        <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. See
        &quot;utf8n_to_uvchr&quot; for details on when the REPLACEMENT CHARACTER
        is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      utf8_to_uvchr(const U8 *s, STRLEN *retlen)
    </pre>
  </dd>
  <dt>utf8_to_uvchr_buf</dt>
  <dd>Returns the native code point of the first character in the string
      <span class="Li">&quot;s&quot;</span> which is assumed to be in UTF-8
      encoding; <span class="Li">&quot;send&quot;</span> points to 1 beyond the
      end of <span class="Li">&quot;s&quot;</span>.
      <span class="Li">*retlen</span> will be set to the length, in bytes, of
      that character.
    <p class="Pp">If <span class="Li">&quot;s&quot;</span> does not point to a
        well-formed UTF-8 character and UTF8 warnings are enabled, zero is
        returned and <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't
        <span class="Li">&quot;NULL&quot;</span>) to -1. If those warnings are
        off, the computed value, if well-defined (or the Unicode REPLACEMENT
        CHARACTER if not), is silently returned, and
        <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't
        <span class="Li">&quot;NULL&quot;</span>) so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. See
        &quot;utf8n_to_uvchr&quot; for details on when the REPLACEMENT CHARACTER
        is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      utf8_to_uvchr_buf(const U8 *s, const U8 *send,
                                  STRLEN *retlen)
    </pre>
  </dd>
  <dt>utf8_to_uvuni_buf</dt>
  <dd>DEPRECATED! It is planned to remove this function from a future release of
      Perl. Do not use it for new code; remove it from existing code.
    <p class="Pp">Only in very rare circumstances should code need to be dealing
        in Unicode (as opposed to native) code points. In those few cases, use
        <span class="Li">&quot;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&quot;</span>
        instead. If you are not absolutely sure this is one of those cases, then
        assume it isn't and use plain
        <span class="Li">&quot;utf8_to_uvchr_buf&quot;</span> instead.</p>
    <p class="Pp">Returns the Unicode (not-native) code point of the first
        character in the string <span class="Li">&quot;s&quot;</span> which is
        assumed to be in UTF-8 encoding;
        <span class="Li">&quot;send&quot;</span> points to 1 beyond the end of
        <span class="Li">&quot;s&quot;</span>.
        <span class="Li">&quot;retlen&quot;</span> will be set to the length, in
        bytes, of that character.</p>
    <p class="Pp">If <span class="Li">&quot;s&quot;</span> does not point to a
        well-formed UTF-8 character and UTF8 warnings are enabled, zero is
        returned and <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) to -1. If those
        warnings are off, the computed value if well-defined (or the Unicode
        REPLACEMENT CHARACTER, if not) is silently returned, and
        <span class="Li">*retlen</span> is set (if
        <span class="Li">&quot;retlen&quot;</span> isn't NULL) so that
        (<span class="Li">&quot;s&quot;</span>&#x00A0;+&#x00A0;<span class="Li">*retlen</span>)
        is the next possible position in <span class="Li">&quot;s&quot;</span>
        that could begin a non-malformed character. See
        &quot;utf8n_to_uvchr&quot; for details on when the REPLACEMENT CHARACTER
        is returned.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      utf8_to_uvuni_buf(const U8 *s, const U8 *send,
                                  STRLEN *retlen)
    </pre>
  </dd>
  <dt>UVCHR_IS_INVARIANT</dt>
  <dd>Evaluates to 1 if the representation of code point
      <span class="Li">&quot;cp&quot;</span> is the same whether or not it is
      encoded in UTF-8; otherwise evaluates to 0. UTF-8 invariant characters can
      be copied as-is when converting to/from UTF-8, saving time.
      <span class="Li">&quot;cp&quot;</span> is Unicode if above 255; otherwise
      is platform-native.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    UVCHR_IS_INVARIANT(UV cp)
    </pre>
  </dd>
  <dt>UVCHR_SKIP</dt>
  <dd>returns the number of bytes required to represent the code point
      <span class="Li">&quot;cp&quot;</span> when encoded as UTF-8.
      <span class="Li">&quot;cp&quot;</span> is a native (ASCII or EBCDIC) code
      point if less than 255; a Unicode code point otherwise.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  UVCHR_SKIP(UV cp)
    </pre>
  </dd>
  <dt>uvchr_to_utf8</dt>
  <dd>Adds the UTF-8 representation of the native code point
      <span class="Li">&quot;uv&quot;</span> to the end of the string
      <span class="Li">&quot;d&quot;</span>;
      <span class="Li">&quot;d&quot;</span> should have at least
      <span class="Li">&quot;UVCHR_SKIP(uv)+1&quot;</span> (up to
      <span class="Li">&quot;UTF8_MAXBYTES+1&quot;</span>) free bytes available.
      The return value is the pointer to the byte after the end of the new
      character. In other words,
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    d = uvchr_to_utf8(d, uv);
    </pre>
    <p class="Pp">is the recommended wide native character-aware way of
      saying</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    *(d++) = uv;
    </pre>
    <p class="Pp">This function accepts any code point from
        0..<span class="Li">&quot;IV_MAX&quot;</span> as input.
        <span class="Li">&quot;IV_MAX&quot;</span> is typically 0x7FFF_FFFF in a
        32-bit word.</p>
    <p class="Pp">It is possible to forbid or warn on non-Unicode code points,
        or those that may be problematic by using
        &quot;uvchr_to_utf8_flags&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     uvchr_to_utf8(U8 *d, UV uv)
    </pre>
  </dd>
  <dt>uvchr_to_utf8_flags</dt>
  <dd>Adds the UTF-8 representation of the native code point
      <span class="Li">&quot;uv&quot;</span> to the end of the string
      <span class="Li">&quot;d&quot;</span>;
      <span class="Li">&quot;d&quot;</span> should have at least
      <span class="Li">&quot;UVCHR_SKIP(uv)+1&quot;</span> (up to
      <span class="Li">&quot;UTF8_MAXBYTES+1&quot;</span>) free bytes available.
      The return value is the pointer to the byte after the end of the new
      character. In other words,
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    d = uvchr_to_utf8_flags(d, uv, flags);
    </pre>
    <p class="Pp">or, in most cases,</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    d = uvchr_to_utf8_flags(d, uv, 0);
    </pre>
    <p class="Pp">This is the Unicode-aware way of saying</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    *(d++) = uv;
    </pre>
    <p class="Pp">If <span class="Li">&quot;flags&quot;</span> is 0, this
        function accepts any code point from
        0..<span class="Li">&quot;IV_MAX&quot;</span> as input.
        <span class="Li">&quot;IV_MAX&quot;</span> is typically 0x7FFF_FFFF in a
        32-bit word.</p>
    <p class="Pp">Specifying <span class="Li">&quot;flags&quot;</span> can
        further restrict what is allowed and not warned on, as follows:</p>
    <p class="Pp">If <span class="Li">&quot;uv&quot;</span> is a Unicode
        surrogate code point and
        <span class="Li">&quot;UNICODE_WARN_SURROGATE&quot;</span> is set, the
        function will raise a warning, provided UTF8 warnings are enabled. If
        instead <span class="Li">&quot;UNICODE_DISALLOW_SURROGATE&quot;</span>
        is set, the function will fail and return NULL. If both flags are set,
        the function will both warn and return NULL.</p>
    <p class="Pp">Similarly, the
        <span class="Li">&quot;UNICODE_WARN_NONCHAR&quot;</span> and
        <span class="Li">&quot;UNICODE_DISALLOW_NONCHAR&quot;</span> flags
        affect how the function handles a Unicode non-character.</p>
    <p class="Pp">And likewise, the
        <span class="Li">&quot;UNICODE_WARN_SUPER&quot;</span> and
        <span class="Li">&quot;UNICODE_DISALLOW_SUPER&quot;</span> flags affect
        the handling of code points that are above the Unicode maximum of
        0x10FFFF. Languages other than Perl may not be able to accept files that
        contain these.</p>
    <p class="Pp">The flag
        <span class="Li">&quot;UNICODE_WARN_ILLEGAL_INTERCHANGE&quot;</span>
        selects all three of the above WARN flags; and
        <span class="Li">&quot;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&quot;</span>
        selects all three DISALLOW flags.
        <span class="Li">&quot;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&quot;</span>
        restricts the allowed inputs to the strict UTF-8 traditionally defined
        by Unicode. Similarly,
        <span class="Li">&quot;UNICODE_WARN_ILLEGAL_C9_INTERCHANGE&quot;</span>
        and
        <span class="Li">&quot;UNICODE_DISALLOW_ILLEGAL_C9_INTERCHANGE&quot;</span>
        are shortcuts to select the above-Unicode and surrogate flags, but not
        the non-character ones, as defined in Unicode Corrigendum #9
        &lt;http://www.unicode.org/versions/corrigendum9.html&gt;. See
        &quot;Noncharacter code points&quot; in perlunicode.</p>
    <p class="Pp">Extremely high code points were never specified in any
        standard, and require an extension to UTF-8 to express, which Perl does.
        It is likely that programs written in something other than Perl would
        not be able to read files that contain these; nor would Perl understand
        files written by something that uses a different extension. For these
        reasons, there is a separate set of flags that can warn and/or disallow
        these extremely high code points, even if other above-Unicode ones are
        accepted. They are the
        <span class="Li">&quot;UNICODE_WARN_PERL_EXTENDED&quot;</span> and
        <span class="Li">&quot;UNICODE_DISALLOW_PERL_EXTENDED&quot;</span>
        flags. For more information see
        &quot;<span class="Li">&quot;UTF8_GOT_PERL_EXTENDED&quot;</span>&quot;.
        Of course <span class="Li">&quot;UNICODE_DISALLOW_SUPER&quot;</span>
        will treat all above-Unicode code points, including these, as
        malformations. (Note that the Unicode standard considers anything above
        0x10FFFF to be illegal, but there are standards predating it that allow
        up to 0x7FFF_FFFF (2**31 -1))</p>
    <p class="Pp">A somewhat misleadingly named synonym for
        <span class="Li">&quot;UNICODE_WARN_PERL_EXTENDED&quot;</span> is
        retained for backward compatibility:
        <span class="Li">&quot;UNICODE_WARN_ABOVE_31_BIT&quot;</span>.
        Similarly,
        <span class="Li">&quot;UNICODE_DISALLOW_ABOVE_31_BIT&quot;</span> is
        usable instead of the more accurately named
        <span class="Li">&quot;UNICODE_DISALLOW_PERL_EXTENDED&quot;</span>. The
        names are misleading because on EBCDIC platforms,these flags can apply
        to code points that actually do fit in 31 bits. The new names accurately
        describe the situation in all cases.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     uvchr_to_utf8_flags(U8 *d, UV uv, UV flags)
    </pre>
  </dd>
  <dt>uvchr_to_utf8_flags_msgs</dt>
  <dd>NOTE: this function is experimental and may change or be removed without
      notice.
    <p class="Pp">THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED
        CIRCUMSTANCES.</p>
    <p class="Pp">Most code should use
        <span class="Li">&quot;&quot;uvchr_to_utf8_flags&quot;()&quot;</span>
        rather than call this directly.</p>
    <p class="Pp">This function is for code that wants any warning and/or error
        messages to be returned to the caller rather than be displayed. All
        messages that would have been displayed if all lexical warnings are
        enabled will be returned.</p>
    <p class="Pp">It is just like
        <span class="Li">&quot;uvchr_to_utf8_flags&quot;</span> but it takes an
        extra parameter placed after all the others,
        <span class="Li">&quot;msgs&quot;</span>. If this parameter is 0, this
        function behaves identically to
        <span class="Li">&quot;uvchr_to_utf8_flags&quot;</span>. Otherwise,
        <span class="Li">&quot;msgs&quot;</span> should be a pointer to an
        <span class="Li">&quot;HV *&quot;</span> variable, in which this
        function creates a new HV to contain any appropriate messages. The hash
        has three key-value pairs, as follows:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;text&quot;</dt>
  <dd>The text of the message as a
    <span class="Li">&quot;SVpv&quot;</span>.</dd>
  <dt>&quot;warn_categories&quot;</dt>
  <dd>The warning category (or categories) packed into a
      <span class="Li">&quot;SVuv&quot;</span>.</dd>
  <dt>&quot;flag&quot;</dt>
  <dd>A single flag bit associated with this message, in a
      <span class="Li">&quot;SVuv&quot;</span>. The bit corresponds to some bit
      in the <span class="Li">*errors</span> return value, such as
      <span class="Li">&quot;UNICODE_GOT_SURROGATE&quot;</span>.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">It's important to note that specifying this parameter as non-null
    will cause any warnings this function would otherwise generate to be
    suppressed, and instead be placed in <span class="Li">*msgs</span>. The
    caller can check the lexical warnings state (or not) when choosing what to
    do with the returned messages.</p>
<p class="Pp">The caller, of course, is responsible for freeing any returned
  HV.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        U8*     uvchr_to_utf8_flags_msgs(U8 *d, UV uv, UV flags,
                                         HV ** msgs)
</pre>
</div>
<dl class="Bl-tag">
  <dt>uvoffuni_to_utf8_flags</dt>
  <dd>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.
      Instead, <b>Almost all code should use &quot;uvchr_to_utf8&quot; or</b>
      <b>&quot;uvchr_to_utf8_flags&quot;</b>.
    <p class="Pp">This function is like them, but the input is a strict Unicode
        (as opposed to native) code point. Only in very rare circumstances
        should code not be using the native code point.</p>
    <p class="Pp">For details, see the description for
        &quot;uvchr_to_utf8_flags&quot;.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     uvoffuni_to_utf8_flags(U8 *d, UV uv,
                                       const UV flags)
    </pre>
  </dd>
  <dt>uvuni_to_utf8_flags</dt>
  <dd>Instead you almost certainly want to use &quot;uvchr_to_utf8&quot; or
      &quot;uvchr_to_utf8_flags&quot;.
    <p class="Pp">This function is a deprecated synonym for
        &quot;uvoffuni_to_utf8_flags&quot;, which itself, while not deprecated,
        should be used only in isolated circumstances. These functions were
        useful for code that wanted to handle both EBCDIC and ASCII platforms
        with Unicode properties, but starting in Perl v5.20, the distinctions
        between the platforms have mostly been made invisible to most code, so
        this function is quite unlikely to be what you want.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U8*     uvuni_to_utf8_flags(U8 *d, UV uv, UV flags)
    </pre>
  </dd>
  <dt>valid_utf8_to_uvchr</dt>
  <dd>Like <span class="Li">&quot;utf8_to_uvchr_buf&quot;</span>, but should
      only be called when it is known that the next character in the input UTF-8
      string <span class="Li">&quot;s&quot;</span> is well-formed (<i>e.g.</i>,
      it passes <span class="Li">&quot;isUTF8_CHAR&quot;</span>. Surrogates,
      non-character code points, and non-Unicode code points are allowed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        UV      valid_utf8_to_uvchr(const U8 *s, STRLEN *retlen)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Variables_created_by__xsubpp__and__xsubpp__internal_functions"><a class="permalink" href="#Variables_created_by__xsubpp__and__xsubpp__internal_functions">Variables
  created by &quot;xsubpp&quot; and &quot;xsubpp&quot; internal
  functions</a></h1>
<dl class="Bl-tag">
  <dt>newXSproto</dt>
  <dd>Used by <span class="Li">&quot;xsubpp&quot;</span> to hook up XSUBs as
      Perl subs. Adds Perl prototypes to the subs.</dd>
  <dt>XS_APIVERSION_BOOTCHECK</dt>
  <dd>Macro to verify that the perl api version an XS module has been compiled
      against matches the api version of the perl interpreter it's being loaded
      into.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XS_APIVERSION_BOOTCHECK;
    </pre>
  </dd>
  <dt>XS_VERSION</dt>
  <dd>The version identifier for an XS module. This is usually handled
      automatically by <span class="Li">&quot;ExtUtils::MakeMaker&quot;</span>.
      See <span class="Li">&quot;XS_VERSION_BOOTCHECK&quot;</span>.</dd>
  <dt>XS_VERSION_BOOTCHECK</dt>
  <dd>Macro to verify that a PM module's <span class="Li">$VERSION</span>
      variable matches the XS module's
      <span class="Li">&quot;XS_VERSION&quot;</span> variable. This is usually
      handled automatically by <span class="Li">&quot;xsubpp&quot;</span>. See
      &quot;The VERSIONCHECK: Keyword&quot; in perlxs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                XS_VERSION_BOOTCHECK;
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Warning_and_Dieing"><a class="permalink" href="#Warning_and_Dieing">Warning
  and Dieing</a></h1>
<dl class="Bl-tag">
  <dt>ckWARN</dt>
  <dd>Returns a boolean as to whether or not warnings are enabled for the
      warning category <span class="Li">&quot;w&quot;</span>. If the category is
      by default enabled even if not within the scope of
      <span class="Li">&quot;use&#x00A0;warnings&quot;</span>, instead use the
      &quot;ckWARN_d&quot; macro.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    ckWARN(U32 w)
    </pre>
  </dd>
  <dt>ckWARN2</dt>
  <dd>Like <span class="Li">&quot;ckWARN&quot;</span>, but takes two warnings
      categories as input, and returns TRUE if either is enabled. If either
      category is by default enabled even if not within the scope of
      <span class="Li">&quot;use&#x00A0;warnings&quot;</span>, instead use the
      &quot;ckWARN2_d&quot; macro. The categories must be completely
      independent, one may not be subclassed from the other.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    ckWARN2(U32 w1, U32 w2)
    </pre>
  </dd>
  <dt>ckWARN3</dt>
  <dd>Like <span class="Li">&quot;ckWARN2&quot;</span>, but takes three warnings
      categories as input, and returns TRUE if any is enabled. If any of the
      categories is by default enabled even if not within the scope of
      <span class="Li">&quot;use&#x00A0;warnings&quot;</span>, instead use the
      &quot;ckWARN3_d&quot; macro. The categories must be completely
      independent, one may not be subclassed from any other.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    ckWARN3(U32 w1, U32 w2, U32 w3)
    </pre>
  </dd>
  <dt>ckWARN4</dt>
  <dd>Like <span class="Li">&quot;ckWARN3&quot;</span>, but takes four warnings
      categories as input, and returns TRUE if any is enabled. If any of the
      categories is by default enabled even if not within the scope of
      <span class="Li">&quot;use&#x00A0;warnings&quot;</span>, instead use the
      &quot;ckWARN4_d&quot; macro. The categories must be completely
      independent, one may not be subclassed from any other.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    ckWARN4(U32 w1, U32 w2, U32 w3, U32 w4)
    </pre>
  </dd>
  <dt>ckWARN_d</dt>
  <dd>Like <span class="Li">&quot;ckWARN&quot;</span>, but for use if and only
      if the warning category is by default enabled even if not within the scope
      of <span class="Li">&quot;use&#x00A0;warnings&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    ckWARN_d(U32 w)
    </pre>
  </dd>
  <dt>ckWARN2_d</dt>
  <dd>Like <span class="Li">&quot;ckWARN2&quot;</span>, but for use if and only
      if either warning category is by default enabled even if not within the
      scope of <span class="Li">&quot;use&#x00A0;warnings&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    ckWARN2_d(U32 w1, U32 w2)
    </pre>
  </dd>
  <dt>ckWARN3_d</dt>
  <dd>Like <span class="Li">&quot;ckWARN3&quot;</span>, but for use if and only
      if any of the warning categories is by default enabled even if not within
      the scope of <span class="Li">&quot;use&#x00A0;warnings&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    ckWARN3_d(U32 w1, U32 w2, U32 w3)
    </pre>
  </dd>
  <dt>ckWARN4_d</dt>
  <dd>Like <span class="Li">&quot;ckWARN4&quot;</span>, but for use if and only
      if any of the warning categories is by default enabled even if not within
      the scope of <span class="Li">&quot;use&#x00A0;warnings&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    ckWARN4_d(U32 w1, U32 w2, U32 w3, U32 w4)
    </pre>
  </dd>
  <dt>croak</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;die&quot;</span>
      function.
    <p class="Pp">Take a sprintf-style format pattern and argument list. These
        are used to generate a string message. If the message does not end with
        a newline, then it will be extended with some indication of the current
        location in the code, as described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message will be used as an exception, by default
        returning control to the nearest enclosing
        <span class="Li">&quot;eval&quot;</span>, but subject to modification by
        a <span class="Li">$SIG{__DIE__}</span> handler. In any case, the
        <span class="Li">&quot;croak&quot;</span> function never returns
        normally.</p>
    <p class="Pp">For historical reasons, if
        <span class="Li">&quot;pat&quot;</span> is null then the contents of
        <span class="Li">&quot;ERRSV&quot;</span> (<span class="Li">$@</span>)
        will be used as an error message or object instead of building an error
        message from arguments. If you want to throw a non-string object, or
        build an error message in an SV yourself, it is preferable to use the
        &quot;croak_sv&quot; function, which does not involve clobbering
        <span class="Li">&quot;ERRSV&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    croak(const char *pat, ...)
    </pre>
  </dd>
  <dt>croak_no_modify</dt>
  <dd>Exactly equivalent to <span class="Li">&quot;Perl_croak(aTHX_
      &quot;%s&quot;, PL_no_modify)&quot;</span>, but generates terser object
      code than using <span class="Li">&quot;Perl_croak&quot;</span>. Less code
      used on exception code paths reduces CPU cache pressure.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    croak_no_modify()
    </pre>
  </dd>
  <dt>croak_sv</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;die&quot;</span>
      function.
    <p class="Pp"><span class="Li">&quot;baseex&quot;</span> is the error
        message or object. If it is a reference, it will be used as-is.
        Otherwise it is used as a string, and if it does not end with a newline
        then it will be extended with some indication of the current location in
        the code, as described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message or object will be used as an exception, by
        default returning control to the nearest enclosing
        <span class="Li">&quot;eval&quot;</span>, but subject to modification by
        a <span class="Li">$SIG{__DIE__}</span> handler. In any case, the
        <span class="Li">&quot;croak_sv&quot;</span> function never returns
        normally.</p>
    <p class="Pp">To die with a simple string message, the &quot;croak&quot;
        function may be more convenient.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    croak_sv(SV *baseex)
    </pre>
  </dd>
  <dt>die</dt>
  <dd>Behaves the same as &quot;croak&quot;, except for the return type. It
      should be used only where the <span class="Li">&quot;OP *&quot;</span>
      return type is required. The function never actually returns.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    die(const char *pat, ...)
    </pre>
  </dd>
  <dt>die_sv</dt>
  <dd>Behaves the same as &quot;croak_sv&quot;, except for the return type. It
      should be used only where the <span class="Li">&quot;OP *&quot;</span>
      return type is required. The function never actually returns.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP *    die_sv(SV *baseex)
    </pre>
  </dd>
  <dt>vcroak</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;die&quot;</span>
      function.
    <p class="Pp"><span class="Li">&quot;pat&quot;</span> and
        <span class="Li">&quot;args&quot;</span> are a sprintf-style format
        pattern and encapsulated argument list. These are used to generate a
        string message. If the message does not end with a newline, then it will
        be extended with some indication of the current location in the code, as
        described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message will be used as an exception, by default
        returning control to the nearest enclosing
        <span class="Li">&quot;eval&quot;</span>, but subject to modification by
        a <span class="Li">$SIG{__DIE__}</span> handler. In any case, the
        <span class="Li">&quot;croak&quot;</span> function never returns
        normally.</p>
    <p class="Pp">For historical reasons, if
        <span class="Li">&quot;pat&quot;</span> is null then the contents of
        <span class="Li">&quot;ERRSV&quot;</span> (<span class="Li">$@</span>)
        will be used as an error message or object instead of building an error
        message from arguments. If you want to throw a non-string object, or
        build an error message in an SV yourself, it is preferable to use the
        &quot;croak_sv&quot; function, which does not involve clobbering
        <span class="Li">&quot;ERRSV&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    vcroak(const char *pat, va_list *args)
    </pre>
  </dd>
  <dt>vwarn</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;warn&quot;</span>
      function.
    <p class="Pp"><span class="Li">&quot;pat&quot;</span> and
        <span class="Li">&quot;args&quot;</span> are a sprintf-style format
        pattern and encapsulated argument list. These are used to generate a
        string message. If the message does not end with a newline, then it will
        be extended with some indication of the current location in the code, as
        described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message or object will by default be written to
        standard error, but this is subject to modification by a
        <span class="Li">$SIG{__WARN__}</span> handler.</p>
    <p class="Pp">Unlike with &quot;vcroak&quot;,
        <span class="Li">&quot;pat&quot;</span> is not permitted to be null.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    vwarn(const char *pat, va_list *args)
    </pre>
  </dd>
  <dt>warn</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;warn&quot;</span>
      function.
    <p class="Pp">Take a sprintf-style format pattern and argument list. These
        are used to generate a string message. If the message does not end with
        a newline, then it will be extended with some indication of the current
        location in the code, as described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message or object will by default be written to
        standard error, but this is subject to modification by a
        <span class="Li">$SIG{__WARN__}</span> handler.</p>
    <p class="Pp">Unlike with &quot;croak&quot;,
        <span class="Li">&quot;pat&quot;</span> is not permitted to be null.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    warn(const char *pat, ...)
    </pre>
  </dd>
  <dt>warn_sv</dt>
  <dd>This is an XS interface to Perl's <span class="Li">&quot;warn&quot;</span>
      function.
    <p class="Pp"><span class="Li">&quot;baseex&quot;</span> is the error
        message or object. If it is a reference, it will be used as-is.
        Otherwise it is used as a string, and if it does not end with a newline
        then it will be extended with some indication of the current location in
        the code, as described for &quot;mess_sv&quot;.</p>
    <p class="Pp">The error message or object will by default be written to
        standard error, but this is subject to modification by a
        <span class="Li">$SIG{__WARN__}</span> handler.</p>
    <p class="Pp">To warn with a simple string message, the &quot;warn&quot;
        function may be more convenient.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    warn_sv(SV *baseex)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Undocumented_functions"><a class="permalink" href="#Undocumented_functions">Undocumented
  functions</a></h1>
The following functions have been flagged as part of the public API, but are
  currently undocumented. Use them at your own risk, as the interfaces are
  subject to change. Functions that are not listed in this document are not
  intended for public use, and should NOT be used under any circumstances.
<p class="Pp">If you feel you need to use one of these functions, first send
    email to perl5-porters@perl.org &lt;mailto:perl5-porters@perl.org&gt;. It
    may be that there is a good reason for the function not being documented,
    and it should be removed from this list; or it may just be that no one has
    gotten around to documenting it. In the latter case, you will be asked to
    submit a patch to document the function. Once your patch is accepted, it
    will indicate that the interface is stable (unless it is explicitly marked
    otherwise) and usable by you.</p>
<dl class="Bl-tag">
  <dt>GetVars</dt>
  <dd></dd>
  <dt>Gv_AMupdate</dt>
  <dd></dd>
  <dt>PerlIO_clearerr</dt>
  <dd></dd>
  <dt>PerlIO_close</dt>
  <dd></dd>
  <dt>PerlIO_context_layers</dt>
  <dd></dd>
  <dt>PerlIO_eof</dt>
  <dd></dd>
  <dt>PerlIO_error</dt>
  <dd></dd>
  <dt>PerlIO_fileno</dt>
  <dd></dd>
  <dt>PerlIO_fill</dt>
  <dd></dd>
  <dt>PerlIO_flush</dt>
  <dd></dd>
  <dt>PerlIO_get_base</dt>
  <dd></dd>
  <dt>PerlIO_get_bufsiz</dt>
  <dd></dd>
  <dt>PerlIO_get_cnt</dt>
  <dd></dd>
  <dt>PerlIO_get_ptr</dt>
  <dd></dd>
  <dt>PerlIO_read</dt>
  <dd></dd>
  <dt>PerlIO_seek</dt>
  <dd></dd>
  <dt>PerlIO_set_cnt</dt>
  <dd></dd>
  <dt>PerlIO_set_ptrcnt</dt>
  <dd></dd>
  <dt>PerlIO_setlinebuf</dt>
  <dd></dd>
  <dt>PerlIO_stderr</dt>
  <dd></dd>
  <dt>PerlIO_stdin</dt>
  <dd></dd>
  <dt>PerlIO_stdout</dt>
  <dd></dd>
  <dt>PerlIO_tell</dt>
  <dd></dd>
  <dt>PerlIO_unread</dt>
  <dd></dd>
  <dt>PerlIO_write</dt>
  <dd></dd>
  <dt>_variant_byte_number</dt>
  <dd></dd>
  <dt>amagic_call</dt>
  <dd></dd>
  <dt>amagic_deref_call</dt>
  <dd></dd>
  <dt>any_dup</dt>
  <dd></dd>
  <dt>atfork_lock</dt>
  <dd></dd>
  <dt>atfork_unlock</dt>
  <dd></dd>
  <dt>av_arylen_p</dt>
  <dd></dd>
  <dt>av_iter_p</dt>
  <dd></dd>
  <dt>block_gimme</dt>
  <dd></dd>
  <dt>call_atexit</dt>
  <dd></dd>
  <dt>call_list</dt>
  <dd></dd>
  <dt>calloc</dt>
  <dd></dd>
  <dt>cast_i32</dt>
  <dd></dd>
  <dt>cast_iv</dt>
  <dd></dd>
  <dt>cast_ulong</dt>
  <dd></dd>
  <dt>cast_uv</dt>
  <dd></dd>
  <dt>ck_warner</dt>
  <dd></dd>
  <dt>ck_warner_d</dt>
  <dd></dd>
  <dt>ckwarn</dt>
  <dd></dd>
  <dt>ckwarn_d</dt>
  <dd></dd>
  <dt>clear_defarray</dt>
  <dd></dd>
  <dt>clone_params_del</dt>
  <dd></dd>
  <dt>clone_params_new</dt>
  <dd></dd>
  <dt>croak_memory_wrap</dt>
  <dd></dd>
  <dt>croak_nocontext</dt>
  <dd></dd>
  <dt>csighandler</dt>
  <dd></dd>
  <dt>cx_dump</dt>
  <dd></dd>
  <dt>cx_dup</dt>
  <dd></dd>
  <dt>cxinc</dt>
  <dd></dd>
  <dt>deb</dt>
  <dd></dd>
  <dt>deb_nocontext</dt>
  <dd></dd>
  <dt>debop</dt>
  <dd></dd>
  <dt>debprofdump</dt>
  <dd></dd>
  <dt>debstack</dt>
  <dd></dd>
  <dt>debstackptrs</dt>
  <dd></dd>
  <dt>delimcpy</dt>
  <dd></dd>
  <dt>despatch_signals</dt>
  <dd></dd>
  <dt>die_nocontext</dt>
  <dd></dd>
  <dt>dirp_dup</dt>
  <dd></dd>
  <dt>do_aspawn</dt>
  <dd></dd>
  <dt>do_binmode</dt>
  <dd></dd>
  <dt>do_close</dt>
  <dd></dd>
  <dt>do_gv_dump</dt>
  <dd></dd>
  <dt>do_gvgv_dump</dt>
  <dd></dd>
  <dt>do_hv_dump</dt>
  <dd></dd>
  <dt>do_join</dt>
  <dd></dd>
  <dt>do_magic_dump</dt>
  <dd></dd>
  <dt>do_op_dump</dt>
  <dd></dd>
  <dt>do_open</dt>
  <dd></dd>
  <dt>do_open9</dt>
  <dd></dd>
  <dt>do_openn</dt>
  <dd></dd>
  <dt>do_pmop_dump</dt>
  <dd></dd>
  <dt>do_spawn</dt>
  <dd></dd>
  <dt>do_spawn_nowait</dt>
  <dd></dd>
  <dt>do_sprintf</dt>
  <dd></dd>
  <dt>do_sv_dump</dt>
  <dd></dd>
  <dt>doing_taint</dt>
  <dd></dd>
  <dt>doref</dt>
  <dd></dd>
  <dt>dounwind</dt>
  <dd></dd>
  <dt>dowantarray</dt>
  <dd></dd>
  <dt>dump_eval</dt>
  <dd></dd>
  <dt>dump_form</dt>
  <dd></dd>
  <dt>dump_indent</dt>
  <dd></dd>
  <dt>dump_mstats</dt>
  <dd></dd>
  <dt>dump_sub</dt>
  <dd></dd>
  <dt>dump_vindent</dt>
  <dd></dd>
  <dt>filter_add</dt>
  <dd></dd>
  <dt>filter_del</dt>
  <dd></dd>
  <dt>filter_read</dt>
  <dd></dd>
  <dt>foldEQ_latin1</dt>
  <dd></dd>
  <dt>form_nocontext</dt>
  <dd></dd>
  <dt>fp_dup</dt>
  <dd></dd>
  <dt>fprintf_nocontext</dt>
  <dd></dd>
  <dt>free_global_struct</dt>
  <dd></dd>
  <dt>free_tmps</dt>
  <dd></dd>
  <dt>get_context</dt>
  <dd></dd>
  <dt>get_mstats</dt>
  <dd></dd>
  <dt>get_op_descs</dt>
  <dd></dd>
  <dt>get_op_names</dt>
  <dd></dd>
  <dt>get_ppaddr</dt>
  <dd></dd>
  <dt>get_vtbl</dt>
  <dd></dd>
  <dt>gp_dup</dt>
  <dd></dd>
  <dt>gp_free</dt>
  <dd></dd>
  <dt>gp_ref</dt>
  <dd></dd>
  <dt>gv_AVadd</dt>
  <dd></dd>
  <dt>gv_HVadd</dt>
  <dd></dd>
  <dt>gv_IOadd</dt>
  <dd></dd>
  <dt>gv_SVadd</dt>
  <dd></dd>
  <dt>gv_add_by_type</dt>
  <dd></dd>
  <dt>gv_autoload4</dt>
  <dd></dd>
  <dt>gv_autoload_pv</dt>
  <dd></dd>
  <dt>gv_autoload_pvn</dt>
  <dd></dd>
  <dt>gv_autoload_sv</dt>
  <dd></dd>
  <dt>gv_check</dt>
  <dd></dd>
  <dt>gv_dump</dt>
  <dd></dd>
  <dt>gv_efullname</dt>
  <dd></dd>
  <dt>gv_efullname3</dt>
  <dd></dd>
  <dt>gv_efullname4</dt>
  <dd></dd>
  <dt>gv_fetchfile</dt>
  <dd></dd>
  <dt>gv_fetchfile_flags</dt>
  <dd></dd>
  <dt>gv_fetchpv</dt>
  <dd></dd>
  <dt>gv_fetchpvn_flags</dt>
  <dd></dd>
  <dt>gv_fetchsv</dt>
  <dd></dd>
  <dt>gv_fullname</dt>
  <dd></dd>
  <dt>gv_fullname3</dt>
  <dd></dd>
  <dt>gv_fullname4</dt>
  <dd></dd>
  <dt>gv_handler</dt>
  <dd></dd>
  <dt>gv_name_set</dt>
  <dd></dd>
  <dt>he_dup</dt>
  <dd></dd>
  <dt>hek_dup</dt>
  <dd></dd>
  <dt>hv_common</dt>
  <dd></dd>
  <dt>hv_common_key_len</dt>
  <dd></dd>
  <dt>hv_delayfree_ent</dt>
  <dd></dd>
  <dt>hv_eiter_p</dt>
  <dd></dd>
  <dt>hv_eiter_set</dt>
  <dd></dd>
  <dt>hv_free_ent</dt>
  <dd></dd>
  <dt>hv_ksplit</dt>
  <dd></dd>
  <dt>hv_name_set</dt>
  <dd></dd>
  <dt>hv_placeholders_get</dt>
  <dd></dd>
  <dt>hv_placeholders_set</dt>
  <dd></dd>
  <dt>hv_rand_set</dt>
  <dd></dd>
  <dt>hv_riter_p</dt>
  <dd></dd>
  <dt>hv_riter_set</dt>
  <dd></dd>
  <dt>ibcmp_utf8</dt>
  <dd></dd>
  <dt>init_global_struct</dt>
  <dd></dd>
  <dt>init_stacks</dt>
  <dd></dd>
  <dt>init_tm</dt>
  <dd></dd>
  <dt>instr</dt>
  <dd></dd>
  <dt>is_lvalue_sub</dt>
  <dd></dd>
  <dt>leave_scope</dt>
  <dd></dd>
  <dt>load_module_nocontext</dt>
  <dd></dd>
  <dt>magic_dump</dt>
  <dd></dd>
  <dt>malloc</dt>
  <dd></dd>
  <dt>markstack_grow</dt>
  <dd></dd>
  <dt>mess_nocontext</dt>
  <dd></dd>
  <dt>mfree</dt>
  <dd></dd>
  <dt>mg_dup</dt>
  <dd></dd>
  <dt>mg_size</dt>
  <dd></dd>
  <dt>mini_mktime</dt>
  <dd></dd>
  <dt>moreswitches</dt>
  <dd></dd>
  <dt>mro_get_from_name</dt>
  <dd></dd>
  <dt>mro_get_private_data</dt>
  <dd></dd>
  <dt>mro_set_mro</dt>
  <dd></dd>
  <dt>mro_set_private_data</dt>
  <dd></dd>
  <dt>my_atof</dt>
  <dd></dd>
  <dt>my_atof2</dt>
  <dd></dd>
  <dt>my_atof3</dt>
  <dd></dd>
  <dt>my_chsize</dt>
  <dd></dd>
  <dt>my_cxt_index</dt>
  <dd></dd>
  <dt>my_cxt_init</dt>
  <dd></dd>
  <dt>my_dirfd</dt>
  <dd></dd>
  <dt>my_exit</dt>
  <dd></dd>
  <dt>my_failure_exit</dt>
  <dd></dd>
  <dt>my_fflush_all</dt>
  <dd></dd>
  <dt>my_fork</dt>
  <dd></dd>
  <dt>my_lstat</dt>
  <dd></dd>
  <dt>my_pclose</dt>
  <dd></dd>
  <dt>my_popen</dt>
  <dd></dd>
  <dt>my_popen_list</dt>
  <dd></dd>
  <dt>my_setenv</dt>
  <dd></dd>
  <dt>my_socketpair</dt>
  <dd></dd>
  <dt>my_stat</dt>
  <dd></dd>
  <dt>my_strftime</dt>
  <dd></dd>
  <dt>newANONATTRSUB</dt>
  <dd></dd>
  <dt>newANONHASH</dt>
  <dd></dd>
  <dt>newANONLIST</dt>
  <dd></dd>
  <dt>newANONSUB</dt>
  <dd></dd>
  <dt>newATTRSUB</dt>
  <dd></dd>
  <dt>newAVREF</dt>
  <dd></dd>
  <dt>newCVREF</dt>
  <dd></dd>
  <dt>newFORM</dt>
  <dd></dd>
  <dt>newGVREF</dt>
  <dd></dd>
  <dt>newGVgen</dt>
  <dd></dd>
  <dt>newGVgen_flags</dt>
  <dd></dd>
  <dt>newHVREF</dt>
  <dd></dd>
  <dt>newHVhv</dt>
  <dd></dd>
  <dt>newIO</dt>
  <dd></dd>
  <dt>newMYSUB</dt>
  <dd></dd>
  <dt>newPROG</dt>
  <dd></dd>
  <dt>newRV</dt>
  <dd></dd>
  <dt>newSUB</dt>
  <dd></dd>
  <dt>newSVREF</dt>
  <dd></dd>
  <dt>newSVpvf_nocontext</dt>
  <dd></dd>
  <dt>newSVsv_flags</dt>
  <dd></dd>
  <dt>new_stackinfo</dt>
  <dd></dd>
  <dt>op_refcnt_lock</dt>
  <dd></dd>
  <dt>op_refcnt_unlock</dt>
  <dd></dd>
  <dt>parser_dup</dt>
  <dd></dd>
  <dt>perl_alloc_using</dt>
  <dd></dd>
  <dt>perl_clone_using</dt>
  <dd></dd>
  <dt>pmop_dump</dt>
  <dd></dd>
  <dt>pop_scope</dt>
  <dd></dd>
  <dt>pregcomp</dt>
  <dd></dd>
  <dt>pregexec</dt>
  <dd></dd>
  <dt>pregfree</dt>
  <dd></dd>
  <dt>pregfree2</dt>
  <dd></dd>
  <dt>printf_nocontext</dt>
  <dd></dd>
  <dt>ptr_table_fetch</dt>
  <dd></dd>
  <dt>ptr_table_free</dt>
  <dd></dd>
  <dt>ptr_table_new</dt>
  <dd></dd>
  <dt>ptr_table_split</dt>
  <dd></dd>
  <dt>ptr_table_store</dt>
  <dd></dd>
  <dt>push_scope</dt>
  <dd></dd>
  <dt>re_compile</dt>
  <dd></dd>
  <dt>re_dup_guts</dt>
  <dd></dd>
  <dt>re_intuit_start</dt>
  <dd></dd>
  <dt>re_intuit_string</dt>
  <dd></dd>
  <dt>realloc</dt>
  <dd></dd>
  <dt>reentrant_free</dt>
  <dd></dd>
  <dt>reentrant_init</dt>
  <dd></dd>
  <dt>reentrant_retry</dt>
  <dd></dd>
  <dt>reentrant_size</dt>
  <dd></dd>
  <dt>ref</dt>
  <dd></dd>
  <dt>reg_named_buff_all</dt>
  <dd></dd>
  <dt>reg_named_buff_exists</dt>
  <dd></dd>
  <dt>reg_named_buff_fetch</dt>
  <dd></dd>
  <dt>reg_named_buff_firstkey</dt>
  <dd></dd>
  <dt>reg_named_buff_nextkey</dt>
  <dd></dd>
  <dt>reg_named_buff_scalar</dt>
  <dd></dd>
  <dt>regdump</dt>
  <dd></dd>
  <dt>regdupe_internal</dt>
  <dd></dd>
  <dt>regexec_flags</dt>
  <dd></dd>
  <dt>regfree_internal</dt>
  <dd></dd>
  <dt>reginitcolors</dt>
  <dd></dd>
  <dt>regnext</dt>
  <dd></dd>
  <dt>repeatcpy</dt>
  <dd></dd>
  <dt>rsignal</dt>
  <dd></dd>
  <dt>rsignal_state</dt>
  <dd></dd>
  <dt>runops_debug</dt>
  <dd></dd>
  <dt>runops_standard</dt>
  <dd></dd>
  <dt>rvpv_dup</dt>
  <dd></dd>
  <dt>safesyscalloc</dt>
  <dd></dd>
  <dt>safesysfree</dt>
  <dd></dd>
  <dt>safesysmalloc</dt>
  <dd></dd>
  <dt>safesysrealloc</dt>
  <dd></dd>
  <dt>save_I16</dt>
  <dd></dd>
  <dt>save_I32</dt>
  <dd></dd>
  <dt>save_I8</dt>
  <dd></dd>
  <dt>save_adelete</dt>
  <dd></dd>
  <dt>save_aelem</dt>
  <dd></dd>
  <dt>save_aelem_flags</dt>
  <dd></dd>
  <dt>save_alloc</dt>
  <dd></dd>
  <dt>save_aptr</dt>
  <dd></dd>
  <dt>save_ary</dt>
  <dd></dd>
  <dt>save_bool</dt>
  <dd></dd>
  <dt>save_clearsv</dt>
  <dd></dd>
  <dt>save_delete</dt>
  <dd></dd>
  <dt>save_destructor</dt>
  <dd></dd>
  <dt>save_destructor_x</dt>
  <dd></dd>
  <dt>save_freeop</dt>
  <dd></dd>
  <dt>save_freepv</dt>
  <dd></dd>
  <dt>save_freesv</dt>
  <dd></dd>
  <dt>save_generic_pvref</dt>
  <dd></dd>
  <dt>save_generic_svref</dt>
  <dd></dd>
  <dt>save_hash</dt>
  <dd></dd>
  <dt>save_hdelete</dt>
  <dd></dd>
  <dt>save_helem</dt>
  <dd></dd>
  <dt>save_helem_flags</dt>
  <dd></dd>
  <dt>save_hints</dt>
  <dd></dd>
  <dt>save_hptr</dt>
  <dd></dd>
  <dt>save_int</dt>
  <dd></dd>
  <dt>save_item</dt>
  <dd></dd>
  <dt>save_iv</dt>
  <dd></dd>
  <dt>save_list</dt>
  <dd></dd>
  <dt>save_long</dt>
  <dd></dd>
  <dt>save_mortalizesv</dt>
  <dd></dd>
  <dt>save_nogv</dt>
  <dd></dd>
  <dt>save_op</dt>
  <dd></dd>
  <dt>save_padsv_and_mortalize</dt>
  <dd></dd>
  <dt>save_pptr</dt>
  <dd></dd>
  <dt>save_pushi32ptr</dt>
  <dd></dd>
  <dt>save_pushptr</dt>
  <dd></dd>
  <dt>save_pushptrptr</dt>
  <dd></dd>
  <dt>save_re_context</dt>
  <dd></dd>
  <dt>save_scalar</dt>
  <dd></dd>
  <dt>save_set_svflags</dt>
  <dd></dd>
  <dt>save_shared_pvref</dt>
  <dd></dd>
  <dt>save_sptr</dt>
  <dd></dd>
  <dt>save_svref</dt>
  <dd></dd>
  <dt>save_vptr</dt>
  <dd></dd>
  <dt>savestack_grow</dt>
  <dd></dd>
  <dt>savestack_grow_cnt</dt>
  <dd></dd>
  <dt>scan_num</dt>
  <dd></dd>
  <dt>scan_vstring</dt>
  <dd></dd>
  <dt>seed</dt>
  <dd></dd>
  <dt>set_context</dt>
  <dd></dd>
  <dt>share_hek</dt>
  <dd></dd>
  <dt>si_dup</dt>
  <dd></dd>
  <dt>ss_dup</dt>
  <dd></dd>
  <dt>stack_grow</dt>
  <dd></dd>
  <dt>start_subparse</dt>
  <dd></dd>
  <dt>str_to_version</dt>
  <dd></dd>
  <dt>sv_2iv</dt>
  <dd></dd>
  <dt>sv_2pv</dt>
  <dd></dd>
  <dt>sv_2uv</dt>
  <dd></dd>
  <dt>sv_catpvf_mg_nocontext</dt>
  <dd></dd>
  <dt>sv_catpvf_nocontext</dt>
  <dd></dd>
  <dt>sv_dup</dt>
  <dd></dd>
  <dt>sv_dup_inc</dt>
  <dd></dd>
  <dt>sv_peek</dt>
  <dd></dd>
  <dt>sv_pvn_nomg</dt>
  <dd></dd>
  <dt>sv_setpvf_mg_nocontext</dt>
  <dd></dd>
  <dt>sv_setpvf_nocontext</dt>
  <dd></dd>
  <dt>sys_init</dt>
  <dd></dd>
  <dt>sys_init3</dt>
  <dd></dd>
  <dt>sys_intern_clear</dt>
  <dd></dd>
  <dt>sys_intern_dup</dt>
  <dd></dd>
  <dt>sys_intern_init</dt>
  <dd></dd>
  <dt>sys_term</dt>
  <dd></dd>
  <dt>taint_env</dt>
  <dd></dd>
  <dt>taint_proper</dt>
  <dd></dd>
  <dt>unlnk</dt>
  <dd></dd>
  <dt>unsharepvn</dt>
  <dd></dd>
  <dt>uvuni_to_utf8</dt>
  <dd></dd>
  <dt>vdeb</dt>
  <dd></dd>
  <dt>vform</dt>
  <dd></dd>
  <dt>vload_module</dt>
  <dd></dd>
  <dt>vnewSVpvf</dt>
  <dd></dd>
  <dt>vwarner</dt>
  <dd></dd>
  <dt>warn_nocontext</dt>
  <dd></dd>
  <dt>warner</dt>
  <dd></dd>
  <dt>warner_nocontext</dt>
  <dd></dd>
  <dt>whichsig</dt>
  <dd></dd>
  <dt>whichsig_pv</dt>
  <dd></dd>
  <dt>whichsig_pvn</dt>
  <dd></dd>
  <dt>whichsig_sv</dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Until May 1997, this document was maintained by Jeff Okamoto
  &lt;okamoto@corp.hp.com&gt;. It is now maintained as part of Perl itself.
<p class="Pp">With lots of help and suggestions from Dean Roehrich, Malcolm
    Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil
    Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen
    McCamant, and Gurusamy Sarathy.</p>
<p class="Pp">API Listing originally by Dean Roehrich
  &lt;roehrich@cray.com&gt;.</p>
<p class="Pp">Updated to be autogenerated from comments in the source by
    Benjamin Stuhl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlguts, perlxs, perlxstut, perlintern
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-03-30</td>
    <td class="foot-os">perl v5.30.1</td>
  </tr>
</table>

	</div>
	<div class=footer>
		<p>Copyright 2020 Scott Court</p>
	</div>
	</div>
</body>
