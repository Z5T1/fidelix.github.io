
<!DOCTYPE HTML>
<head>
	<title>/usr/share/man/man1/pcretest.1</title>		<link rel='stylesheet' href='/mandoc.css' />
	<link rel='stylesheet' href='/style.css' />
</head>
<body>
	<div class=contents>
	<div class=header>
	<h1>The Fidelix Linux Distribution</h1>
	<h2>Simple, Stable, and Secure</h2>
	</div>
<div class=menubar>
	<ul>
		<li><a href=/>News</a></li>
		<li><a href=/about.html>About</a></li>
		<div class=dropdown>
			<li><a href=/download>Download</a></li>
			<ul class=dropdown-content>
				<li><a href=/download/>Latest Downloads</a></li>
				<li><a href=/download/all.html>All Downloads</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Documentation</a></li>
			<ul class=dropdown-content>
				<li><a href=/handbook/>Handbook</a></li>
				<li><a href=/man/>Manual Pages</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Development</a></li>
			<ul class=dropdown-content>
				<li><a href=https://github.com/Z5T1/fidelix>GitHub</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Community</a></li>
			<ul class=dropdown-content>
				<li><a href=https://discord.com/invite/Yz8DeUr>Discord</a></li>
			</ul>
		</div>
	</ul>
</div>


	<div class=body><table class="head">
  <tr>
    <td class="head-ltitle">PCRETEST(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">PCRETEST(1)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
pcretest - a program for testing Perl-compatible regular expressions.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>pcretest [options] [input file [output file]]</b>
<p class="Pp"><b>pcretest</b> was written as a test program for the PCRE regular
    expression library itself, but it can also be used for experimenting with
    regular expressions. This document describes the features of the test
    program; for details of the regular expressions themselves, see the
    <b>pcrepattern</b> documentation. For details of the PCRE library function
    calls and their options, see the <b>pcreapi</b> , <b>pcre16</b> and
    <b>pcre32</b> documentation.</p>
<p class="Pp">The input for <b>pcretest</b> is a sequence of regular expression
    patterns and strings to be matched, as described below. The output shows the
    result of each match. Options on the command line and the patterns control
    PCRE options and exactly what is output.</p>
<p class="Pp">As PCRE has evolved, it has acquired many different features, and
    as a result, <b>pcretest</b> now has rather a lot of obscure options for
    testing every possible feature. Some of these options are specifically
    designed for use in conjunction with the test script and data files that are
    distributed as part of PCRE, and are unlikely to be of use otherwise. They
    are all documented here, but without much justification.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INPUT_DATA_FORMAT"><a class="permalink" href="#INPUT_DATA_FORMAT">INPUT
  DATA FORMAT</a></h1>
Input to <b>pcretest</b> is processed line by line, either by calling the C
  library's <b>fgets()</b> function, or via the <b>libreadline</b> library (see
  below). In Unix-like environments, <b>fgets()</b> treats any bytes other than
  newline as data characters. However, in some Windows environments character 26
  (hex 1A) causes an immediate end of file, and no further data is read. For
  maximum portability, therefore, it is safest to use only ASCII characters in
  <b>pcretest</b> input files.
<p class="Pp">The input is processed using using C's string functions, so must
    not contain binary zeroes, even though in Unix-like environments,
    <b>fgets()</b> treats any bytes other than newline as data characters.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PCRE's_8-BIT,_16-BIT_AND_32-BIT_LIBRARIES"><a class="permalink" href="#PCRE's_8-BIT,_16-BIT_AND_32-BIT_LIBRARIES">PCRE's
  8-BIT, 16-BIT AND 32-BIT LIBRARIES</a></h1>
From release 8.30, two separate PCRE libraries can be built. The original one
  supports 8-bit character strings, whereas the newer 16-bit library supports
  character strings encoded in 16-bit units. From release 8.32, a third library
  can be built, supporting character strings encoded in 32-bit units. The
  <b>pcretest</b> program can be used to test all three libraries. However, it
  is itself still an 8-bit program, reading 8-bit input and writing 8-bit
  output. When testing the 16-bit or 32-bit library, the patterns and data
  strings are converted to 16- or 32-bit format before being passed to the PCRE
  library functions. Results are converted to 8-bit for output.
<p class="Pp">References to functions and structures of the form
    <b>pcre[16|32]_xx</b> below mean &quot;<b>pcre_xx</b> when using the 8-bit
    library, <b>pcre16_xx</b> when using the 16-bit library, or <b>pcre32_xx</b>
    when using the 32-bit library&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMAND_LINE_OPTIONS"><a class="permalink" href="#COMMAND_LINE_OPTIONS">COMMAND
  LINE OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt><b>-8</b></dt>
  <dd>If the 8-bit library has been built, this option causes it to be used
      (this is the default). If the 8-bit library has not been built, this
      option causes an error.</dd>
  <dt><b>-16</b></dt>
  <dd>If the 16-bit library has been built, this option causes it to be used. If
      only the 16-bit library has been built, this is the default. If the 16-bit
      library has not been built, this option causes an error.</dd>
  <dt><b>-32</b></dt>
  <dd>If the 32-bit library has been built, this option causes it to be used. If
      only the 32-bit library has been built, this is the default. If the 32-bit
      library has not been built, this option causes an error.</dd>
  <dt><b>-b</b></dt>
  <dd>Behave as if each pattern has the <b>/B</b> (show byte code) modifier; the
      internal form is output after compilation.</dd>
  <dt><b>-C</b></dt>
  <dd>Output the version number of the PCRE library, and all available
      information about the optional features that are included, and then exit
      with zero exit code. All other options are ignored.</dd>
  <dt><b>-C</b> <i>option</i></dt>
  <dd>Output information about a specific build-time option, then exit. This
      functionality is intended for use in scripts such as <b>RunTest</b>. The
      following options output the value and set the exit code as indicated:
    <p class="Pp">
       ebcdic-nl the code for LF (= NL) in an EBCDIC environment:
       0x15 or 0x25
       0 if used in an ASCII environment
       exit code is always 0
       linksize the configured internal link size (2, 3, or 4)
       exit code is set to the link size
       newline the default newline setting:
       CR, LF, CRLF, ANYCRLF, or ANY
       exit code is always 0
       bsr the default setting for what \R matches:
       ANYCRLF or ANY
       exit code is always 0</p>
    <p class="Pp">The following options output 1 for true or 0 for false, and
        set the exit code to the same value:</p>
    <p class="Pp">
       ebcdic compiled for an EBCDIC environment
       jit just-in-time support is available
       pcre16 the 16-bit library was built
       pcre32 the 32-bit library was built
       pcre8 the 8-bit library was built
       ucp Unicode property support is available
       utf UTF-8 and/or UTF-16 and/or UTF-32 support
       is available</p>
    <p class="Pp">If an unknown option is given, an error message is output; the
        exit code is 0.</p>
  </dd>
  <dt><b>-d</b></dt>
  <dd>Behave as if each pattern has the <b>/D</b> (debug) modifier; the internal
      form and information about the compiled pattern is output after
      compilation; <b>-d</b> is equivalent to <b>-b -i</b>.</dd>
  <dt><b>-dfa</b></dt>
  <dd>Behave as if each data line contains the \D escape sequence; this causes
      the alternative matching function, <b>pcre[16|32]_dfa_exec()</b>, to be
      used instead of the standard <b>pcre[16|32]_exec()</b> function (more
      detail is given below).</dd>
  <dt><b>-help</b></dt>
  <dd>Output a brief summary these options and then exit.</dd>
  <dt><b>-i</b></dt>
  <dd>Behave as if each pattern has the <b>/I</b> modifier; information about
      the compiled pattern is given after compilation.</dd>
  <dt><b>-M</b></dt>
  <dd>Behave as if each data line contains the \M escape sequence; this causes
      PCRE to discover the minimum MATCH_LIMIT and MATCH_LIMIT_RECURSION
      settings by calling <b>pcre[16|32]_exec()</b> repeatedly with different
      limits.</dd>
  <dt><b>-m</b></dt>
  <dd>Output the size of each compiled pattern after it has been compiled. This
      is equivalent to adding <b>/M</b> to each regular expression. The size is
      given in bytes for both libraries.</dd>
  <dt><b>-O</b></dt>
  <dd>Behave as if each pattern has the <b>/O</b> modifier, that is disable
      auto-possessification for all patterns.</dd>
  <dt><b>-o</b> <i>osize</i></dt>
  <dd>Set the number of elements in the output vector that is used when calling
      <b>pcre[16|32]_exec()</b> or <b>pcre[16|32]_dfa_exec()</b> to be
      <i>osize</i>. The default value is 45, which is enough for 14 capturing
      subexpressions for <b>pcre[16|32]_exec()</b> or 22 different matches for
      <b>pcre[16|32]_dfa_exec()</b>. The vector size can be changed for
      individual matching calls by including \O in the data line (see
    below).</dd>
  <dt><b>-p</b></dt>
  <dd>Behave as if each pattern has the <b>/P</b> modifier; the POSIX wrapper
      API is used to call PCRE. None of the other options has any effect when
      <b>-p</b> is set. This option can be used only with the 8-bit
    library.</dd>
  <dt><b>-q</b></dt>
  <dd>Do not output the version number of <b>pcretest</b> at the start of
      execution.</dd>
  <dt><b>-S</b> <i>size</i></dt>
  <dd>On Unix-like systems, set the size of the run-time stack to <i>size</i>
      megabytes.</dd>
  <dt><b>-s</b> or <b>-s+</b></dt>
  <dd>Behave as if each pattern has the <b>/S</b> modifier; in other words,
      force each pattern to be studied. If <b>-s+</b> is used, all the JIT
      compile options are passed to <b>pcre[16|32]_study()</b>, causing
      just-in-time optimization to be set up if it is available, for both full
      and partial matching. Specific JIT compile options can be selected by
      following <b>-s+</b> with a digit in the range 1 to 7, which selects the
      JIT compile modes as follows:
    <p class="Pp">
       1 normal match only
       2 soft partial match only
       3 normal match and soft partial match
       4 hard partial match only
       6 soft and hard partial match
       7 all three modes (default)</p>
    <p class="Pp">If <b>-s++</b> is used instead of <b>-s+</b> (with or without
        a following digit), the text &quot;(JIT)&quot; is added to the first
        output line after a match or no match when JIT-compiled code was
        actually used.</p>
    <p class="Pp">Note that there are pattern options that can override
        <b>-s</b>, either specifying no studying at all, or suppressing JIT
        compilation.</p>
    <p class="Pp">If the <b>/I</b> or <b>/D</b> option is present on a pattern
        (requesting output about the compiled pattern), information about the
        result of studying is not included when studying is caused only by
        <b>-s</b> and neither <b>-i</b> nor <b>-d</b> is present on the command
        line. This behaviour means that the output from tests that are run with
        and without <b>-s</b> should be identical, except when options that
        output information about the actual running of a match are set.</p>
    <p class="Pp">The <b>-M</b>, <b>-t</b>, and <b>-tm</b> options, which give
        information about resources used, are likely to produce different output
        with and without <b>-s</b>. Output may also differ if the <b>/C</b>
        option is present on an individual pattern. This uses callouts to trace
        the the matching process, and this may be different between studied and
        non-studied patterns. If the pattern contains (*MARK) items there may
        also be differences, for the same reason. The <b>-s</b> command line
        option can be overridden for specific patterns that should never be
        studied (see the <b>/S</b> pattern modifier below).</p>
  </dd>
  <dt><b>-t</b></dt>
  <dd>Run each compile, study, and match many times with a timer, and output the
      resulting times per compile, study, or match (in milliseconds). Do not set
      <b>-m</b> with <b>-t</b>, because you will then get the size output a
      zillion times, and the timing will be distorted. You can control the
      number of iterations that are used for timing by following <b>-t</b> with
      a number (as a separate item on the command line). For example, &quot;-t
      1000&quot; iterates 1000 times. The default is to iterate 500000
    times.</dd>
  <dt><b>-tm</b></dt>
  <dd>This is like <b>-t</b> except that it times only the matching phase, not
      the compile or study phases.</dd>
  <dt><b>-T</b> <b>-TM</b></dt>
  <dd>These behave like <b>-t</b> and <b>-tm</b>, but in addition, at the end of
      a run, the total times for all compiles, studies, and matches are
    output.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
If <b>pcretest</b> is given two filename arguments, it reads from the first and
  writes to the second. If it is given only one filename argument, it reads from
  that file and writes to stdout. Otherwise, it reads from stdin and writes to
  stdout, and prompts for each line of input, using &quot;re&gt;&quot; to prompt
  for regular expressions, and &quot;data&gt;&quot; to prompt for data lines.
<p class="Pp">When <b>pcretest</b> is built, a configuration option can specify
    that it should be linked with the <b>libreadline</b> library. When this is
    done, if the input is from a terminal, it is read using the
    <b>readline()</b> function. This provides line-editing and history
    facilities. The output from the <b>-help</b> option states whether or not
    <b>readline()</b> will be used.</p>
<p class="Pp">The program handles any number of sets of input on a single input
    file. Each set starts with a regular expression, and continues with any
    number of data lines to be matched against that pattern.</p>
<p class="Pp">Each data line is matched separately and independently. If you
    want to do multi-line matches, you have to use the \n escape sequence (or \r
    or \r\n, etc., depending on the newline setting) in a single line of input
    to encode the newline sequences. There is no limit on the length of data
    lines; the input buffer is automatically extended if it is too small.</p>
<p class="Pp">An empty line signals the end of the data lines, at which point a
    new regular expression is read. The regular expressions are given enclosed
    in any non-alphanumeric delimiters other than backslash, for example:</p>
<p class="Pp">
   /(a|bc)x+yz/</p>
<p class="Pp">White space before the initial delimiter is ignored. A regular
    expression may be continued over several input lines, in which case the
    newline characters are included within it. It is possible to include the
    delimiter within the pattern by escaping it, for example</p>
<p class="Pp">
   /abc\/def/</p>
<p class="Pp">If you do so, the escape and the delimiter form part of the
    pattern, but since delimiters are always non-alphanumeric, this does not
    affect its interpretation. If the terminating delimiter is immediately
    followed by a backslash, for example,</p>
<p class="Pp">
   /abc/\</p>
<p class="Pp">then a backslash is added to the end of the pattern. This is done
    to provide a way of testing the error condition that arises if a pattern
    finishes with a backslash, because</p>
<p class="Pp">
   /abc\/</p>
<p class="Pp">is interpreted as the first line of a pattern that starts with
    &quot;abc/&quot;, causing pcretest to read the next line as a continuation
    of the regular expression.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PATTERN_MODIFIERS"><a class="permalink" href="#PATTERN_MODIFIERS">PATTERN
  MODIFIERS</a></h1>
A pattern may be followed by any number of modifiers, which are mostly single
  characters, though some of these can be qualified by further characters.
  Following Perl usage, these are referred to below as, for example, &quot;the
  <b>/i</b> modifier&quot;, even though the delimiter of the pattern need not
  always be a slash, and no slash is used when writing modifiers. White space
  may appear between the final pattern delimiter and the first modifier, and
  between the modifiers themselves. For reference, here is a complete list of
  modifiers. They fall into several groups that are described in detail in the
  following sections.
<p class="Pp">
   <b>/8</b> set UTF mode
   <b>/9</b> set PCRE_NEVER_UTF (locks out UTF mode)
   <b>/?</b> disable UTF validity check
   <b>/+</b> show remainder of subject after match
   <b>/=</b> show all captures (not just those that are set)</p>
<p class="Pp">
   <b>/A</b> set PCRE_ANCHORED
   <b>/B</b> show compiled code
   <b>/C</b> set PCRE_AUTO_CALLOUT
   <b>/D</b> same as <b>/B</b> plus <b>/I</b>
   <b>/E</b> set PCRE_DOLLAR_ENDONLY
   <b>/F</b> flip byte order in compiled pattern
   <b>/f</b> set PCRE_FIRSTLINE
   <b>/G</b> find all matches (shorten string)
   <b>/g</b> find all matches (use startoffset)
   <b>/I</b> show information about pattern
   <b>/i</b> set PCRE_CASELESS
   <b>/J</b> set PCRE_DUPNAMES
   <b>/K</b> show backtracking control names
   <b>/L</b> set locale
   <b>/M</b> show compiled memory size
   <b>/m</b> set PCRE_MULTILINE
   <b>/N</b> set PCRE_NO_AUTO_CAPTURE
   <b>/O</b> set PCRE_NO_AUTO_POSSESS
   <b>/P</b> use the POSIX wrapper
   <b>/Q</b> test external stack check function
   <b>/S</b> study the pattern after compilation
   <b>/s</b> set PCRE_DOTALL
   <b>/T</b> select character tables
   <b>/U</b> set PCRE_UNGREEDY
   <b>/W</b> set PCRE_UCP
   <b>/X</b> set PCRE_EXTRA
   <b>/x</b> set PCRE_EXTENDED
   <b>/Y</b> set PCRE_NO_START_OPTIMIZE
   <b>/Z</b> don't show lengths in <b>/B</b> output</p>
<p class="Pp">
   <b>/&lt;any&gt;</b> set PCRE_NEWLINE_ANY
   <b>/&lt;anycrlf&gt;</b> set PCRE_NEWLINE_ANYCRLF
   <b>/&lt;cr&gt;</b> set PCRE_NEWLINE_CR
   <b>/&lt;crlf&gt;</b> set PCRE_NEWLINE_CRLF
   <b>/&lt;lf&gt;</b> set PCRE_NEWLINE_LF
   <b>/&lt;bsr_anycrlf&gt;</b> set PCRE_BSR_ANYCRLF
   <b>/&lt;bsr_unicode&gt;</b> set PCRE_BSR_UNICODE
   <b>/&lt;JS&gt;</b> set PCRE_JAVASCRIPT_COMPAT</p>
<p class="Pp"></p>
<section class="Ss">
<h2 class="Ss" id="Perl-compatible_modifiers"><a class="permalink" href="#Perl-compatible_modifiers">Perl-compatible
  modifiers</a></h2>
The <b>/i</b>, <b>/m</b>, <b>/s</b>, and <b>/x</b> modifiers set the
  PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, or PCRE_EXTENDED options,
  respectively, when <b>pcre[16|32]_compile()</b> is called. These four modifier
  letters have the same effect as they do in Perl. For example:
<p class="Pp">
   /caseless/i</p>
<p class="Pp"></p>
</section>
<section class="Ss">
<h2 class="Ss" id="Modifiers_for_other_PCRE_options"><a class="permalink" href="#Modifiers_for_other_PCRE_options">Modifiers
  for other PCRE options</a></h2>
The following table shows additional modifiers for setting PCRE compile-time
  options that do not correspond to anything in Perl:
<p class="Pp">
   <b>/8</b> PCRE_UTF8 ) when using the 8-bit
   <b>/?</b> PCRE_NO_UTF8_CHECK ) library</p>
<p class="Pp">
   <b>/8</b> PCRE_UTF16 ) when using the 16-bit
   <b>/?</b> PCRE_NO_UTF16_CHECK ) library</p>
<p class="Pp">
   <b>/8</b> PCRE_UTF32 ) when using the 32-bit
   <b>/?</b> PCRE_NO_UTF32_CHECK ) library</p>
<p class="Pp">
   <b>/9</b> PCRE_NEVER_UTF
   <b>/A</b> PCRE_ANCHORED
   <b>/C</b> PCRE_AUTO_CALLOUT
   <b>/E</b> PCRE_DOLLAR_ENDONLY
   <b>/f</b> PCRE_FIRSTLINE
   <b>/J</b> PCRE_DUPNAMES
   <b>/N</b> PCRE_NO_AUTO_CAPTURE
   <b>/O</b> PCRE_NO_AUTO_POSSESS
   <b>/U</b> PCRE_UNGREEDY
   <b>/W</b> PCRE_UCP
   <b>/X</b> PCRE_EXTRA
   <b>/Y</b> PCRE_NO_START_OPTIMIZE
   <b>/&lt;any&gt;</b> PCRE_NEWLINE_ANY
   <b>/&lt;anycrlf&gt;</b> PCRE_NEWLINE_ANYCRLF
   <b>/&lt;cr&gt;</b> PCRE_NEWLINE_CR
   <b>/&lt;crlf&gt;</b> PCRE_NEWLINE_CRLF
   <b>/&lt;lf&gt;</b> PCRE_NEWLINE_LF
   <b>/&lt;bsr_anycrlf&gt;</b> PCRE_BSR_ANYCRLF
   <b>/&lt;bsr_unicode&gt;</b> PCRE_BSR_UNICODE
   <b>/&lt;JS&gt;</b> PCRE_JAVASCRIPT_COMPAT</p>
<p class="Pp">The modifiers that are enclosed in angle brackets are literal
    strings as shown, including the angle brackets, but the letters within can
    be in either case. This example sets multiline matching with CRLF as the
    line ending sequence:</p>
<p class="Pp">
   /^abc/m&lt;CRLF&gt;</p>
<p class="Pp">As well as turning on the PCRE_UTF8/16/32 option, the <b>/8</b>
    modifier causes all non-printing characters in output strings to be printed
    using the \x{hh...} notation. Otherwise, those less than 0x100 are output in
    hex without the curly brackets.</p>
<p class="Pp">Full details of the PCRE options are given in the <b>pcreapi</b>
    documentation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Finding_all_matches_in_a_string"><a class="permalink" href="#Finding_all_matches_in_a_string">Finding
  all matches in a string</a></h2>
Searching for all possible matches within each subject string can be requested
  by the <b>/g</b> or <b>/G</b> modifier. After finding a match, PCRE is called
  again to search the remainder of the subject string. The difference between
  <b>/g</b> and <b>/G</b> is that the former uses the <i>startoffset</i>
  argument to <b>pcre[16|32]_exec()</b> to start searching at a new point within
  the entire string (which is in effect what Perl does), whereas the latter
  passes over a shortened substring. This makes a difference to the matching
  process if the pattern begins with a lookbehind assertion (including \b or
  \B).
<p class="Pp">If any call to <b>pcre[16|32]_exec()</b> in a <b>/g</b> or
    <b>/G</b> sequence matches an empty string, the next call is done with the
    PCRE_NOTEMPTY_ATSTART and PCRE_ANCHORED flags set in order to search for
    another, non-empty, match at the same point. If this second match fails, the
    start offset is advanced, and the normal match is retried. This imitates the
    way Perl handles such cases when using the <b>/g</b> modifier or the
    <b>split()</b> function. Normally, the start offset is advanced by one
    character, but if the newline convention recognizes CRLF as a newline, and
    the current character is CR followed by LF, an advance of two is used.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Other_modifiers"><a class="permalink" href="#Other_modifiers">Other
  modifiers</a></h2>
There are yet more modifiers for controlling the way <b>pcretest</b> operates.
<p class="Pp">The <b>/+</b> modifier requests that as well as outputting the
    substring that matched the entire pattern, <b>pcretest</b> should in
    addition output the remainder of the subject string. This is useful for
    tests where the subject contains multiple copies of the same substring. If
    the <b>+</b> modifier appears twice, the same action is taken for captured
    substrings. In each case the remainder is output on the following line with
    a plus character following the capture number. Note that this modifier must
    not immediately follow the /S modifier because /S+ and /S++ have other
    meanings.</p>
<p class="Pp">The <b>/=</b> modifier requests that the values of all potential
    captured parentheses be output after a match. By default, only those up to
    the highest one actually used in the match are output (corresponding to the
    return code from <b>pcre[16|32]_exec()</b>). Values in the offsets vector
    corresponding to higher numbers should be set to -1, and these are output as
    &quot;&lt;unset&gt;&quot;. This modifier gives a way of checking that this
    is happening.</p>
<p class="Pp">The <b>/B</b> modifier is a debugging feature. It requests that
    <b>pcretest</b> output a representation of the compiled code after
    compilation. Normally this information contains length and offset values;
    however, if <b>/Z</b> is also present, this data is replaced by spaces. This
    is a special feature for use in the automatic test scripts; it ensures that
    the same output is generated for different internal link sizes.</p>
<p class="Pp">The <b>/D</b> modifier is a PCRE debugging feature, and is
    equivalent to <b>/BI</b>, that is, both the <b>/B</b> and the <b>/I</b>
    modifiers.</p>
<p class="Pp">The <b>/F</b> modifier causes <b>pcretest</b> to flip the byte
    order of the 2-byte and 4-byte fields in the compiled pattern. This facility
    is for testing the feature in PCRE that allows it to execute patterns that
    were compiled on a host with a different endianness. This feature is not
    available when the POSIX interface to PCRE is being used, that is, when the
    <b>/P</b> pattern modifier is specified. See also the section about saving
    and reloading compiled patterns below.</p>
<p class="Pp">The <b>/I</b> modifier requests that <b>pcretest</b> output
    information about the compiled pattern (whether it is anchored, has a fixed
    first character, and so on). It does this by calling
    <b>pcre[16|32]_fullinfo()</b> after compiling a pattern. If the pattern is
    studied, the results of that are also output. In this output, the word
    &quot;char&quot; means a non-UTF character, that is, the value of a single
    data item (8-bit, 16-bit, or 32-bit, depending on the library that is being
    tested).</p>
<p class="Pp">The <b>/K</b> modifier requests <b>pcretest</b> to show names from
    backtracking control verbs that are returned from calls to
    <b>pcre[16|32]_exec()</b>. It causes <b>pcretest</b> to create a
    <b>pcre[16|32]_extra</b> block if one has not already been created by a call
    to <b>pcre[16|32]_study()</b>, and to set the PCRE_EXTRA_MARK flag and the
    <b>mark</b> field within it, every time that <b>pcre[16|32]_exec()</b> is
    called. If the variable that the <b>mark</b> field points to is non-NULL for
    a match, non-match, or partial match, <b>pcretest</b> prints the string to
    which it points. For a match, this is shown on a line by itself, tagged with
    &quot;MK:&quot;. For a non-match it is added to the message.</p>
<p class="Pp">The <b>/L</b> modifier must be followed directly by the name of a
    locale, for example,</p>
<p class="Pp">
   /pattern/Lfr_FR</p>
<p class="Pp">For this reason, it must be the last modifier. The given locale is
    set, <b>pcre[16|32]_maketables()</b> is called to build a set of character
    tables for the locale, and this is then passed to
    <b>pcre[16|32]_compile()</b> when compiling the regular expression. Without
    an <b>/L</b> (or <b>/T</b>) modifier, NULL is passed as the tables pointer;
    that is, <b>/L</b> applies only to the expression on which it appears.</p>
<p class="Pp">The <b>/M</b> modifier causes the size in bytes of the memory
    block used to hold the compiled pattern to be output. This does not include
    the size of the <b>pcre[16|32]</b> block; it is just the actual compiled
    data. If the pattern is successfully studied with the PCRE_STUDY_JIT_COMPILE
    option, the size of the JIT compiled code is also output.</p>
<p class="Pp">The <b>/Q</b> modifier is used to test the use of
    <b>pcre_stack_guard</b>. It must be followed by '0' or '1', specifying the
    return code to be given from an external function that is passed to PCRE and
    used for stack checking during compilation (see the <b>pcreapi</b>
    documentation for details).</p>
<p class="Pp">The <b>/S</b> modifier causes <b>pcre[16|32]_study()</b> to be
    called after the expression has been compiled, and the results used when the
    expression is matched. There are a number of qualifying characters that may
    follow <b>/S</b>. They may appear in any order.</p>
<p class="Pp">If <b>/S</b> is followed by an exclamation mark,
    <b>pcre[16|32]_study()</b> is called with the PCRE_STUDY_EXTRA_NEEDED
    option, causing it always to return a <b>pcre_extra</b> block, even when
    studying discovers no useful information.</p>
<p class="Pp">If <b>/S</b> is followed by a second S character, it suppresses
    studying, even if it was requested externally by the <b>-s</b> command line
    option. This makes it possible to specify that certain patterns are always
    studied, and others are never studied, independently of <b>-s</b>. This
    feature is used in the test files in a few cases where the output is
    different when the pattern is studied.</p>
<p class="Pp">If the <b>/S</b> modifier is followed by a + character, the call
    to <b>pcre[16|32]_study()</b> is made with all the JIT study options,
    requesting just-in-time optimization support if it is available, for both
    normal and partial matching. If you want to restrict the JIT compiling
    modes, you can follow <b>/S+</b> with a digit in the range 1 to 7:</p>
<p class="Pp">
   1 normal match only
   2 soft partial match only
   3 normal match and soft partial match
   4 hard partial match only
   6 soft and hard partial match
   7 all three modes (default)</p>
<p class="Pp">If <b>/S++</b> is used instead of <b>/S+</b> (with or without a
    following digit), the text &quot;(JIT)&quot; is added to the first output
    line after a match or no match when JIT-compiled code was actually used.</p>
<p class="Pp">Note that there is also an independent <b>/+</b> modifier; it must
    not be given immediately after <b>/S</b> or <b>/S+</b> because this will be
    misinterpreted.</p>
<p class="Pp">If JIT studying is successful, the compiled JIT code will
    automatically be used when <b>pcre[16|32]_exec()</b> is run, except when
    incompatible run-time options are specified. For more details, see the
    <b>pcrejit</b> documentation. See also the <b>\J</b> escape sequence below
    for a way of setting the size of the JIT stack.</p>
<p class="Pp">Finally, if <b>/S</b> is followed by a minus character, JIT
    compilation is suppressed, even if it was requested externally by the
    <b>-s</b> command line option. This makes it possible to specify that JIT is
    never to be used for certain patterns.</p>
<p class="Pp">The <b>/T</b> modifier must be followed by a single digit. It
    causes a specific set of built-in character tables to be passed to
    <b>pcre[16|32]_compile()</b>. It is used in the standard PCRE tests to check
    behaviour with different character tables. The digit specifies the tables as
    follows:</p>
<p class="Pp">
   0 the default ASCII tables, as distributed in
   pcre_chartables.c.dist
   1 a set of tables defining ISO 8859 characters</p>
<p class="Pp">In table 1, some characters whose codes are greater than 128 are
    identified as letters, digits, spaces, etc.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_the_POSIX_wrapper_API"><a class="permalink" href="#Using_the_POSIX_wrapper_API">Using
  the POSIX wrapper API</a></h2>
The <b>/P</b> modifier causes <b>pcretest</b> to call PCRE via the POSIX wrapper
  API rather than its native API. This supports only the 8-bit library. When
  <b>/P</b> is set, the following modifiers set options for the <b>regcomp()</b>
  function:
<p class="Pp">
   /i REG_ICASE
   /m REG_NEWLINE
   /N REG_NOSUB
   /s REG_DOTALL )
   /U REG_UNGREEDY ) These options are not part of
   /W REG_UCP ) the POSIX standard
   /8 REG_UTF8 )</p>
<p class="Pp">The <b>/+</b> modifier works as described above. All other
    modifiers are ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Locking_out_certain_modifiers"><a class="permalink" href="#Locking_out_certain_modifiers">Locking
  out certain modifiers</a></h2>
PCRE can be compiled with or without support for certain features such as
  UTF-8/16/32 or Unicode properties. Accordingly, the standard tests are split
  up into a number of different files that are selected for running depending on
  which features are available. When updating the tests, it is all too easy to
  put a new test into the wrong file by mistake; for example, to put a test that
  requires UTF support into a file that is used when it is not available. To
  help detect such mistakes as early as possible, there is a facility for
  locking out specific modifiers. If an input line for <b>pcretest</b> starts
  with the string &quot;&lt; forbid &quot; the following sequence of characters
  is taken as a list of forbidden modifiers. For example, in the test files that
  must not use UTF or Unicode property support, this line appears:
<p class="Pp">
   &lt; forbid 8W</p>
<p class="Pp">This locks out the /8 and /W modifiers. An immediate error is
    given if they are subsequently encountered. If the character string contains
    &lt; but not &gt;, all the multi-character modifiers that begin with &lt;
    are locked out. Otherwise, such modifiers must be explicitly listed, for
    example:</p>
<p class="Pp">
   &lt; forbid &lt;JS&gt;&lt;cr&gt;</p>
<p class="Pp">There must be a single space between &lt; and &quot;forbid&quot;
    for this feature to be recognised. If there is not, the line is interpreted
    either as a request to re-load a pre-compiled pattern (see &quot;SAVING AND
    RELOADING COMPILED PATTERNS&quot; below) or, if there is a another &lt;
    character, as a pattern that uses &lt; as its delimiter.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DATA_LINES"><a class="permalink" href="#DATA_LINES">DATA
  LINES</a></h1>
Before each data line is passed to <b>pcre[16|32]_exec()</b>, leading and
  trailing white space is removed, and it is then scanned for \ escapes. Some of
  these are pretty esoteric features, intended for checking out some of the more
  complicated features of PCRE. If you are just testing &quot;ordinary&quot;
  regular expressions, you probably don't need any of these. The following
  escapes are recognized:
<p class="Pp">
   \a alarm (BEL, \x07)
   \b backspace (\x08)
   \e escape (\x27)
   \f form feed (\x0c)
   \n newline (\x0a)
   \qdd set the PCRE_MATCH_LIMIT limit to dd
   (any number of digits)
   \r carriage return (\x0d)
   \t tab (\x09)
   \v vertical tab (\x0b)
   \nnn octal character (up to 3 octal digits); always
   a byte unless &gt; 255 in UTF-8 or 16-bit or 32-bit mode
   \o{dd...} octal character (any number of octal digits}
   \xhh hexadecimal byte (up to 2 hex digits)
   \x{hh...} hexadecimal character (any number of hex digits)
   \A pass the PCRE_ANCHORED option to <b>pcre[16|32]_exec()</b>
   or <b>pcre[16|32]_dfa_exec()</b>
   \B pass the PCRE_NOTBOL option to <b>pcre[16|32]_exec()</b>
   or <b>pcre[16|32]_dfa_exec()</b>
   \Cdd call pcre[16|32]_copy_substring() for substring dd
   after a successful match (number less than 32)
   \Cname call pcre[16|32]_copy_named_substring() for substring
   &quot;name&quot; after a successful match (name termin-
   ated by next non alphanumeric character)
   \C+ show the current captured substrings at callout
   time
   \C- do not supply a callout function
   \C!n return 1 instead of 0 when callout number n is
   reached
   \C!n!m return 1 instead of 0 when callout number n is
   reached for the nth time
   \C*n pass the number n (may be negative) as callout
   data; this is used as the callout return value
   \D use the <b>pcre[16|32]_dfa_exec()</b> match function
   \F only shortest match for <b>pcre[16|32]_dfa_exec()</b>
   \Gdd call pcre[16|32]_get_substring() for substring dd
   after a successful match (number less than 32)
   \Gname call pcre[16|32]_get_named_substring() for substring
   &quot;name&quot; after a successful match (name termin-
   ated by next non-alphanumeric character)
   \Jdd set up a JIT stack of dd kilobytes maximum (any
   number of digits)
   \L call pcre[16|32]_get_substringlist() after a
   successful match
   \M discover the minimum MATCH_LIMIT and
   MATCH_LIMIT_RECURSION settings
   \N pass the PCRE_NOTEMPTY option to <b>pcre[16|32]_exec()</b>
   or <b>pcre[16|32]_dfa_exec()</b>; if used twice, pass the
   PCRE_NOTEMPTY_ATSTART option
   \Odd set the size of the output vector passed to
   <b>pcre[16|32]_exec()</b> to dd (any number of digits)
   \P pass the PCRE_PARTIAL_SOFT option to <b>pcre[16|32]_exec()</b>
   or <b>pcre[16|32]_dfa_exec()</b>; if used twice, pass the
   PCRE_PARTIAL_HARD option
   \Qdd set the PCRE_MATCH_LIMIT_RECURSION limit to dd
   (any number of digits)
   \R pass the PCRE_DFA_RESTART option to <b>pcre[16|32]_dfa_exec()</b>
   \S output details of memory get/free calls during matching
   \Y pass the PCRE_NO_START_OPTIMIZE option to <b>pcre[16|32]_exec()</b>
   or <b>pcre[16|32]_dfa_exec()</b>
   \Z pass the PCRE_NOTEOL option to <b>pcre[16|32]_exec()</b>
   or <b>pcre[16|32]_dfa_exec()</b>
   \? pass the PCRE_NO_UTF[8|16|32]_CHECK option to
   <b>pcre[16|32]_exec()</b> or <b>pcre[16|32]_dfa_exec()</b>
   \&gt;dd start the match at offset dd (optional &quot;-&quot;; then
   any number of digits); this sets the <i>startoffset</i>
   argument for <b>pcre[16|32]_exec()</b> or <b>pcre[16|32]_dfa_exec()</b>
   \&lt;cr&gt; pass the PCRE_NEWLINE_CR option to <b>pcre[16|32]_exec()</b>
   or <b>pcre[16|32]_dfa_exec()</b>
   \&lt;lf&gt; pass the PCRE_NEWLINE_LF option to <b>pcre[16|32]_exec()</b>
   or <b>pcre[16|32]_dfa_exec()</b>
   \&lt;crlf&gt; pass the PCRE_NEWLINE_CRLF option to <b>pcre[16|32]_exec()</b>
   or <b>pcre[16|32]_dfa_exec()</b>
   \&lt;anycrlf&gt; pass the PCRE_NEWLINE_ANYCRLF option to
    <b>pcre[16|32]_exec()</b>
   or <b>pcre[16|32]_dfa_exec()</b>
   \&lt;any&gt; pass the PCRE_NEWLINE_ANY option to <b>pcre[16|32]_exec()</b>
   or <b>pcre[16|32]_dfa_exec()</b></p>
<p class="Pp">The use of \x{hh...} is not dependent on the use of the <b>/8</b>
    modifier on the pattern. It is recognized always. There may be any number of
    hexadecimal digits inside the braces; invalid values provoke error
  messages.</p>
<p class="Pp">Note that \xhh specifies one byte rather than one character in
    UTF-8 mode; this makes it possible to construct invalid UTF-8 sequences for
    testing purposes. On the other hand, \x{hh} is interpreted as a UTF-8
    character in UTF-8 mode, generating more than one byte if the value is
    greater than 127. When testing the 8-bit library not in UTF-8 mode, \x{hh}
    generates one byte for values less than 256, and causes an error for greater
    values.</p>
<p class="Pp">In UTF-16 mode, all 4-digit \x{hhhh} values are accepted. This
    makes it possible to construct invalid UTF-16 sequences for testing
    purposes.</p>
<p class="Pp">In UTF-32 mode, all 4- to 8-digit \x{...} values are accepted.
    This makes it possible to construct invalid UTF-32 sequences for testing
    purposes.</p>
<p class="Pp">The escapes that specify line ending sequences are literal
    strings, exactly as shown. No more than one newline setting should be
    present in any data line.</p>
<p class="Pp">A backslash followed by anything else just escapes the anything
    else. If the very last character is a backslash, it is ignored. This gives a
    way of passing an empty line as data, since a real empty line terminates the
    data input.</p>
<p class="Pp">The <b>\J</b> escape provides a way of setting the maximum stack
    size that is used by the just-in-time optimization code. It is ignored if
    JIT optimization is not being used. Providing a stack that is larger than
    the default 32K is necessary only for very complicated patterns.</p>
<p class="Pp">If \M is present, <b>pcretest</b> calls <b>pcre[16|32]_exec()</b>
    several times, with different values in the <i>match_limit</i> and
    <i>match_limit_recursion</i> fields of the <b>pcre[16|32]_extra</b> data
    structure, until it finds the minimum numbers for each parameter that allow
    <b>pcre[16|32]_exec()</b> to complete without error. Because this is testing
    a specific feature of the normal interpretive <b>pcre[16|32]_exec()</b>
    execution, the use of any JIT optimization that might have been set up by
    the <b>/S+</b> qualifier of <b>-s+</b> option is disabled.</p>
<p class="Pp">The <i>match_limit</i> number is a measure of the amount of
    backtracking that takes place, and checking it out can be instructive. For
    most simple matches, the number is quite small, but for patterns with very
    large numbers of matching possibilities, it can become large very quickly
    with increasing length of subject string. The <i>match_limit_recursion</i>
    number is a measure of how much stack (or, if PCRE is compiled with
    NO_RECURSE, how much heap) memory is needed to complete the match
  attempt.</p>
<p class="Pp">When \O is used, the value specified may be higher or lower than
    the size set by the <b>-O</b> command line option (or defaulted to 45); \O
    applies only to the call of <b>pcre[16|32]_exec()</b> for the line in which
    it appears.</p>
<p class="Pp">If the <b>/P</b> modifier was present on the pattern, causing the
    POSIX wrapper API to be used, the only option-setting sequences that have
    any effect are \B, \N, and \Z, causing REG_NOTBOL, REG_NOTEMPTY, and
    REG_NOTEOL, respectively, to be passed to <b>regexec()</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_ALTERNATIVE_MATCHING_FUNCTION"><a class="permalink" href="#THE_ALTERNATIVE_MATCHING_FUNCTION">THE
  ALTERNATIVE MATCHING FUNCTION</a></h1>
By default, <b>pcretest</b> uses the standard PCRE matching function,
  <b>pcre[16|32]_exec()</b> to match each data line. PCRE also supports an
  alternative matching function, <b>pcre[16|32]_dfa_test()</b>, which operates
  in a different way, and has some restrictions. The differences between the two
  functions are described in the <b>pcrematching</b> documentation.
<p class="Pp">If a data line contains the \D escape sequence, or if the command
    line contains the <b>-dfa</b> option, the alternative matching function is
    used. This function finds all possible matches at a given point. If,
    however, the \F escape sequence is present in the data line, it stops after
    the first match is found. This is always the shortest possible match.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEFAULT_OUTPUT_FROM_PCRETEST"><a class="permalink" href="#DEFAULT_OUTPUT_FROM_PCRETEST">DEFAULT
  OUTPUT FROM PCRETEST</a></h1>
This section describes the output when the normal matching function,
  <b>pcre[16|32]_exec()</b>, is being used.
<p class="Pp">When a match succeeds, <b>pcretest</b> outputs the list of
    captured substrings that <b>pcre[16|32]_exec()</b> returns, starting with
    number 0 for the string that matched the whole pattern. Otherwise, it
    outputs &quot;No match&quot; when the return is PCRE_ERROR_NOMATCH, and
    &quot;Partial match:&quot; followed by the partially matching substring when
    <b>pcre[16|32]_exec()</b> returns PCRE_ERROR_PARTIAL. (Note that this is the
    entire substring that was inspected during the partial match; it may include
    characters before the actual match start if a lookbehind assertion, \K, \b,
    or \B was involved.) For any other return, <b>pcretest</b> outputs the PCRE
    negative error number and a short descriptive phrase. If the error is a
    failed UTF string check, the offset of the start of the failing character
    and the reason code are also output, provided that the size of the output
    vector is at least two. Here is an example of an interactive <b>pcretest</b>
    run.</p>
<p class="Pp">
   $ pcretest
   PCRE version 8.13 2011-04-30</p>
<p class="Pp">
   re&gt; /^abc(\d+)/
   data&gt; abc123
   0: abc123
   1: 123
   data&gt; xyz
   No match</p>
<p class="Pp">Unset capturing substrings that are not followed by one that is
    set are not returned by <b>pcre[16|32]_exec()</b>, and are not shown by
    <b>pcretest</b>. In the following example, there are two capturing
    substrings, but when the first data line is matched, the second, unset
    substring is not shown. An &quot;internal&quot; unset substring is shown as
    &quot;&lt;unset&gt;&quot;, as for the second data line.</p>
<p class="Pp">
   re&gt; /(a)|(b)/
   data&gt; a
   0: a
   1: a
   data&gt; b
   0: b
   1: &lt;unset&gt;
   2: b</p>
<p class="Pp">If the strings contain any non-printing characters, they are
    output as \xhh escapes if the value is less than 256 and UTF mode is not
    set. Otherwise they are output as \x{hh...} escapes. See below for the
    definition of non-printing characters. If the pattern has the <b>/+</b>
    modifier, the output for substring 0 is followed by the the rest of the
    subject string, identified by &quot;0+&quot; like this:</p>
<p class="Pp">
   re&gt; /cat/+
   data&gt; cataract
   0: cat
   0+ aract</p>
<p class="Pp">If the pattern has the <b>/g</b> or <b>/G</b> modifier, the
    results of successive matching attempts are output in sequence, like
  this:</p>
<p class="Pp">
   re&gt; /\Bi(\w\w)/g
   data&gt; Mississippi
   0: iss
   1: ss
   0: iss
   1: ss
   0: ipp
   1: pp</p>
<p class="Pp">&quot;No match&quot; is output only if the first match attempt
    fails. Here is an example of a failure message (the offset 4 that is
    specified by \&gt;4 is past the end of the subject string):</p>
<p class="Pp">
   re&gt; /xyz/
   data&gt; xyz\&gt;4
   Error -24 (bad offset value)</p>
<p class="Pp">If any of the sequences <b>\C</b>, <b>\G</b>, or <b>\L</b> are
    present in a data line that is successfully matched, the substrings
    extracted by the convenience functions are output with C, G, or L after the
    string number instead of a colon. This is in addition to the normal full
    list. The string length (that is, the return from the extraction function)
    is given in parentheses after each string for <b>\C</b> and <b>\G</b>.</p>
<p class="Pp">Note that whereas patterns can be continued over several lines (a
    plain &quot;&gt;&quot; prompt is used for continuations), data lines may
    not. However newlines can be included in data by means of the \n escape (or
    \r, \r\n, etc., depending on the newline sequence setting).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OUTPUT_FROM_THE_ALTERNATIVE_MATCHING_FUNCTION"><a class="permalink" href="#OUTPUT_FROM_THE_ALTERNATIVE_MATCHING_FUNCTION">OUTPUT
  FROM THE ALTERNATIVE MATCHING FUNCTION</a></h1>
When the alternative matching function, <b>pcre[16|32]_dfa_exec()</b>, is used
  (by means of the \D escape sequence or the <b>-dfa</b> command line option),
  the output consists of a list of all the matches that start at the first point
  in the subject where there is at least one match. For example:
<p class="Pp">
   re&gt; /(tang|tangerine|tan)/
   data&gt; yellow tangerine\D
   0: tangerine
   1: tang
   2: tan</p>
<p class="Pp">(Using the normal matching function on this data finds only
    &quot;tang&quot;.) The longest matching string is always given first (and
    numbered zero). After a PCRE_ERROR_PARTIAL return, the output is
    &quot;Partial match:&quot;, followed by the partially matching substring.
    (Note that this is the entire substring that was inspected during the
    partial match; it may include characters before the actual match start if a
    lookbehind assertion, \K, \b, or \B was involved.)</p>
<p class="Pp">If <b>/g</b> is present on the pattern, the search for further
    matches resumes at the end of the longest match. For example:</p>
<p class="Pp">
   re&gt; /(tang|tangerine|tan)/g
   data&gt; yellow tangerine and tangy sultana\D
   0: tangerine
   1: tang
   2: tan
   0: tang
   1: tan
   0: tan</p>
<p class="Pp">Since the matching function does not support substring capture,
    the escape sequences that are concerned with captured substrings are not
    relevant.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RESTARTING_AFTER_A_PARTIAL_MATCH"><a class="permalink" href="#RESTARTING_AFTER_A_PARTIAL_MATCH">RESTARTING
  AFTER A PARTIAL MATCH</a></h1>
When the alternative matching function has given the PCRE_ERROR_PARTIAL return,
  indicating that the subject partially matched the pattern, you can restart the
  match with additional subject data by means of the \R escape sequence. For
  example:
<p class="Pp">
   re&gt; /^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$/
   data&gt; 23ja\P\D
   Partial match: 23ja
   data&gt; n05\R\D
   0: n05</p>
<p class="Pp">For further information about partial matching, see the
    <b>pcrepartial</b> documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CALLOUTS"><a class="permalink" href="#CALLOUTS">CALLOUTS</a></h1>
If the pattern contains any callout requests, <b>pcretest</b>'s callout function
  is called during matching. This works with both matching functions. By
  default, the called function displays the callout number, the start and
  current positions in the text at the callout time, and the next pattern item
  to be tested. For example:
<p class="Pp">
   ---&gt;pqrabcdef
   0 ^ ^ \d</p>
<p class="Pp">This output indicates that callout number 0 occurred for a match
    attempt starting at the fourth character of the subject string, when the
    pointer was at the seventh character of the data, and when the next pattern
    item was \d. Just one circumflex is output if the start and current
    positions are the same.</p>
<p class="Pp">Callouts numbered 255 are assumed to be automatic callouts,
    inserted as a result of the <b>/C</b> pattern modifier. In this case,
    instead of showing the callout number, the offset in the pattern, preceded
    by a plus, is output. For example:</p>
<p class="Pp">
   re&gt; /\d?[A-E]\*/C
   data&gt; E*
   ---&gt;E*
   +0 ^ \d?
   +3 ^ [A-E]
   +8 ^^ \*
   +10 ^ ^
   0: E*</p>
<p class="Pp">If a pattern contains (*MARK) items, an additional line is output
    whenever a change of latest mark is passed to the callout function. For
    example:</p>
<p class="Pp">
   re&gt; /a(*MARK:X)bc/C
   data&gt; abc
   ---&gt;abc
   +0 ^ a
   +1 ^^ (*MARK:X)
   +10 ^^ b
   Latest Mark: X
   +11 ^ ^ c
   +12 ^ ^
   0: abc</p>
<p class="Pp">The mark changes between matching &quot;a&quot; and &quot;b&quot;,
    but stays the same for the rest of the match, so nothing more is output. If,
    as a result of backtracking, the mark reverts to being unset, the text
    &quot;&lt;unset&gt;&quot; is output.</p>
<p class="Pp">The callout function in <b>pcretest</b> returns zero (carry on
    matching) by default, but you can use a \C item in a data line (as described
    above) to change this and other parameters of the callout.</p>
<p class="Pp">Inserting callouts can be helpful when using <b>pcretest</b> to
    check complicated regular expressions. For further information about
    callouts, see the <b>pcrecallout</b> documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NON-PRINTING_CHARACTERS"><a class="permalink" href="#NON-PRINTING_CHARACTERS">NON-PRINTING
  CHARACTERS</a></h1>
When <b>pcretest</b> is outputting text in the compiled version of a pattern,
  bytes other than 32-126 are always treated as non-printing characters are are
  therefore shown as hex escapes.
<p class="Pp">When <b>pcretest</b> is outputting text that is a matched part of
    a subject string, it behaves in the same way, unless a different locale has
    been set for the pattern (using the <b>/L</b> modifier). In this case, the
    <b>isprint()</b> function to distinguish printing and non-printing
    characters.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SAVING_AND_RELOADING_COMPILED_PATTERNS"><a class="permalink" href="#SAVING_AND_RELOADING_COMPILED_PATTERNS">SAVING
  AND RELOADING COMPILED PATTERNS</a></h1>
The facilities described in this section are not available when the POSIX
  interface to PCRE is being used, that is, when the <b>/P</b> pattern modifier
  is specified.
<p class="Pp">When the POSIX interface is not in use, you can cause
    <b>pcretest</b> to write a compiled pattern to a file, by following the
    modifiers with &gt; and a file name. For example:</p>
<p class="Pp">
   /pattern/im &gt;/some/file</p>
<p class="Pp">See the <b>pcreprecompile</b> documentation for a discussion about
    saving and re-using compiled patterns. Note that if the pattern was
    successfully studied with JIT optimization, the JIT data cannot be
  saved.</p>
<p class="Pp">The data that is written is binary. The first eight bytes are the
    length of the compiled pattern data followed by the length of the optional
    study data, each written as four bytes in big-endian order (most significant
    byte first). If there is no study data (either the pattern was not studied,
    or studying did not return any data), the second length is zero. The lengths
    are followed by an exact copy of the compiled pattern. If there is
    additional study data, this (excluding any JIT data) follows immediately
    after the compiled pattern. After writing the file, <b>pcretest</b> expects
    to read a new pattern.</p>
<p class="Pp">A saved pattern can be reloaded into <b>pcretest</b> by specifying
    &lt; and a file name instead of a pattern. There must be no space between
    &lt; and the file name, which must not contain a &lt; character, as
    otherwise <b>pcretest</b> will interpret the line as a pattern delimited by
    &lt; characters. For example:</p>
<p class="Pp">
   re&gt; &lt;/some/file
   Compiled pattern loaded from /some/file
   No study data</p>
<p class="Pp">If the pattern was previously studied with the JIT optimization,
    the JIT information cannot be saved and restored, and so is lost. When the
    pattern has been loaded, <b>pcretest</b> proceeds to read data lines in the
    usual way.</p>
<p class="Pp">You can copy a file written by <b>pcretest</b> to a different host
    and reload it there, even if the new host has opposite endianness to the one
    on which the pattern was compiled. For example, you can compile on an i86
    machine and run on a SPARC machine. When a pattern is reloaded on a host
    with different endianness, the confirmation message is changed to:</p>
<p class="Pp">
   Compiled pattern (byte-inverted) loaded from /some/file</p>
<p class="Pp">The test suite contains some saved pre-compiled patterns with
    different endianness. These are reloaded using &quot;&lt;!&quot; instead of
    just &quot;&lt;&quot;. This suppresses the &quot;(byte-inverted)&quot; text
    so that the output is the same on all hosts. It also forces debugging output
    once the pattern has been reloaded.</p>
<p class="Pp">File names for saving and reloading can be absolute or relative,
    but note that the shell facility of expanding a file name that starts with a
    tilde (~) is not available.</p>
<p class="Pp">The ability to save and reload files in <b>pcretest</b> is
    intended for testing and experimentation. It is not intended for production
    use because only a single pattern can be written to a file. Furthermore,
    there is no facility for supplying custom character tables for use with a
    reloaded pattern. If the original pattern was compiled with custom tables,
    an attempt to match a subject string using a reloaded pattern is likely to
    cause <b>pcretest</b> to crash. Finally, if you attempt to load a file that
    is not in the correct format, the result is undefined.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>pcre</b>(3), <b>pcre16</b>(3), <b>pcre32</b>(3), <b>pcreapi</b>(3),
  <b>pcrecallout</b>(3), <b>pcrejit</b>, <b>pcrematching</b>(3),
  <b>pcrepartial</b>(d), <b>pcrepattern</b>(3), <b>pcreprecompile</b>(3).
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<pre>
Philip Hazel
University Computing Service
Cambridge CB2 3QH, England.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="REVISION"><a class="permalink" href="#REVISION">REVISION</a></h1>
<pre>
Last updated: 10 February 2020
Copyright (c) 1997-2020 University of Cambridge.
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">10 February 2020</td>
    <td class="foot-os">PCRE 8.44</td>
  </tr>
</table>

	</div>
	<div class=footer>
		<p>Copyright 2020 Scott Court</p>
	</div>
	</div>
</body>
