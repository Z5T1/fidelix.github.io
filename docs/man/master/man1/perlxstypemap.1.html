
<!DOCTYPE HTML>
<head>
	<title>/usr/share/man/man1/perlxstypemap.1</title>		<link rel='stylesheet' href='/mandoc.css' />
	<link rel='stylesheet' href='/style.css' />
</head>
<body>
	<div class=contents>
	<div class=header>
	<h1>The Fidelix Linux Distribution</h1>
	<h2>Simple, Stable, and Secure</h2>
	</div>
<div class=menubar>
	<ul>
		<li><a href=/>News</a></li>
		<li><a href=/about.html>About</a></li>
		<div class=dropdown>
			<li><a href=/download>Download</a></li>
			<ul class=dropdown-content>
				<li><a href=/download/>Latest Downloads</a></li>
				<li><a href=/download/all.html>All Downloads</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Documentation</a></li>
			<ul class=dropdown-content>
				<li><a href=/handbook/>Handbook</a></li>
				<li><a href=/man/>Manual Pages</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Development</a></li>
			<ul class=dropdown-content>
				<li><a href=https://github.com/Z5T1/fidelix>GitHub</a></li>
			</ul>
		</div>
	</ul>
</div>


	<div class=body><table class="head">
  <tr>
    <td class="head-ltitle">PERLXSTYPEMAP(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLXSTYPEMAP(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlxstypemap - Perl XS C/Perl type mapping
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The more you think about interfacing between two languages, the more you'll
  realize that the majority of programmer effort has to go into converting
  between the data structures that are native to either of the languages
  involved. This trumps other matter such as differing calling conventions
  because the problem space is so much greater. There are simply more ways to
  shove data into memory than there are ways to implement a function call.
<p class="Pp">Perl XS' attempt at a solution to this is the concept of typemaps.
    At an abstract level, a Perl XS typemap is nothing but a recipe for
    converting from a certain Perl data structure to a certain C data structure
    and vice versa. Since there can be C types that are sufficiently similar to
    one another to warrant converting with the same logic, XS typemaps are
    represented by a unique identifier, henceforth called an <b>XS type</b> in
    this document. You can then tell the XS compiler that multiple C types are
    to be mapped with the same XS typemap.</p>
<p class="Pp">In your XS code, when you define an argument with a C type or when
    you are using a <span class="Li">&quot;CODE:&quot;</span> and an
    <span class="Li">&quot;OUTPUT:&quot;</span> section together with a C return
    type of your XSUB, it'll be the typemapping mechanism that makes this
  easy.</p>
<section class="Ss">
<h2 class="Ss" id="Anatomy_of_a_typemap"><a class="permalink" href="#Anatomy_of_a_typemap">Anatomy
  of a typemap</a></h2>
In more practical terms, the typemap is a collection of code fragments which are
  used by the <b>xsubpp</b> compiler to map C function parameters and values to
  Perl values. The typemap file may consist of three sections labelled
  <span class="Li">&quot;TYPEMAP&quot;</span>,
  <span class="Li">&quot;INPUT&quot;</span>, and
  <span class="Li">&quot;OUTPUT&quot;</span>. An unlabelled initial section is
  assumed to be a <span class="Li">&quot;TYPEMAP&quot;</span> section. The INPUT
  section tells the compiler how to translate Perl values into variables of
  certain C types. The OUTPUT section tells the compiler how to translate the
  values from certain C types into values Perl can understand. The TYPEMAP
  section tells the compiler which of the INPUT and OUTPUT code fragments should
  be used to map a given C type to a Perl value. The section labels
  <span class="Li">&quot;TYPEMAP&quot;</span>,
  <span class="Li">&quot;INPUT&quot;</span>, or
  <span class="Li">&quot;OUTPUT&quot;</span> must begin in the first column on a
  line by themselves, and must be in uppercase.
<p class="Pp">Each type of section can appear an arbitrary number of times and
    does not have to appear at all. For example, a typemap may commonly lack
    <span class="Li">&quot;INPUT&quot;</span> and
    <span class="Li">&quot;OUTPUT&quot;</span> sections if all it needs to do is
    associate additional C types with core XS types like T_PTROBJ. Lines that
    start with a hash <span class="Li">&quot;#&quot;</span> are considered
    comments and ignored in the <span class="Li">&quot;TYPEMAP&quot;</span>
    section, but are considered significant in
    <span class="Li">&quot;INPUT&quot;</span> and
    <span class="Li">&quot;OUTPUT&quot;</span>. Blank lines are generally
    ignored.</p>
<p class="Pp">Traditionally, typemaps needed to be written to a separate file,
    conventionally called <span class="Li">&quot;typemap&quot;</span> in a CPAN
    distribution. With ExtUtils::ParseXS (the XS compiler) version 3.12 or
    better which comes with perl 5.16, typemaps can also be embedded directly
    into XS code using a HERE-doc like syntax:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  TYPEMAP: &lt;&lt;HERE
  ...
  HERE
</pre>
<p class="Pp">where <span class="Li">&quot;HERE&quot;</span> can be replaced by
    other identifiers like with normal Perl HERE-docs. All details below about
    the typemap textual format remain valid.</p>
<p class="Pp">The <span class="Li">&quot;TYPEMAP&quot;</span> section should
    contain one pair of C type and XS type per line as follows. An example from
    the core typemap file:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  TYPEMAP
  # all variants of char* is handled by the T_PV typemap
  char *          T_PV
  const char *    T_PV
  unsigned char * T_PV
  ...
</pre>
<p class="Pp">The <span class="Li">&quot;INPUT&quot;</span> and
    <span class="Li">&quot;OUTPUT&quot;</span> sections have identical formats,
    that is, each unindented line starts a new in- or output map respectively. A
    new in- or output map must start with the name of the XS type to map on a
    line by itself, followed by the code that implements it indented on the
    following lines. Example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  INPUT
  T_PV
    $var = ($type)SvPV_nolen($arg)
  T_PTR
    $var = INT2PTR($type,SvIV($arg))
</pre>
<p class="Pp">We'll get to the meaning of those Perlish-looking variables in a
    little bit.</p>
<p class="Pp">Finally, here's an example of the full typemap file for mapping C
    strings of the <span class="Li">&quot;char *&quot;</span> type to Perl
    scalars/strings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  TYPEMAP
  char *  T_PV

  INPUT
  T_PV
    $var = ($type)SvPV_nolen($arg)

  OUTPUT
  T_PV
    sv_setpv((SV*)$arg, $var);
</pre>
<p class="Pp">Here's a more complicated example: suppose that you wanted
    <span class="Li">&quot;struct netconfig&quot;</span> to be blessed into the
    class <span class="Li">&quot;Net::Config&quot;</span>. One way to do this is
    to use underscores (_) to separate package names, as follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  typedef struct netconfig * Net_Config;
</pre>
<p class="Pp">And then provide a typemap entry
    <span class="Li">&quot;T_PTROBJ_SPECIAL&quot;</span> that maps underscores
    to double-colons (::), and declare
    <span class="Li">&quot;Net_Config&quot;</span> to be of that type:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  TYPEMAP
  Net_Config      T_PTROBJ_SPECIAL

  INPUT
  T_PTROBJ_SPECIAL
    if (sv_derived_from($arg, \&quot;${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\&quot;)){
      IV tmp = SvIV((SV*)SvRV($arg));
      $var = INT2PTR($type, tmp);
    }
    else
      croak(\&quot;$var is not of type ${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\&quot;)

  OUTPUT
  T_PTROBJ_SPECIAL
    sv_setref_pv($arg, \&quot;${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\&quot;,
                 (void*)$var);
</pre>
<p class="Pp">The INPUT and OUTPUT sections substitute underscores for
    double-colons on the fly, giving the desired effect. This example
    demonstrates some of the power and versatility of the typemap facility.</p>
<p class="Pp">The <span class="Li">&quot;INT2PTR&quot;</span> macro (defined in
    perl.h) casts an integer to a pointer of a given type, taking care of the
    possible different size of integers and pointers. There are also
    <span class="Li">&quot;PTR2IV&quot;</span>,
    <span class="Li">&quot;PTR2UV&quot;</span>,
    <span class="Li">&quot;PTR2NV&quot;</span> macros, to map the other way,
    which may be useful in OUTPUT sections.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Role_of_the_typemap_File_in_Your_Distribution"><a class="permalink" href="#The_Role_of_the_typemap_File_in_Your_Distribution">The
  Role of the typemap File in Your Distribution</a></h2>
The default typemap in the <i>lib/ExtUtils</i> directory of the Perl source
  contains many useful types which can be used by Perl extensions. Some
  extensions define additional typemaps which they keep in their own directory.
  These additional typemaps may reference INPUT and OUTPUT maps in the main
  typemap. The <b>xsubpp</b> compiler will allow the extension's own typemap to
  override any mappings which are in the default typemap. Instead of using an
  additional <i>typemap</i> file, typemaps may be embedded verbatim in XS with a
  heredoc-like syntax. See the documentation on the
  <span class="Li">&quot;TYPEMAP:&quot;</span> XS keyword.
<p class="Pp">For CPAN distributions, you can assume that the XS types defined
    by the perl core are already available. Additionally, the core typemap has
    default XS types for a large number of C types. For example, if you simply
    return a <span class="Li">&quot;char *&quot;</span> from your XSUB, the core
    typemap will have this C type associated with the T_PV XS type. That means
    your C string will be copied into the PV (pointer value) slot of a new
    scalar that will be returned from your XSUB to Perl.</p>
<p class="Pp">If you're developing a CPAN distribution using XS, you may add
    your own file called <i>typemap</i> to the distribution. That file may
    contain typemaps that either map types that are specific to your code or
    that override the core typemap file's mappings for common C types.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Sharing_typemaps_Between__s-1CPAN_s0_Distributions"><a class="permalink" href="#Sharing_typemaps_Between__s-1CPAN_s0_Distributions">Sharing
  typemaps Between CPAN Distributions</a></h2>
Starting with ExtUtils::ParseXS version 3.13_01 (comes with perl 5.16 and
  better), it is rather easy to share typemap code between multiple CPAN
  distributions. The general idea is to share it as a module that offers a
  certain API and have the dependent modules declare that as a built-time
  requirement and import the typemap into the XS. An example of such a
  typemap-sharing module on CPAN is
  <span class="Li">&quot;ExtUtils::Typemaps::Basic&quot;</span>. Two steps to
  getting that module's typemaps available in your code:
<ul class="Bl-bullet">
  <li>Declare <span class="Li">&quot;ExtUtils::Typemaps::Basic&quot;</span> as a
      build-time dependency in <span class="Li">&quot;Makefile.PL&quot;</span>
      (use <span class="Li">&quot;BUILD_REQUIRES&quot;</span>), or in your
      <span class="Li">&quot;Build.PL&quot;</span> (use
      <span class="Li">&quot;build_requires&quot;</span>).</li>
  <li>Include the following line in the XS section of your XS file: (don't break
      the line)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  INCLUDE_COMMAND: $^X -MExtUtils::Typemaps::Cmd
                   -e &quot;print embeddable_typemap(q{Basic})&quot;
    </pre>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_typemap_Entries"><a class="permalink" href="#Writing_typemap_Entries">Writing
  typemap Entries</a></h2>
Each INPUT or OUTPUT typemap entry is a double-quoted Perl string that will be
  evaluated in the presence of certain variables to get the final C code for
  mapping a certain C type.
<p class="Pp">This means that you can embed Perl code in your typemap (C) code
    using constructs such as <span class="Li">&quot;${ perl code that evaluates
    to scalar reference here }&quot;</span>. A common use case is to generate
    error messages that refer to the true function name even when using the
    ALIAS XS feature:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  ${ $ALIAS ? \q[GvNAME(CvGV(cv))] : \qq[\&quot;$pname\&quot;] }
</pre>
<p class="Pp">For many typemap examples, refer to the core typemap file that can
    be found in the perl source tree at <i>lib/ExtUtils/typemap</i>.</p>
<p class="Pp">The Perl variables that are available for interpolation into
    typemaps are the following:</p>
<ul class="Bl-bullet">
  <li><i></i><i>$var</i><i></i> - the name of the input or output variable, eg.
      RETVAL for return values.</li>
  <li><i></i><i>$type</i><i></i> - the raw C type of the parameter, any
      <span class="Li">&quot;:&quot;</span> replaced with
      <span class="Li">&quot;_&quot;</span>. e.g. for a type of
      <span class="Li">&quot;Foo::Bar&quot;</span>, <i></i><i>$type</i><i></i>
      is <span class="Li">&quot;Foo__Bar&quot;</span></li>
  <li><i></i><i>$ntype</i><i></i> - the supplied type with
      <span class="Li">&quot;*&quot;</span> replaced with
      <span class="Li">&quot;Ptr&quot;</span>. e.g. for a type of
      <span class="Li">&quot;Foo*&quot;</span>, <i></i><i>$ntype</i><i></i> is
      <span class="Li">&quot;FooPtr&quot;</span></li>
  <li><i></i><i>$arg</i><i></i> - the stack entry, that the parameter is input
      from or output to, e.g. <span class="Li">ST(0)</span></li>
  <li><i></i><i>$argoff</i><i></i> - the argument stack offset of the argument.
      ie. 0 for the first argument, etc.</li>
  <li><i></i><i>$pname</i><i></i> - the full name of the XSUB, with including
      the <span class="Li">&quot;PACKAGE&quot;</span> name, with any
      <span class="Li">&quot;PREFIX&quot;</span> stripped. This is the non-ALIAS
      name.</li>
  <li><i></i><i>$Package</i><i></i> - the package specified by the most recent
      <span class="Li">&quot;PACKAGE&quot;</span> keyword.</li>
  <li><i></i><i>$ALIAS</i><i></i> - non-zero if the current XSUB has any aliases
      declared with <span class="Li">&quot;ALIAS&quot;</span>.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Full_Listing_of_Core_Typemaps"><a class="permalink" href="#Full_Listing_of_Core_Typemaps">Full
  Listing of Core Typemaps</a></h2>
Each C type is represented by an entry in the typemap file that is responsible
  for converting perl variables (SV, AV, HV, CV, etc.) to and from that type.
  The following sections list all XS types that come with perl by default.
<dl class="Bl-tag">
  <dt>T_SV</dt>
  <dd>This simply passes the C representation of the Perl variable (an SV*) in
      and out of the XS layer. This can be used if the C code wants to deal
      directly with the Perl variable.</dd>
  <dt>T_SVREF</dt>
  <dd>Used to pass in and return a reference to an SV.
    <p class="Pp">Note that this typemap does not decrement the reference count
        when returning the reference to an SV*. See also:
      T_SVREF_REFCOUNT_FIXED</p>
  </dd>
  <dt>T_SVREF_FIXED</dt>
  <dd>Used to pass in and return a reference to an SV. This is a fixed variant
      of T_SVREF that decrements the refcount appropriately when returning a
      reference to an SV*. Introduced in perl 5.15.4.</dd>
  <dt>T_AVREF</dt>
  <dd>From the perl level this is a reference to a perl array. From the C level
      this is a pointer to an AV.
    <p class="Pp">Note that this typemap does not decrement the reference count
        when returning an AV*. See also: T_AVREF_REFCOUNT_FIXED</p>
  </dd>
  <dt>T_AVREF_REFCOUNT_FIXED</dt>
  <dd>From the perl level this is a reference to a perl array. From the C level
      this is a pointer to an AV. This is a fixed variant of T_AVREF that
      decrements the refcount appropriately when returning an AV*. Introduced in
      perl 5.15.4.</dd>
  <dt>T_HVREF</dt>
  <dd>From the perl level this is a reference to a perl hash. From the C level
      this is a pointer to an HV.
    <p class="Pp">Note that this typemap does not decrement the reference count
        when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED</p>
  </dd>
  <dt>T_HVREF_REFCOUNT_FIXED</dt>
  <dd>From the perl level this is a reference to a perl hash. From the C level
      this is a pointer to an HV. This is a fixed variant of T_HVREF that
      decrements the refcount appropriately when returning an HV*. Introduced in
      perl 5.15.4.</dd>
  <dt>T_CVREF</dt>
  <dd>From the perl level this is a reference to a perl subroutine (e.g.
      <span class="Li">$sub</span> = sub { 1 };). From the C level this is a
      pointer to a CV.
    <p class="Pp">Note that this typemap does not decrement the reference count
        when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED</p>
  </dd>
  <dt>T_CVREF_REFCOUNT_FIXED</dt>
  <dd>From the perl level this is a reference to a perl subroutine (e.g.
      <span class="Li">$sub</span> = sub { 1 };). From the C level this is a
      pointer to a CV.
    <p class="Pp">This is a fixed variant of T_HVREF that decrements the
        refcount appropriately when returning an HV*. Introduced in perl
      5.15.4.</p>
  </dd>
  <dt>T_SYSRET</dt>
  <dd>The T_SYSRET typemap is used to process return values from system calls.
      It is only meaningful when passing values from C to perl (there is no
      concept of passing a system return value from Perl to C).
    <p class="Pp">System calls return -1 on error (setting ERRNO with the
        reason) and (usually) 0 on success. If the return value is -1 this
        typemap returns <span class="Li">&quot;undef&quot;</span>. If the return
        value is not -1, this typemap translates a 0 (perl false) to &quot;0 but
        true&quot; (which is perl true) or returns the value itself, to indicate
        that the command succeeded.</p>
    <p class="Pp">The POSIX module makes extensive use of this type.</p>
  </dd>
  <dt>T_UV</dt>
  <dd>An unsigned integer.</dd>
  <dt>T_IV</dt>
  <dd>A signed integer. This is cast to the required integer type when passed to
      C and converted to an IV when passed back to Perl.</dd>
  <dt>T_INT</dt>
  <dd>A signed integer. This typemap converts the Perl value to a native integer
      type (the <span class="Li">&quot;int&quot;</span> type on the current
      platform). When returning the value to perl it is processed in the same
      way as for T_IV.
    <p class="Pp">Its behaviour is identical to using an
        <span class="Li">&quot;int&quot;</span> type in XS with T_IV.</p>
  </dd>
  <dt>T_ENUM</dt>
  <dd>An enum value. Used to transfer an enum component from C. There is no
      reason to pass an enum value to C since it is stored as an IV inside
    perl.</dd>
  <dt>T_BOOL</dt>
  <dd>A boolean type. This can be used to pass true and false values to and from
      C.</dd>
  <dt>T_U_INT</dt>
  <dd>This is for unsigned integers. It is equivalent to using T_UV but
      explicitly casts the variable to type <span class="Li">&quot;unsigned
      int&quot;</span>. The default type for <span class="Li">&quot;unsigned
      int&quot;</span> is T_UV.</dd>
  <dt>T_SHORT</dt>
  <dd>Short integers. This is equivalent to T_IV but explicitly casts the return
      to type <span class="Li">&quot;short&quot;</span>. The default typemap for
      <span class="Li">&quot;short&quot;</span> is T_IV.</dd>
  <dt>T_U_SHORT</dt>
  <dd>Unsigned short integers. This is equivalent to T_UV but explicitly casts
      the return to type <span class="Li">&quot;unsigned short&quot;</span>. The
      default typemap for <span class="Li">&quot;unsigned short&quot;</span> is
      T_UV.
    <p class="Pp">T_U_SHORT is used for type
        <span class="Li">&quot;U16&quot;</span> in the standard typemap.</p>
  </dd>
  <dt>T_LONG</dt>
  <dd>Long integers. This is equivalent to T_IV but explicitly casts the return
      to type <span class="Li">&quot;long&quot;</span>. The default typemap for
      <span class="Li">&quot;long&quot;</span> is T_IV.</dd>
  <dt>T_U_LONG</dt>
  <dd>Unsigned long integers. This is equivalent to T_UV but explicitly casts
      the return to type <span class="Li">&quot;unsigned long&quot;</span>. The
      default typemap for <span class="Li">&quot;unsigned long&quot;</span> is
      T_UV.
    <p class="Pp">T_U_LONG is used for type
        <span class="Li">&quot;U32&quot;</span> in the standard typemap.</p>
  </dd>
  <dt>T_CHAR</dt>
  <dd>Single 8-bit characters.</dd>
  <dt>T_U_CHAR</dt>
  <dd>An unsigned byte.</dd>
  <dt>T_FLOAT</dt>
  <dd>A floating point number. This typemap guarantees to return a variable cast
      to a <span class="Li">&quot;float&quot;</span>.</dd>
  <dt>T_NV</dt>
  <dd>A Perl floating point number. Similar to T_IV and T_UV in that the return
      type is cast to the requested numeric type rather than to a specific
    type.</dd>
  <dt>T_DOUBLE</dt>
  <dd>A double precision floating point number. This typemap guarantees to
      return a variable cast to a
    <span class="Li">&quot;double&quot;</span>.</dd>
  <dt>T_PV</dt>
  <dd>A string (char *).</dd>
  <dt>T_PTR</dt>
  <dd>A memory address (pointer). Typically associated with a
      <span class="Li">&quot;void *&quot;</span> type.</dd>
  <dt>T_PTRREF</dt>
  <dd>Similar to T_PTR except that the pointer is stored in a scalar and the
      reference to that scalar is returned to the caller. This can be used to
      hide the actual pointer value from the programmer since it is usually not
      required directly from within perl.
    <p class="Pp">The typemap checks that a scalar reference is passed from perl
        to XS.</p>
  </dd>
  <dt>T_PTROBJ</dt>
  <dd>Similar to T_PTRREF except that the reference is blessed into a class.
      This allows the pointer to be used as an object. Most commonly used to
      deal with C structs. The typemap checks that the perl object passed into
      the XS routine is of the correct class (or part of a subclass).
    <p class="Pp">The pointer is blessed into a class that is derived from the
        name of type of the pointer but with all '*' in the name replaced with
        'Ptr'.</p>
    <p class="Pp">For <span class="Li">&quot;DESTROY&quot;</span> XSUBs only, a
        T_PTROBJ is optimized to a T_PTRREF. This means the class check is
        skipped.</p>
  </dd>
  <dt>T_REF_IV_REF</dt>
  <dd>NOT YET</dd>
  <dt>T_REF_IV_PTR</dt>
  <dd>Similar to T_PTROBJ in that the pointer is blessed into a scalar object.
      The difference is that when the object is passed back into XS it must be
      of the correct type (inheritance is not supported) while T_PTROBJ supports
      inheritance.
    <p class="Pp">The pointer is blessed into a class that is derived from the
        name of type of the pointer but with all '*' in the name replaced with
        'Ptr'.</p>
    <p class="Pp">For <span class="Li">&quot;DESTROY&quot;</span> XSUBs only, a
        T_REF_IV_PTR is optimized to a T_PTRREF. This means the class check is
        skipped.</p>
  </dd>
  <dt>T_PTRDESC</dt>
  <dd>NOT YET</dd>
  <dt>T_REFREF</dt>
  <dd>Similar to T_PTRREF, except the pointer stored in the referenced scalar is
      dereferenced and copied to the output variable. This means that T_REFREF
      is to T_PTRREF as T_OPAQUE is to T_OPAQUEPTR. All clear?
    <p class="Pp">Only the INPUT part of this is implemented (Perl to XSUB) and
        there are no known users in core or on CPAN.</p>
  </dd>
  <dt>T_REFOBJ</dt>
  <dd>Like T_REFREF, except it does strict type checking (inheritance is not
      supported).
    <p class="Pp">For <span class="Li">&quot;DESTROY&quot;</span> XSUBs only, a
        T_REFOBJ is optimized to a T_REFREF. This means the class check is
        skipped.</p>
  </dd>
  <dt>T_OPAQUEPTR</dt>
  <dd>This can be used to store bytes in the string component of the SV. Here
      the representation of the data is irrelevant to perl and the bytes
      themselves are just stored in the SV. It is assumed that the C variable is
      a pointer (the bytes are copied from that memory location). If the pointer
      is pointing to something that is represented by 8 bytes then those 8 bytes
      are stored in the SV (and <b>length()</b> will report a value of 8). This
      entry is similar to T_OPAQUE.
    <p class="Pp">In principle the <b>unpack()</b> command can be used to
        convert the bytes back to a number (if the underlying type is known to
        be a number).</p>
    <p class="Pp">This entry can be used to store a C structure (the number of
        bytes to be copied is calculated using the C
        <span class="Li">&quot;sizeof&quot;</span> function) and can be used as
        an alternative to T_PTRREF without having to worry about a memory leak
        (since Perl will clean up the SV).</p>
  </dd>
  <dt>T_OPAQUE</dt>
  <dd>This can be used to store data from non-pointer types in the string part
      of an SV. It is similar to T_OPAQUEPTR except that the typemap retrieves
      the pointer directly rather than assuming it is being supplied. For
      example, if an integer is imported into Perl using T_OPAQUE rather than
      T_IV the underlying bytes representing the integer will be stored in the
      SV but the actual integer value will not be available. i.e. The data is
      opaque to perl.
    <p class="Pp">The data may be retrieved using the
        <span class="Li">&quot;unpack&quot;</span> function if the underlying
        type of the byte stream is known.</p>
    <p class="Pp">T_OPAQUE supports input and output of simple types.
        T_OPAQUEPTR can be used to pass these bytes back into C if a pointer is
        acceptable.</p>
  </dd>
  <dt>Implicit array</dt>
  <dd>xsubpp supports a special syntax for returning packed C arrays to perl. If
      the XS return type is given as
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  array(type, nelem)
    </pre>
    <p class="Pp">xsubpp will copy the contents of <span class="Li">&quot;nelem
        * sizeof(type)&quot;</span> bytes from RETVAL to an SV and push it onto
        the stack. This is only really useful if the number of items to be
        returned is known at compile time and you don't mind having a string of
        bytes in your SV. Use T_ARRAY to push a variable number of arguments
        onto the return stack (they won't be packed as a single string
      though).</p>
    <p class="Pp">This is similar to using T_OPAQUEPTR but can be used to
        process more than one element.</p>
  </dd>
  <dt>T_PACKED</dt>
  <dd>Calls user-supplied functions for conversion. For
      <span class="Li">&quot;OUTPUT&quot;</span> (XSUB to Perl), a function
      named <span class="Li">&quot;XS_pack_$ntype&quot;</span> is called with
      the output Perl scalar and the C variable to convert from.
      <span class="Li">$ntype</span> is the normalized C type that is to be
      mapped to Perl. Normalized means that all
      <span class="Li">&quot;*&quot;</span> are replaced by the string
      <span class="Li">&quot;Ptr&quot;</span>. The return value of the function
      is ignored.
    <p class="Pp">Conversely for <span class="Li">&quot;INPUT&quot;</span> (Perl
        to XSUB) mapping, the function named
        <span class="Li">&quot;XS_unpack_$ntype&quot;</span> is called with the
        input Perl scalar as argument and the return value is cast to the mapped
        C type and assigned to the output C variable.</p>
    <p class="Pp">An example conversion function for a typemapped struct
        <span class="Li">&quot;foo_t *&quot;</span> might be:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  static void
  XS_pack_foo_tPtr(SV *out, foo_t *in)
  {
    dTHX; /* alas, signature does not include pTHX_ */
    HV* hash = newHV();
    hv_stores(hash, &quot;int_member&quot;, newSViv(in-&gt;int_member));
    hv_stores(hash, &quot;float_member&quot;, newSVnv(in-&gt;float_member));
    /* ... */

    /* mortalize as thy stack is not refcounted */
    sv_setsv(out, sv_2mortal(newRV_noinc((SV*)hash)));
  }
    </pre>
    <p class="Pp">The conversion from Perl to C is left as an exercise to the
        reader, but the prototype would be:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  static foo_t *
  XS_unpack_foo_tPtr(SV *in);
    </pre>
    <p class="Pp">Instead of an actual C function that has to fetch the thread
        context using <span class="Li">&quot;dTHX&quot;</span>, you can define
        macros of the same name and avoid the overhead. Also, keep in mind to
        possibly free the memory allocated by
        <span class="Li">&quot;XS_unpack_foo_tPtr&quot;</span>.</p>
  </dd>
  <dt>T_PACKEDARRAY</dt>
  <dd>T_PACKEDARRAY is similar to T_PACKED. In fact, the
      <span class="Li">&quot;INPUT&quot;</span> (Perl to XSUB) typemap is
      identical, but the <span class="Li">&quot;OUTPUT&quot;</span> typemap
      passes an additional argument to the
      <span class="Li">&quot;XS_pack_$ntype&quot;</span> function. This third
      parameter indicates the number of elements in the output so that the
      function can handle C arrays sanely. The variable needs to be declared by
      the user and must have the name
      <span class="Li">&quot;count_$ntype&quot;</span> where
      <span class="Li">$ntype</span> is the normalized C type name as explained
      above. The signature of the function would be for the example above and
      <span class="Li">&quot;foo_t **&quot;</span>:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  static void
  XS_pack_foo_tPtrPtr(SV *out, foo_t *in, UV count_foo_tPtrPtr);
    </pre>
    <p class="Pp">The type of the third parameter is arbitrary as far as the
        typemap is concerned. It just has to be in line with the declared
        variable.</p>
    <p class="Pp">Of course, unless you know the number of elements in the
        <span class="Li">&quot;sometype **&quot;</span> C array, within your
        XSUB, the return value from <span class="Li">&quot;foo_t **
        XS_unpack_foo_tPtrPtr(...)&quot;</span> will be hard to decipher. Since
        the details are all up to the XS author (the typemap user), there are
        several solutions, none of which particularly elegant. The most commonly
        seen solution has been to allocate memory for N+1 pointers and assign
        <span class="Li">&quot;NULL&quot;</span> to the (N+1)th to facilitate
        iteration.</p>
    <p class="Pp">Alternatively, using a customized typemap for your purposes in
        the first place is probably preferable.</p>
  </dd>
  <dt>T_DATAUNIT</dt>
  <dd>NOT YET</dd>
  <dt>T_CALLBACK</dt>
  <dd>NOT YET</dd>
  <dt>T_ARRAY</dt>
  <dd>This is used to convert the perl argument list to a C array and for
      pushing the contents of a C array onto the perl argument stack.
    <p class="Pp">The usual calling signature is</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  @out = array_func( @in );
    </pre>
    <p class="Pp">Any number of arguments can occur in the list before the array
        but the input and output arrays must be the last elements in the
      list.</p>
    <p class="Pp">When used to pass a perl list to C the XS writer must provide
        a function (named after the array type but with 'Ptr' substituted for
        '*') to allocate the memory required to hold the list. A pointer should
        be returned. It is up to the XS writer to free the memory on exit from
        the function. The variable <span class="Li">&quot;ix_$var&quot;</span>
        is set to the number of elements in the new array.</p>
    <p class="Pp">When returning a C array to Perl the XS writer must provide an
        integer variable called <span class="Li">&quot;size_$var&quot;</span>
        containing the number of elements in the array. This is used to
        determine how many elements should be pushed onto the return argument
        stack. This is not required on input since Perl knows how many arguments
        are on the stack when the routine is called. Ordinarily this variable
        would be called <span class="Li">&quot;size_RETVAL&quot;</span>.</p>
    <p class="Pp">Additionally, the type of each element is determined from the
        type of the array. If the array uses type
        <span class="Li">&quot;intArray *&quot;</span> xsubpp will automatically
        work out that it contains variables of type
        <span class="Li">&quot;int&quot;</span> and use that typemap entry to
        perform the copy of each element. All pointer '*' and 'Array' tags are
        removed from the name to determine the subtype.</p>
  </dd>
  <dt>T_STDIO</dt>
  <dd>This is used for passing perl filehandles to and from C using
      <span class="Li">&quot;FILE *&quot;</span> structures.</dd>
  <dt>T_INOUT</dt>
  <dd>This is used for passing perl filehandles to and from C using
      <span class="Li">&quot;PerlIO *&quot;</span> structures. The file handle
      can used for reading and writing. This corresponds to the
      <span class="Li">&quot;+&lt;&quot;</span> mode, see also T_IN and T_OUT.
    <p class="Pp">See perliol for more information on the Perl IO abstraction
        layer. Perl must have been built with
        <span class="Li">&quot;-Duseperlio&quot;</span>.</p>
    <p class="Pp">There is no check to assert that the filehandle passed from
        Perl to C was created with the right
        <span class="Li">&quot;open()&quot;</span> mode.</p>
    <p class="Pp">Hint: The perlxstut tutorial covers the T_INOUT, T_IN, and
        T_OUT XS types nicely.</p>
  </dd>
  <dt>T_IN</dt>
  <dd>Same as T_INOUT, but the filehandle that is returned from C to Perl can
      only be used for reading (mode
    <span class="Li">&quot;&lt;&quot;</span>).</dd>
  <dt>T_OUT</dt>
  <dd>Same as T_INOUT, but the filehandle that is returned from C to Perl is set
      to use the open mode <span class="Li">&quot;+&gt;&quot;</span>.</dd>
</dl>
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-24</td>
    <td class="foot-os">perl v5.30.1</td>
  </tr>
</table>

	</div>
	<div class=footer>
		<p>Copyright 2020 Scott Court</p>
	</div>
	</div>
</body>
