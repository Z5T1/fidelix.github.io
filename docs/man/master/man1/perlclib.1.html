
<!DOCTYPE HTML>
<head>
	<title>/usr/share/man/man1/perlclib.1</title>		<link rel='stylesheet' href='/mandoc.css' />
	<link rel='stylesheet' href='/style.css' />
</head>
<body>
	<div class=contents>
	<div class=header>
	<h1>The Fidelix Linux Distribution</h1>
	<h2>Simple, Stable, and Secure</h2>
	</div>
<div class=menubar>
	<ul>
		<li><a href=/>News</a></li>
		<li><a href=/about.html>About</a></li>
		<div class=dropdown>
			<li><a href=/download>Download</a></li>
			<ul class=dropdown-content>
				<li><a href=/download/>Latest Downloads</a></li>
				<li><a href=/download/all.html>All Downloads</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Documentation</a></li>
			<ul class=dropdown-content>
				<li><a href=https://github.com/fidelix-project/fidelix/blob/master/doc/README.md>Handbook</a></li>
				<li><a href=/man/>Manual Pages</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Development</a></li>
			<ul class=dropdown-content>
				<li><a href=https://github.com/fidelix-project>GitHub</a></li>
			</ul>
		</div>
		<div class=dropdown>
			<li><a href=#>Community</a></li>
			<ul class=dropdown-content>
				<li><a href=https://discord.com/invite/Yz8DeUr>Discord</a></li>
				<li><a href=/get-involved.html>Get Involved</a></li>
				<li><a href=/contact.html>Contact Us</a></li>
			</ul>
		</div>
	</ul>
</div>


	<div class=body><table class="head">
  <tr>
    <td class="head-ltitle">PERLCLIB(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLCLIB(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlclib - Internal replacements for standard C library functions
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
One thing Perl porters should note is that <i>perl</i> doesn't tend to use that
  much of the C standard library internally; you'll see very little use of, for
  example, the <i>ctype.h</i> functions in there. This is because Perl tends to
  reimplement or abstract standard library functions, so that we know exactly
  how they're going to operate.
<p class="Pp">This is a reference card for people who are familiar with the C
    library and who want to do things the Perl way; to tell them which functions
    they ought to use instead of the more normal C functions.</p>
<section class="Ss">
<h2 class="Ss" id="Conventions"><a class="permalink" href="#Conventions">Conventions</a></h2>
In the following tables:
<dl class="Bl-tag">
  <dt>&quot;t&quot;</dt>
  <dd>is a type.</dd>
  <dt>&quot;p&quot;</dt>
  <dd>is a pointer.</dd>
  <dt>&quot;n&quot;</dt>
  <dd>is a number.</dd>
  <dt>&quot;s&quot;</dt>
  <dd>is a string.</dd>
</dl>
<p class="Pp"><span class="Li">&quot;sv&quot;</span>,
    <span class="Li">&quot;av&quot;</span>,
    <span class="Li">&quot;hv&quot;</span>, etc. represent variables of their
    respective types.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="File_Operations"><a class="permalink" href="#File_Operations">File
  Operations</a></h2>
Instead of the <i>stdio.h</i> functions, you should use the Perl abstraction
  layer. Instead of <span class="Li">&quot;FILE*&quot;</span> types, you need to
  be handling <span class="Li">&quot;PerlIO*&quot;</span> types. Don't forget
  that with the new PerlIO layered I/O abstraction
  <span class="Li">&quot;FILE*&quot;</span> types may not even be available. See
  also the <span class="Li">&quot;perlapio&quot;</span> documentation for more
  information about the following functions:
<p class="Pp"><span class="Li"></span></p>
<pre>
 Instead Of:                 Use:

 stdin                       PerlIO_stdin()
 stdout                      PerlIO_stdout()
 stderr                      PerlIO_stderr()

 fopen(fn, mode)             PerlIO_open(fn, mode)
 freopen(fn, mode, stream)   PerlIO_reopen(fn, mode, perlio) (Dep-
                               recated)
 fflush(stream)              PerlIO_flush(perlio)
 fclose(stream)              PerlIO_close(perlio)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="File_Input_and_Output"><a class="permalink" href="#File_Input_and_Output">File
  Input and Output</a></h2>
<span class="Li"></span>
<pre>
 Instead Of:                 Use:

 fprintf(stream, fmt, ...)   PerlIO_printf(perlio, fmt, ...)

 [f]getc(stream)             PerlIO_getc(perlio)
 [f]putc(stream, n)          PerlIO_putc(perlio, n)
 ungetc(n, stream)           PerlIO_ungetc(perlio, n)
</pre>
<p class="Pp">Note that the PerlIO equivalents of
    <span class="Li">&quot;fread&quot;</span> and
    <span class="Li">&quot;fwrite&quot;</span> are slightly different from their
    C library counterparts:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 fread(p, size, n, stream)   PerlIO_read(perlio, buf, numbytes)
 fwrite(p, size, n, stream)  PerlIO_write(perlio, buf, numbytes)

 fputs(s, stream)            PerlIO_puts(perlio, s)
</pre>
<p class="Pp">There is no equivalent to
    <span class="Li">&quot;fgets&quot;</span>; one should use
    <span class="Li">&quot;sv_gets&quot;</span> instead:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 fgets(s, n, stream)         sv_gets(sv, perlio, append)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="File_Positioning"><a class="permalink" href="#File_Positioning">File
  Positioning</a></h2>
<span class="Li"></span>
<pre>
 Instead Of:                 Use:

 feof(stream)                PerlIO_eof(perlio)
 fseek(stream, n, whence)    PerlIO_seek(perlio, n, whence)
 rewind(stream)              PerlIO_rewind(perlio)

 fgetpos(stream, p)          PerlIO_getpos(perlio, sv)
 fsetpos(stream, p)          PerlIO_setpos(perlio, sv)

 ferror(stream)              PerlIO_error(perlio)
 clearerr(stream)            PerlIO_clearerr(perlio)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Memory_Management_and_String_Handling"><a class="permalink" href="#Memory_Management_and_String_Handling">Memory
  Management and String Handling</a></h2>
<span class="Li"></span>
<pre>
 Instead Of:                    Use:

 t* p = malloc(n)               Newx(p, n, t)
 t* p = calloc(n, s)            Newxz(p, n, t)
 p = realloc(p, n)              Renew(p, n, t)
 memcpy(dst, src, n)            Copy(src, dst, n, t)
 memmove(dst, src, n)           Move(src, dst, n, t)
 memcpy(dst, src, sizeof(t))    StructCopy(src, dst, t)
 memset(dst, 0, n * sizeof(t))  Zero(dst, n, t)
 memzero(dst, 0)                Zero(dst, n, char)
 free(p)                        Safefree(p)

 strdup(p)                      savepv(p)
 strndup(p, n)                  savepvn(p, n) (Hey, strndup doesn't
                                               exist!)

 strstr(big, little)            instr(big, little)
 strcmp(s1, s2)                 strLE(s1, s2) / strEQ(s1, s2)
                                              / strGT(s1,s2)
 strncmp(s1, s2, n)             strnNE(s1, s2, n) / strnEQ(s1, s2, n)

 memcmp(p1, p2, n)              memNE(p1, p2, n)
 !memcmp(p1, p2, n)             memEQ(p1, p2, n)
</pre>
<p class="Pp">Notice the different order of arguments to
    <span class="Li">&quot;Copy&quot;</span> and
    <span class="Li">&quot;Move&quot;</span> than used in
    <span class="Li">&quot;memcpy&quot;</span> and
    <span class="Li">&quot;memmove&quot;</span>.</p>
<p class="Pp">Most of the time, though, you'll want to be dealing with SVs
    internally instead of raw <span class="Li">&quot;char *&quot;</span>
    strings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 strlen(s)                   sv_len(sv)
 strcpy(dt, src)             sv_setpv(sv, s)
 strncpy(dt, src, n)         sv_setpvn(sv, s, n)
 strcat(dt, src)             sv_catpv(sv, s)
 strncat(dt, src)            sv_catpvn(sv, s)
 sprintf(s, fmt, ...)        sv_setpvf(sv, fmt, ...)
</pre>
<p class="Pp">Note also the existence of
    <span class="Li">&quot;sv_catpvf&quot;</span> and
    <span class="Li">&quot;sv_vcatpvfn&quot;</span>, combining concatenation
    with formatting.</p>
<p class="Pp">Sometimes instead of zeroing the allocated heap by using
    <b>Newxz()</b> you should consider &quot;poisoning&quot; the data. This
    means writing a bit pattern into it that should be illegal as pointers (and
    floating point numbers), and also hopefully surprising enough as integers,
    so that any code attempting to use the data without forethought will break
    sooner rather than later. Poisoning can be done using the <b>Poison()</b>
    macros, which have similar arguments to <b>Zero()</b>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 PoisonWith(dst, n, t, b)    scribble memory with byte b
 PoisonNew(dst, n, t)        equal to PoisonWith(dst, n, t, 0xAB)
 PoisonFree(dst, n, t)       equal to PoisonWith(dst, n, t, 0xEF)
 Poison(dst, n, t)           equal to PoisonFree(dst, n, t)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Character_Class_Tests"><a class="permalink" href="#Character_Class_Tests">Character
  Class Tests</a></h2>
There are several types of character class tests that Perl implements. The only
  ones described here are those that directly correspond to C library functions
  that operate on 8-bit characters, but there are equivalents that operate on
  wide characters, and UTF-8 encoded strings. All are more fully described in
  &quot;Character classification&quot; in perlapi and &quot;Character case
  changing&quot; in perlapi.
<p class="Pp">The C library routines listed in the table below return values
    based on the current locale. Use the entries in the final column for that
    functionality. The other two columns always assume a POSIX (or C) locale.
    The entries in the ASCII column are only meaningful for ASCII inputs,
    returning FALSE for anything else. Use these only when you <b>know</b> that
    is what you want. The entries in the Latin1 column assume that the non-ASCII
    8-bit characters are as Unicode defines, them, the same as ISO-8859-1, often
    called Latin 1.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 Instead Of:  Use for ASCII:   Use for Latin1:      Use for locale:

 isalnum(c)  isALPHANUMERIC(c) isALPHANUMERIC_L1(c) isALPHANUMERIC_LC(c)
 isalpha(c)  isALPHA(c)        isALPHA_L1(c)        isALPHA_LC(u )
 isascii(c)  isASCII(c)                             isASCII_LC(c)
 isblank(c)  isBLANK(c)        isBLANK_L1(c)        isBLANK_LC(c)
 iscntrl(c)  isCNTRL(c)        isCNTRL_L1(c)        isCNTRL_LC(c)
 isdigit(c)  isDIGIT(c)        isDIGIT_L1(c)        isDIGIT_LC(c)
 isgraph(c)  isGRAPH(c)        isGRAPH_L1(c)        isGRAPH_LC(c)
 islower(c)  isLOWER(c)        isLOWER_L1(c)        isLOWER_LC(c)
 isprint(c)  isPRINT(c)        isPRINT_L1(c)        isPRINT_LC(c)
 ispunct(c)  isPUNCT(c)        isPUNCT_L1(c)        isPUNCT_LC(c)
 isspace(c)  isSPACE(c)        isSPACE_L1(c)        isSPACE_LC(c)
 isupper(c)  isUPPER(c)        isUPPER_L1(c)        isUPPER_LC(c)
 isxdigit(c) isXDIGIT(c)       isXDIGIT_L1(c)       isXDIGIT_LC(c)

 tolower(c)  toLOWER(c)        toLOWER_L1(c)        toLOWER_LC(c)
 toupper(c)  toUPPER(c)                             toUPPER_LC(c)
</pre>
<p class="Pp">To emphasize that you are operating only on ASCII characters, you
    can append <span class="Li">&quot;_A&quot;</span> to each of the macros in
    the ASCII column: <span class="Li">&quot;isALPHA_A&quot;</span>,
    <span class="Li">&quot;isDIGIT_A&quot;</span>, and so on.</p>
<p class="Pp">(There is no entry in the Latin1 column for
    <span class="Li">&quot;isascii&quot;</span> even though there is an
    <span class="Li">&quot;isASCII_L1&quot;</span>, which is identical to
    <span class="Li">&quot;isASCII&quot;</span>; the latter name is clearer.
    There is no entry in the Latin1 column for
    <span class="Li">&quot;toupper&quot;</span> because the result can be
    non-Latin1. You have to use <span class="Li">&quot;toUPPER_uni&quot;</span>,
    as described in &quot;Character case changing&quot; in perlapi.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIstdlib.h_fP_functions"><a class="permalink" href="#_fIstdlib.h_fP_functions"><i>stdlib.h</i>
  functions</a></h2>
<span class="Li"></span>
<pre>
 Instead Of:                 Use:

 atof(s)                     Atof(s)
 atoi(s)                     grok_atoUV(s, &amp;uv, &amp;e)
 atol(s)                     grok_atoUV(s, &amp;uv, &amp;e)
 strtod(s, &amp;p)               my_atof3(s, &amp;nv, &amp;p) is the closest we have
 strtol(s, &amp;p, n)            grok_atoUV(s, &amp;uv, &amp;e)
 strtoul(s, &amp;p, n)           grok_atoUV(s, &amp;uv, &amp;e)
</pre>
<p class="Pp">Typical use is to do range checks on
    <span class="Li">&quot;uv&quot;</span> before casting:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  int i; UV uv;
  char* end_ptr = input_end;
  if (grok_atoUV(input, &amp;uv, &amp;end_ptr)
      &amp;&amp; uv &lt;= INT_MAX)
    i = (int)uv;
    ... /* continue parsing from end_ptr */
  } else {
    ... /* parse error: not a decimal integer in range 0 .. MAX_IV */
  }
</pre>
<p class="Pp">Notice also the <span class="Li">&quot;grok_bin&quot;</span>,
    <span class="Li">&quot;grok_hex&quot;</span>, and
    <span class="Li">&quot;grok_oct&quot;</span> functions in <i>numeric.c</i>
    for converting strings representing numbers in the respective bases into
    <span class="Li">&quot;NV&quot;</span>s. Note that <b>grok_atoUV()</b>
    doesn't handle negative inputs, or leading whitespace (being purposefully
    strict).</p>
<p class="Pp">Note that <b>strtol()</b> and <b>strtoul()</b> may be disguised as
    <b>Strtol()</b>, <b>Strtoul()</b>, <b>Atol()</b>, <b>Atoul()</b>. Avoid
    those, too.</p>
<p class="Pp">In theory <span class="Li">&quot;Strtol&quot;</span> and
    <span class="Li">&quot;Strtoul&quot;</span> may not be defined if the
    machine perl is built on doesn't actually have strtol and strtoul. But as
    those 2 functions are part of the 1989 ANSI C spec we suspect you'll find
    them everywhere by now.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 int rand()                  double Drand01()
 srand(n)                    { seedDrand01((Rand_seed_t)n);
                               PL_srand_called = TRUE; }

 exit(n)                     my_exit(n)
 system(s)                   Don't. Look at pp_system or use my_popen.

 getenv(s)                   PerlEnv_getenv(s)
 setenv(s, val)              my_setenv(s, val)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Miscellaneous_functions"><a class="permalink" href="#Miscellaneous_functions">Miscellaneous
  functions</a></h2>
You should not even <b>want</b> to use <i>setjmp.h</i> functions, but if you
  think you do, use the <span class="Li">&quot;JMPENV&quot;</span> stack in
  <i>scope.h</i> instead.
<p class="Pp">For
    <span class="Li">&quot;signal&quot;</span>/<span class="Li">&quot;sigaction&quot;</span>,
    use <span class="Li">&quot;rsignal(signo, handler)&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlapi, perlapio, perlguts
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>

	</div>
	<div class=footer>
		<p>Copyright 2020 Scott Court</p>
	</div>
	</div>
</body>
